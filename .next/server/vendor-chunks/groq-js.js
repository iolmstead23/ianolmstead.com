"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/groq-js";
exports.ids = ["vendor-chunks/groq-js"];
exports.modules = {

/***/ "(ssr)/./node_modules/groq-js/dist/1.mjs":
/*!*****************************************!*\
  !*** ./node_modules/groq-js/dist/1.mjs ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DateTime: () => (/* binding */ DateTime),\n/* harmony export */   Path: () => (/* binding */ Path),\n/* harmony export */   evaluate: () => (/* binding */ evaluateQuery),\n/* harmony export */   parse: () => (/* binding */ parse)\n/* harmony export */ });\nvar __defProp$5 = Object.defineProperty, __defNormalProp$5 = (obj, key, value)=>key in obj ? __defProp$5(obj, key, {\n        enumerable: !0,\n        configurable: !0,\n        writable: !0,\n        value\n    }) : obj[key] = value, __publicField$5 = (obj, key, value)=>(__defNormalProp$5(obj, typeof key != \"symbol\" ? key + \"\" : key, value), value);\nfunction escapeRegExp(string) {\n    return string.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n}\nfunction pathRegExp(pattern) {\n    const re = [];\n    for (const part of pattern.split(\".\"))part === \"*\" ? re.push(\"[^.]+\") : part === \"**\" ? re.push(\".*\") : re.push(escapeRegExp(part));\n    return new RegExp(`^${re.join(\".\")}$`);\n}\nclass Path {\n    constructor(pattern){\n        __publicField$5(this, \"pattern\"), __publicField$5(this, \"patternRe\"), this.pattern = pattern, this.patternRe = pathRegExp(pattern);\n    }\n    matches(str) {\n        return this.patternRe.test(str);\n    }\n    toJSON() {\n        return this.pattern;\n    }\n}\nvar __defProp$4 = Object.defineProperty, __defNormalProp$4 = (obj, key, value)=>key in obj ? __defProp$4(obj, key, {\n        enumerable: !0,\n        configurable: !0,\n        writable: !0,\n        value\n    }) : obj[key] = value, __publicField$4 = (obj, key, value)=>(__defNormalProp$4(obj, typeof key != \"symbol\" ? key + \"\" : key, value), value);\nclass StreamValue {\n    constructor(generator){\n        __publicField$4(this, \"type\", \"stream\"), __publicField$4(this, \"generator\"), __publicField$4(this, \"ticker\"), __publicField$4(this, \"isDone\"), __publicField$4(this, \"data\"), this.generator = generator, this.ticker = null, this.isDone = !1, this.data = [];\n    }\n    // eslint-disable-next-line class-methods-use-this\n    isArray() {\n        return !0;\n    }\n    async get() {\n        const result = [];\n        for await (const value of this)result.push(await value.get());\n        return result;\n    }\n    async *[Symbol.asyncIterator]() {\n        let i = 0;\n        for(;;){\n            for(; i < this.data.length; i++)yield this.data[i];\n            if (this.isDone) return;\n            await this._nextTick();\n        }\n    }\n    _nextTick() {\n        if (this.ticker) return this.ticker;\n        let currentResolver;\n        const setupTicker = ()=>{\n            this.ticker = new Promise((resolve)=>{\n                currentResolver = resolve;\n            });\n        }, tick = ()=>{\n            currentResolver(), setupTicker();\n        }, fetch = async ()=>{\n            for await (const value of this.generator())this.data.push(value), tick();\n            this.isDone = !0, tick();\n        };\n        return setupTicker(), fetch(), this.ticker;\n    }\n}\nconst RFC3339_REGEX = /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|([-+]\\d{2}:\\d{2}))$/;\nfunction parseRFC3339(str) {\n    return RFC3339_REGEX.test(str) ? new Date(str) : null;\n}\nfunction formatRFC3339(d) {\n    const year = addLeadingZero(d.getUTCFullYear(), 4), month = addLeadingZero(d.getUTCMonth() + 1, 2), day = addLeadingZero(d.getUTCDate(), 2), hour = addLeadingZero(d.getUTCHours(), 2), minute = addLeadingZero(d.getUTCMinutes(), 2), second = addLeadingZero(d.getUTCSeconds(), 2);\n    let fractionalSecond = \"\";\n    const millis = d.getMilliseconds();\n    return millis != 0 && (fractionalSecond = `.${addLeadingZero(millis, 3)}`), `${year}-${month}-${day}T${hour}:${minute}:${second}${fractionalSecond}Z`;\n}\nfunction addLeadingZero(num, targetLength) {\n    let str = num.toString();\n    for(; str.length < targetLength;)str = `0${str}`;\n    return str;\n}\nvar __defProp$3 = Object.defineProperty, __defNormalProp$3 = (obj, key, value)=>key in obj ? __defProp$3(obj, key, {\n        enumerable: !0,\n        configurable: !0,\n        writable: !0,\n        value\n    }) : obj[key] = value, __publicField$3 = (obj, key, value)=>(__defNormalProp$3(obj, typeof key != \"symbol\" ? key + \"\" : key, value), value);\nclass StaticValue {\n    constructor(data, type){\n        __publicField$3(this, \"data\"), __publicField$3(this, \"type\"), this.data = data, this.type = type;\n    }\n    isArray() {\n        return this.type === \"array\";\n    }\n    // eslint-disable-next-line require-await\n    async get() {\n        return this.data;\n    }\n    [Symbol.asyncIterator]() {\n        if (Array.isArray(this.data)) return function*(data) {\n            for (const element of data)yield fromJS(element);\n        }(this.data);\n        throw new Error(`Cannot iterate over: ${this.type}`);\n    }\n}\nconst NULL_VALUE = new StaticValue(null, \"null\"), TRUE_VALUE = new StaticValue(!0, \"boolean\"), FALSE_VALUE = new StaticValue(!1, \"boolean\");\nclass DateTime {\n    constructor(date){\n        __publicField$3(this, \"date\"), this.date = date;\n    }\n    static parseToValue(str) {\n        const date = parseRFC3339(str);\n        return date ? new StaticValue(new DateTime(date), \"datetime\") : NULL_VALUE;\n    }\n    equals(other) {\n        return this.date.getTime() == other.date.getTime();\n    }\n    add(secs) {\n        const copy = new Date(this.date.getTime());\n        return copy.setTime(copy.getTime() + secs * 1e3), new DateTime(copy);\n    }\n    difference(other) {\n        return (this.date.getTime() - other.date.getTime()) / 1e3;\n    }\n    compareTo(other) {\n        return this.date.getTime() - other.date.getTime();\n    }\n    toString() {\n        return formatRFC3339(this.date);\n    }\n    toJSON() {\n        return this.toString();\n    }\n}\nfunction fromNumber(num) {\n    return Number.isFinite(num) ? new StaticValue(num, \"number\") : NULL_VALUE;\n}\nfunction fromString(str) {\n    return new StaticValue(str, \"string\");\n}\nfunction fromDateTime(dt) {\n    return new StaticValue(dt, \"datetime\");\n}\nfunction fromPath(path) {\n    return new StaticValue(path, \"path\");\n}\nfunction isIterator(obj) {\n    return obj && typeof obj.next == \"function\";\n}\nfunction fromJS(val) {\n    return isIterator(val) ? new StreamValue(async function*() {\n        for await (const value of val)yield fromJS(value);\n    }) : val == null ? NULL_VALUE : new StaticValue(val, getType(val));\n}\nfunction getType(data) {\n    return data === null || typeof data > \"u\" ? \"null\" : Array.isArray(data) ? \"array\" : data instanceof Path ? \"path\" : data instanceof DateTime ? \"datetime\" : typeof data;\n}\nfunction isEqual(a, b) {\n    return a.type === \"string\" && b.type === \"string\" || a.type === \"boolean\" && b.type === \"boolean\" || a.type === \"null\" && b.type === \"null\" || a.type === \"number\" && b.type === \"number\" ? a.data === b.data : a.type === \"datetime\" && b.type === \"datetime\" ? a.data.equals(b.data) : !1;\n}\nconst CHARS = /([^!@#$%^&*(),\\\\/?\";:{}|[\\]+<>\\s-])+/g, CHARS_WITH_WILDCARD = /([^!@#$%^&(),\\\\/?\";:{}|[\\]+<>\\s-])+/g, EDGE_CHARS = /(\\b\\.+|\\.+\\b)/g, MAX_TERM_LENGTH = 1024;\nfunction matchText(tokens, patterns) {\n    return tokens.length === 0 || patterns.length === 0 ? !1 : patterns.every((pattern)=>pattern(tokens));\n}\nfunction matchTokenize(text) {\n    return text.replace(EDGE_CHARS, \"\").match(CHARS) || [];\n}\nfunction matchAnalyzePattern(text) {\n    return matchPatternRegex(text).map((re)=>(tokens)=>tokens.some((token)=>re.test(token)));\n}\nfunction matchPatternRegex(text) {\n    return (text.replace(EDGE_CHARS, \"\").match(CHARS_WITH_WILDCARD) || []).map((term)=>new RegExp(`^${term.slice(0, MAX_TERM_LENGTH).replace(/\\*/g, \".*\")}$`, \"i\"));\n}\nasync function gatherText(value, cb) {\n    if (value.type === \"string\") return cb(value.data), !0;\n    if (value.isArray()) {\n        let success = !0;\n        for await (const part of value)part.type === \"string\" ? cb(part.data) : success = !1;\n        return success;\n    }\n    return !1;\n}\nconst TYPE_ORDER = {\n    datetime: 1,\n    number: 2,\n    string: 3,\n    boolean: 4\n};\nfunction partialCompare(a, b) {\n    const aType = getType(a), bType = getType(b);\n    if (aType !== bType) return null;\n    switch(aType){\n        case \"number\":\n        case \"boolean\":\n            return a - b;\n        case \"string\":\n            return a < b ? -1 : a > b ? 1 : 0;\n        case \"datetime\":\n            return a.compareTo(b);\n        default:\n            return null;\n    }\n}\nfunction totalCompare(a, b) {\n    const aType = getType(a), bType = getType(b), aTypeOrder = TYPE_ORDER[aType] || 100, bTypeOrder = TYPE_ORDER[bType] || 100;\n    if (aTypeOrder !== bTypeOrder) return aTypeOrder - bTypeOrder;\n    let result = partialCompare(a, b);\n    return result === null && (result = 0), result;\n}\nconst operators = {\n    \"==\": function(left, right) {\n        return isEqual(left, right) ? TRUE_VALUE : FALSE_VALUE;\n    },\n    \"!=\": function(left, right) {\n        return isEqual(left, right) ? FALSE_VALUE : TRUE_VALUE;\n    },\n    \">\": function(left, right) {\n        if (left.type === \"stream\" || right.type === \"stream\") return NULL_VALUE;\n        const result = partialCompare(left.data, right.data);\n        return result === null ? NULL_VALUE : result > 0 ? TRUE_VALUE : FALSE_VALUE;\n    },\n    \">=\": function(left, right) {\n        if (left.type === \"stream\" || right.type === \"stream\") return NULL_VALUE;\n        const result = partialCompare(left.data, right.data);\n        return result === null ? NULL_VALUE : result >= 0 ? TRUE_VALUE : FALSE_VALUE;\n    },\n    \"<\": function(left, right) {\n        if (left.type === \"stream\" || right.type === \"stream\") return NULL_VALUE;\n        const result = partialCompare(left.data, right.data);\n        return result === null ? NULL_VALUE : result < 0 ? TRUE_VALUE : FALSE_VALUE;\n    },\n    \"<=\": function(left, right) {\n        if (left.type === \"stream\" || right.type === \"stream\") return NULL_VALUE;\n        const result = partialCompare(left.data, right.data);\n        return result === null ? NULL_VALUE : result <= 0 ? TRUE_VALUE : FALSE_VALUE;\n    },\n    // eslint-disable-next-line func-name-matching\n    in: async function(left, right) {\n        if (right.type === \"path\") return left.type !== \"string\" ? NULL_VALUE : right.data.matches(left.data) ? TRUE_VALUE : FALSE_VALUE;\n        if (right.isArray()) {\n            for await (const b of right)if (isEqual(left, b)) return TRUE_VALUE;\n            return FALSE_VALUE;\n        }\n        return NULL_VALUE;\n    },\n    match: async function(left, right) {\n        let tokens = [], patterns = [];\n        return await gatherText(left, (part)=>{\n            tokens = tokens.concat(matchTokenize(part));\n        }), await gatherText(right, (part)=>{\n            patterns = patterns.concat(matchAnalyzePattern(part));\n        }) && matchText(tokens, patterns) ? TRUE_VALUE : FALSE_VALUE;\n    },\n    \"+\": function(left, right) {\n        return left.type === \"datetime\" && right.type === \"number\" ? fromDateTime(left.data.add(right.data)) : left.type === \"number\" && right.type === \"number\" ? fromNumber(left.data + right.data) : left.type === \"string\" && right.type === \"string\" ? fromString(left.data + right.data) : left.type === \"object\" && right.type === \"object\" ? fromJS({\n            ...left.data,\n            ...right.data\n        }) : left.type === \"array\" && right.type === \"array\" ? fromJS(left.data.concat(right.data)) : left.isArray() && right.isArray() ? new StreamValue(async function*() {\n            for await (const val of left)yield val;\n            for await (const val of right)yield val;\n        }) : NULL_VALUE;\n    },\n    \"-\": function(left, right) {\n        return left.type === \"datetime\" && right.type === \"number\" ? fromDateTime(left.data.add(-right.data)) : left.type === \"datetime\" && right.type === \"datetime\" ? fromNumber(left.data.difference(right.data)) : left.type === \"number\" && right.type === \"number\" ? fromNumber(left.data - right.data) : NULL_VALUE;\n    },\n    \"*\": numericOperator((a, b)=>a * b),\n    \"/\": numericOperator((a, b)=>a / b),\n    \"%\": numericOperator((a, b)=>a % b),\n    \"**\": numericOperator((a, b)=>Math.pow(a, b))\n};\nfunction numericOperator(impl) {\n    return function(left, right) {\n        if (left.type === \"number\" && right.type === \"number\") {\n            const result = impl(left.data, right.data);\n            return fromNumber(result);\n        }\n        return NULL_VALUE;\n    };\n}\nvar __defProp$2 = Object.defineProperty, __defNormalProp$2 = (obj, key, value)=>key in obj ? __defProp$2(obj, key, {\n        enumerable: !0,\n        configurable: !0,\n        writable: !0,\n        value\n    }) : obj[key] = value, __publicField$2 = (obj, key, value)=>(__defNormalProp$2(obj, typeof key != \"symbol\" ? key + \"\" : key, value), value);\nclass Scope {\n    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n    constructor(params, source, value, context, parent){\n        __publicField$2(this, \"params\"), __publicField$2(this, \"source\"), __publicField$2(this, \"value\"), __publicField$2(this, \"parent\"), __publicField$2(this, \"context\"), __publicField$2(this, \"isHidden\", !1), this.params = params, this.source = source, this.value = value, this.context = context, this.parent = parent;\n    }\n    createNested(value) {\n        return this.isHidden ? new Scope(this.params, this.source, value, this.context, this.parent) : new Scope(this.params, this.source, value, this.context, this);\n    }\n    createHidden(value) {\n        const result = this.createNested(value);\n        return result.isHidden = !0, result;\n    }\n}\nfunction evaluate(node, scope, execute = evaluate) {\n    const func = EXECUTORS[node.type];\n    return func(node, scope, execute);\n}\nfunction promiselessApply(value, cb) {\n    return \"then\" in value ? value.then(cb) : cb(value);\n}\nconst EXECUTORS = {\n    This (_, scope) {\n        return scope.value;\n    },\n    Selector () {\n        throw new Error(\"Selectors can not be evaluated\");\n    },\n    Everything (_, scope) {\n        return scope.source;\n    },\n    Parameter ({ name }, scope) {\n        return fromJS(scope.params[name]);\n    },\n    Context ({ key }, scope) {\n        if (key === \"before\" || key === \"after\") return scope.context[key] || NULL_VALUE;\n        throw new Error(`unknown context key: ${key}`);\n    },\n    Parent ({ n }, scope) {\n        let current = scope;\n        for(let i = 0; i < n; i++){\n            if (!current.parent) return NULL_VALUE;\n            current = current.parent;\n        }\n        return current.value;\n    },\n    OpCall ({ op, left, right }, scope, execute) {\n        const func = operators[op];\n        if (!func) throw new Error(`Unknown operator: ${op}`);\n        const leftValue = execute(left, scope), rightValue = execute(right, scope);\n        return \"then\" in leftValue || \"then\" in rightValue ? (async ()=>func(await leftValue, await rightValue))() : func(leftValue, rightValue);\n    },\n    async Select ({ alternatives, fallback }, scope, execute) {\n        for (const alt of alternatives){\n            const altCond = await execute(alt.condition, scope);\n            if (altCond.type === \"boolean\" && altCond.data === !0) return execute(alt.value, scope);\n        }\n        return fallback ? execute(fallback, scope) : NULL_VALUE;\n    },\n    async InRange ({ base, left, right, isInclusive }, scope, execute) {\n        const value = await execute(base, scope), leftValue = await execute(left, scope), rightValue = await execute(right, scope), leftCmp = partialCompare(await value.get(), await leftValue.get());\n        if (leftCmp === null) return NULL_VALUE;\n        const rightCmp = partialCompare(await value.get(), await rightValue.get());\n        return rightCmp === null ? NULL_VALUE : isInclusive ? leftCmp >= 0 && rightCmp <= 0 ? TRUE_VALUE : FALSE_VALUE : leftCmp >= 0 && rightCmp < 0 ? TRUE_VALUE : FALSE_VALUE;\n    },\n    async Filter ({ base, expr }, scope, execute) {\n        const baseValue = await execute(base, scope);\n        return baseValue.isArray() ? new StreamValue(async function*() {\n            for await (const elem of baseValue){\n                const newScope = scope.createNested(elem), exprValue = await execute(expr, newScope);\n                exprValue.type === \"boolean\" && exprValue.data === !0 && (yield elem);\n            }\n        }) : NULL_VALUE;\n    },\n    async Projection ({ base, expr }, scope, execute) {\n        const baseValue = await execute(base, scope);\n        if (baseValue.type !== \"object\") return NULL_VALUE;\n        const newScope = scope.createNested(baseValue);\n        return execute(expr, newScope);\n    },\n    FuncCall ({ func, args }, scope, execute) {\n        return func(args, scope, execute);\n    },\n    async PipeFuncCall ({ func, base, args }, scope, execute) {\n        const baseValue = await execute(base, scope);\n        return func(baseValue, args, scope, execute);\n    },\n    async AccessAttribute ({ base, name }, scope, execute) {\n        let value = scope.value;\n        return base && (value = await execute(base, scope)), value.type === \"object\" && value.data.hasOwnProperty(name) ? fromJS(value.data[name]) : NULL_VALUE;\n    },\n    async AccessElement ({ base, index }, scope, execute) {\n        const baseValue = await execute(base, scope);\n        if (!baseValue.isArray()) return NULL_VALUE;\n        const data = await baseValue.get(), finalIndex = index < 0 ? index + data.length : index;\n        return fromJS(data[finalIndex]);\n    },\n    async Slice ({ base, left, right, isInclusive }, scope, execute) {\n        const baseValue = await execute(base, scope);\n        if (!baseValue.isArray()) return NULL_VALUE;\n        const array2 = await baseValue.get();\n        let leftIdx = left, rightIdx = right;\n        return leftIdx < 0 && (leftIdx = array2.length + leftIdx), rightIdx < 0 && (rightIdx = array2.length + rightIdx), isInclusive && rightIdx++, leftIdx < 0 && (leftIdx = 0), rightIdx < 0 && (rightIdx = 0), fromJS(array2.slice(leftIdx, rightIdx));\n    },\n    async Deref ({ base }, scope, execute) {\n        const value = await execute(base, scope);\n        if (!scope.source.isArray() || value.type !== \"object\") return NULL_VALUE;\n        const id = value.data._ref;\n        if (typeof id != \"string\") return NULL_VALUE;\n        if (scope.context.dereference) return fromJS(await scope.context.dereference({\n            _ref: id\n        }));\n        for await (const doc of scope.source)if (doc.type === \"object\" && id === doc.data._id) return doc;\n        return NULL_VALUE;\n    },\n    Value ({ value }) {\n        return fromJS(value);\n    },\n    Group ({ base }, scope, execute) {\n        return execute(base, scope);\n    },\n    async Object ({ attributes }, scope, execute) {\n        const result = {};\n        for (const attr of attributes){\n            const attrType = attr.type;\n            switch(attr.type){\n                case \"ObjectAttributeValue\":\n                    {\n                        const value = await execute(attr.value, scope);\n                        result[attr.name] = await value.get();\n                        break;\n                    }\n                case \"ObjectConditionalSplat\":\n                    {\n                        const cond = await execute(attr.condition, scope);\n                        if (cond.type !== \"boolean\" || cond.data === !1) continue;\n                        const value = await execute(attr.value, scope);\n                        value.type === \"object\" && Object.assign(result, value.data);\n                        break;\n                    }\n                case \"ObjectSplat\":\n                    {\n                        const value = await execute(attr.value, scope);\n                        value.type === \"object\" && Object.assign(result, value.data);\n                        break;\n                    }\n                default:\n                    throw new Error(`Unknown node type: ${attrType}`);\n            }\n        }\n        return fromJS(result);\n    },\n    Array ({ elements }, scope, execute) {\n        return new StreamValue(async function*() {\n            for (const element of elements){\n                const value = await execute(element.value, scope);\n                if (element.isSplat) {\n                    if (value.isArray()) for await (const v of value)yield v;\n                } else yield value;\n            }\n        });\n    },\n    Tuple () {\n        throw new Error(\"tuples can not be evaluated\");\n    },\n    async Or ({ left, right }, scope, execute) {\n        const leftValue = await execute(left, scope), rightValue = await execute(right, scope);\n        return leftValue.type === \"boolean\" && leftValue.data === !0 || rightValue.type === \"boolean\" && rightValue.data === !0 ? TRUE_VALUE : leftValue.type !== \"boolean\" || rightValue.type !== \"boolean\" ? NULL_VALUE : FALSE_VALUE;\n    },\n    async And ({ left, right }, scope, execute) {\n        const leftValue = await execute(left, scope), rightValue = await execute(right, scope);\n        return leftValue.type === \"boolean\" && leftValue.data === !1 || rightValue.type === \"boolean\" && rightValue.data === !1 ? FALSE_VALUE : leftValue.type !== \"boolean\" || rightValue.type !== \"boolean\" ? NULL_VALUE : TRUE_VALUE;\n    },\n    async Not ({ base }, scope, execute) {\n        const value = await execute(base, scope);\n        return value.type !== \"boolean\" ? NULL_VALUE : value.data ? FALSE_VALUE : TRUE_VALUE;\n    },\n    Neg ({ base }, scope, execute) {\n        return promiselessApply(execute(base, scope), (value)=>value.type !== \"number\" ? NULL_VALUE : fromNumber(-value.data));\n    },\n    Pos ({ base }, scope, execute) {\n        return promiselessApply(execute(base, scope), (value)=>value.type !== \"number\" ? NULL_VALUE : fromNumber(value.data));\n    },\n    Asc () {\n        return NULL_VALUE;\n    },\n    Desc () {\n        return NULL_VALUE;\n    },\n    async ArrayCoerce ({ base }, scope, execute) {\n        const value = await execute(base, scope);\n        return value.isArray() ? value : NULL_VALUE;\n    },\n    async Map ({ base, expr }, scope, execute) {\n        const value = await execute(base, scope);\n        return value.isArray() ? new StreamValue(async function*() {\n            for await (const elem of value){\n                const newScope = scope.createHidden(elem);\n                yield await execute(expr, newScope);\n            }\n        }) : NULL_VALUE;\n    },\n    async FlatMap ({ base, expr }, scope, execute) {\n        const value = await execute(base, scope);\n        return value.isArray() ? new StreamValue(async function*() {\n            for await (const elem of value){\n                const newScope = scope.createHidden(elem), innerValue = await execute(expr, newScope);\n                if (innerValue.isArray()) for await (const inner of innerValue)yield inner;\n                else yield innerValue;\n            }\n        }) : NULL_VALUE;\n    }\n};\nfunction evaluateQuery(tree, options = {}) {\n    const root = fromJS(options.root), dataset = fromJS(options.dataset), params = {\n        ...options.params\n    }, scope = new Scope(params, dataset, root, {\n        timestamp: options.timestamp || /* @__PURE__ */ new Date(),\n        identity: options.identity === void 0 ? \"me\" : options.identity,\n        sanity: options.sanity,\n        after: options.after ? fromJS(options.after) : null,\n        before: options.before ? fromJS(options.before) : null,\n        dereference: options.dereference\n    }, null);\n    return evaluate(tree, scope);\n}\nfunction canConstantEvaluate(node) {\n    switch(node.type){\n        case \"Group\":\n            return canConstantEvaluate(node.base);\n        case \"Value\":\n        case \"Parameter\":\n            return !0;\n        case \"Pos\":\n        case \"Neg\":\n            return canConstantEvaluate(node.base);\n        case \"OpCall\":\n            switch(node.op){\n                case \"+\":\n                case \"-\":\n                case \"*\":\n                case \"/\":\n                case \"%\":\n                case \"**\":\n                    return canConstantEvaluate(node.left) && canConstantEvaluate(node.right);\n                default:\n                    return !1;\n            }\n        default:\n            return !1;\n    }\n}\nconst DUMMY_SCOPE = new Scope({}, NULL_VALUE, NULL_VALUE, {\n    timestamp: /* @__PURE__ */ new Date(0),\n    identity: \"me\",\n    before: null,\n    after: null\n}, null);\nfunction tryConstantEvaluate(node) {\n    return canConstantEvaluate(node) ? constantEvaluate(node) : null;\n}\nfunction constantEvaluate(node) {\n    const value = evaluate(node, DUMMY_SCOPE, constantEvaluate);\n    if (\"then\" in value) throw new Error(\"BUG: constant evaluate should never return a promise\");\n    return value;\n}\nasync function portableTextContent(value) {\n    if (value.type === \"object\") return blockText(value.data);\n    if (value.isArray()) {\n        const texts = await arrayText(value);\n        if (texts.length > 0) return texts.join(`\n\n`);\n    }\n    return null;\n}\nasync function arrayText(value, result = []) {\n    for await (const block of value)if (block.type === \"object\") {\n        const text = blockText(block.data);\n        text !== null && result.push(text);\n    } else block.isArray() && await arrayText(block, result);\n    return result;\n}\nfunction blockText(obj) {\n    if (typeof obj._type != \"string\") return null;\n    const children = obj.children;\n    if (!Array.isArray(children)) return null;\n    let result = \"\";\n    for (const child of children)child && typeof child == \"object\" && typeof child._type == \"string\" && child._type === \"span\" && typeof child.text == \"string\" && (result += child.text);\n    return result;\n}\nconst BM25k = 1.2;\nasync function evaluateScore(node, scope, execute) {\n    if (node.type === \"OpCall\" && node.op === \"match\") return evaluateMatchScore(node.left, node.right, scope, execute);\n    if (node.type === \"FuncCall\" && node.name === \"boost\") {\n        const innerScore = await evaluateScore(node.args[0], scope, execute), boost = await execute(node.args[1], scope);\n        return boost.type === \"number\" && innerScore > 0 ? innerScore + boost.data : 0;\n    }\n    switch(node.type){\n        case \"Or\":\n            {\n                const leftScore = await evaluateScore(node.left, scope, execute), rightScore = await evaluateScore(node.right, scope, execute);\n                return leftScore + rightScore;\n            }\n        case \"And\":\n            {\n                const leftScore = await evaluateScore(node.left, scope, execute), rightScore = await evaluateScore(node.right, scope, execute);\n                return leftScore === 0 || rightScore === 0 ? 0 : leftScore + rightScore;\n            }\n        default:\n            {\n                const res = await execute(node, scope);\n                return res.type === \"boolean\" && res.data === !0 ? 1 : 0;\n            }\n    }\n}\nasync function evaluateMatchScore(left, right, scope, execute) {\n    const text = await execute(left, scope), pattern = await execute(right, scope);\n    let tokens = [], terms = [];\n    if (await gatherText(text, (part)=>{\n        tokens = tokens.concat(matchTokenize(part));\n    }), !await gatherText(pattern, (part)=>{\n        terms = terms.concat(matchPatternRegex(part));\n    }) || tokens.length === 0 || terms.length === 0) return 0;\n    let score = 0;\n    for (const re of terms){\n        const freq = tokens.reduce((c, token)=>c + (re.test(token) ? 1 : 0), 0);\n        score += freq * (BM25k + 1) / (freq + BM25k);\n    }\n    return score;\n}\nfunction hasReference(value, pathSet) {\n    switch(getType(value)){\n        case \"array\":\n            for (const v of value)if (hasReference(v, pathSet)) return !0;\n            break;\n        case \"object\":\n            if (value._ref) return pathSet.has(value._ref);\n            for (const v of Object.values(value))if (hasReference(v, pathSet)) return !0;\n            break;\n    }\n    return !1;\n}\nfunction countUTF8(str) {\n    let count2 = 0;\n    for(let i = 0; i < str.length; i++){\n        const code = str.charCodeAt(i);\n        code >= 55296 && code <= 56319 || count2++;\n    }\n    return count2;\n}\nconst _global = {};\n_global.anywhere = async function() {\n    throw new Error(\"not implemented\");\n};\n_global.anywhere.arity = 1;\n_global.coalesce = async function(args, scope, execute) {\n    for (const arg of args){\n        const value = await execute(arg, scope);\n        if (value.type !== \"null\") return value;\n    }\n    return NULL_VALUE;\n};\n_global.count = async function(args, scope, execute) {\n    const inner = await execute(args[0], scope);\n    if (!inner.isArray()) return NULL_VALUE;\n    let num = 0;\n    for await (const _ of inner)num++;\n    return fromNumber(num);\n};\n_global.count.arity = 1;\n_global.dateTime = async function(args, scope, execute) {\n    const val = await execute(args[0], scope);\n    return val.type === \"datetime\" ? val : val.type !== \"string\" ? NULL_VALUE : DateTime.parseToValue(val.data);\n};\n_global.dateTime.arity = 1;\n_global.defined = async function(args, scope, execute) {\n    return (await execute(args[0], scope)).type === \"null\" ? FALSE_VALUE : TRUE_VALUE;\n};\n_global.defined.arity = 1;\n_global.identity = async function(args, scope) {\n    return fromString(scope.context.identity);\n};\n_global.identity.arity = 0;\n_global.length = async function(args, scope, execute) {\n    const inner = await execute(args[0], scope);\n    if (inner.type === \"string\") return fromNumber(countUTF8(inner.data));\n    if (inner.isArray()) {\n        let num = 0;\n        for await (const _ of inner)num++;\n        return fromNumber(num);\n    }\n    return NULL_VALUE;\n};\n_global.length.arity = 1;\n_global.path = async function(args, scope, execute) {\n    const inner = await execute(args[0], scope);\n    return inner.type !== \"string\" ? NULL_VALUE : fromPath(new Path(inner.data));\n};\n_global.path.arity = 1;\n_global.string = async function(args, scope, execute) {\n    const value = await execute(args[0], scope);\n    switch(value.type){\n        case \"number\":\n        case \"string\":\n        case \"boolean\":\n        case \"datetime\":\n            return fromString(`${value.data}`);\n        default:\n            return NULL_VALUE;\n    }\n};\n_global.string.arity = 1;\n_global.references = async function(args, scope, execute) {\n    const pathSet = /* @__PURE__ */ new Set();\n    for (const arg of args){\n        const path2 = await execute(arg, scope);\n        if (path2.type === \"string\") pathSet.add(path2.data);\n        else if (path2.isArray()) for await (const elem of path2)elem.type === \"string\" && pathSet.add(elem.data);\n    }\n    if (pathSet.size === 0) return FALSE_VALUE;\n    const scopeValue = await scope.value.get();\n    return hasReference(scopeValue, pathSet) ? TRUE_VALUE : FALSE_VALUE;\n};\n_global.references.arity = (c)=>c >= 1;\n_global.round = async function(args, scope, execute) {\n    const value = await execute(args[0], scope);\n    if (value.type !== \"number\") return NULL_VALUE;\n    const num = value.data;\n    let prec = 0;\n    if (args.length === 2) {\n        const precValue = await execute(args[1], scope);\n        if (precValue.type !== \"number\" || precValue.data < 0 || !Number.isInteger(precValue.data)) return NULL_VALUE;\n        prec = precValue.data;\n    }\n    return prec === 0 ? num < 0 ? fromNumber(-Math.round(-num)) : fromNumber(Math.round(num)) : fromNumber(Number(num.toFixed(prec)));\n};\n_global.round.arity = (count2)=>count2 >= 1 && count2 <= 2;\n_global.now = async function(args, scope) {\n    return fromString(scope.context.timestamp.toISOString());\n};\n_global.now.arity = 0;\n_global.boost = async function() {\n    throw new Error(\"unexpected boost call\");\n};\n_global.boost.arity = 2;\nconst string2 = {};\nstring2.lower = async function(args, scope, execute) {\n    const value = await execute(args[0], scope);\n    return value.type !== \"string\" ? NULL_VALUE : fromString(value.data.toLowerCase());\n};\nstring2.lower.arity = 1;\nstring2.upper = async function(args, scope, execute) {\n    const value = await execute(args[0], scope);\n    return value.type !== \"string\" ? NULL_VALUE : fromString(value.data.toUpperCase());\n};\nstring2.upper.arity = 1;\nstring2.split = async function(args, scope, execute) {\n    const str = await execute(args[0], scope);\n    if (str.type !== \"string\") return NULL_VALUE;\n    const sep = await execute(args[1], scope);\n    return sep.type !== \"string\" ? NULL_VALUE : str.data.length === 0 ? fromJS([]) : sep.data.length === 0 ? fromJS(Array.from(str.data)) : fromJS(str.data.split(sep.data));\n};\nstring2.split.arity = 2;\n_global.lower = string2.lower;\n_global.upper = string2.upper;\nstring2.startsWith = async function(args, scope, execute) {\n    const str = await execute(args[0], scope);\n    if (str.type !== \"string\") return NULL_VALUE;\n    const prefix = await execute(args[1], scope);\n    return prefix.type !== \"string\" ? NULL_VALUE : str.data.startsWith(prefix.data) ? TRUE_VALUE : FALSE_VALUE;\n};\nstring2.startsWith.arity = 2;\nconst array = {};\narray.join = async function(args, scope, execute) {\n    const arr = await execute(args[0], scope);\n    if (!arr.isArray()) return NULL_VALUE;\n    const sep = await execute(args[1], scope);\n    if (sep.type !== \"string\") return NULL_VALUE;\n    let buf = \"\", needSep = !1;\n    for await (const elem of arr){\n        switch(needSep && (buf += sep.data), elem.type){\n            case \"number\":\n            case \"string\":\n            case \"boolean\":\n            case \"datetime\":\n                buf += `${elem.data}`;\n                break;\n            default:\n                return NULL_VALUE;\n        }\n        needSep = !0;\n    }\n    return fromJS(buf);\n};\narray.join.arity = 2;\narray.compact = async function(args, scope, execute) {\n    const arr = await execute(args[0], scope);\n    return arr.isArray() ? new StreamValue(async function*() {\n        for await (const elem of arr)elem.type !== \"null\" && (yield elem);\n    }) : NULL_VALUE;\n};\narray.compact.arity = 1;\narray.unique = async function(args, scope, execute) {\n    const value = await execute(args[0], scope);\n    return value.isArray() ? new StreamValue(async function*() {\n        const added = /* @__PURE__ */ new Set();\n        for await (const iter of value)switch(iter.type){\n            case \"number\":\n            case \"string\":\n            case \"boolean\":\n            case \"datetime\":\n                added.has(iter.data) || (added.add(iter.data), yield iter);\n                break;\n            default:\n                yield iter;\n        }\n    }) : NULL_VALUE;\n};\narray.unique.arity = 1;\nconst pt = {};\npt.text = async function(args, scope, execute) {\n    const value = await execute(args[0], scope), text = await portableTextContent(value);\n    return text === null ? NULL_VALUE : fromString(text);\n};\npt.text.arity = 1;\nconst sanity = {};\nsanity.projectId = async function(args, scope) {\n    return scope.context.sanity ? fromString(scope.context.sanity.projectId) : NULL_VALUE;\n};\nsanity.dataset = async function(args, scope) {\n    return scope.context.sanity ? fromString(scope.context.sanity.dataset) : NULL_VALUE;\n};\nconst pipeFunctions = {};\npipeFunctions.order = async function(base, args, scope, execute) {\n    if (await !0, !base.isArray()) return NULL_VALUE;\n    const mappers = [], directions = [];\n    let n = 0;\n    for (let mapper of args){\n        let direction = \"asc\";\n        mapper.type === \"Desc\" ? (direction = \"desc\", mapper = mapper.base) : mapper.type === \"Asc\" && (mapper = mapper.base), mappers.push(mapper), directions.push(direction), n++;\n    }\n    const aux = [];\n    let idx = 0;\n    for await (const value of base){\n        const newScope = scope.createNested(value), tuple = [\n            await value.get(),\n            idx\n        ];\n        for(let i = 0; i < n; i++){\n            const result = await execute(mappers[i], newScope);\n            tuple.push(await result.get());\n        }\n        aux.push(tuple), idx++;\n    }\n    return aux.sort((aTuple, bTuple)=>{\n        for(let i = 0; i < n; i++){\n            let c = totalCompare(aTuple[i + 2], bTuple[i + 2]);\n            if (directions[i] === \"desc\" && (c = -c), c !== 0) return c;\n        }\n        return aTuple[1] - bTuple[1];\n    }), fromJS(aux.map((v)=>v[0]));\n};\npipeFunctions.order.arity = (count2)=>count2 >= 1;\npipeFunctions.score = async function(base, args, scope, execute) {\n    if (!base.isArray()) return NULL_VALUE;\n    const unknown = [], scored = [];\n    for await (const value of base){\n        if (value.type !== \"object\") {\n            unknown.push(await value.get());\n            continue;\n        }\n        const newScope = scope.createNested(value);\n        let valueScore = typeof value.data._score == \"number\" ? value.data._score : 0;\n        for (const arg of args)valueScore += await evaluateScore(arg, newScope, execute);\n        const newObject = Object.assign({}, value.data, {\n            _score: valueScore\n        });\n        scored.push(newObject);\n    }\n    return scored.sort((a, b)=>b._score - a._score), fromJS(scored);\n};\npipeFunctions.score.arity = (count2)=>count2 >= 1;\nconst delta = {};\ndelta.operation = async function(args, scope) {\n    const hasBefore = scope.context.before !== null, hasAfter = scope.context.after !== null;\n    return hasBefore && hasAfter ? fromString(\"update\") : hasAfter ? fromString(\"create\") : hasBefore ? fromString(\"delete\") : NULL_VALUE;\n};\ndelta.changedAny = ()=>{\n    throw new Error(\"not implemented\");\n};\ndelta.changedAny.arity = 1;\ndelta.changedAny.mode = \"delta\";\ndelta.changedOnly = ()=>{\n    throw new Error(\"not implemented\");\n};\ndelta.changedOnly.arity = 1;\ndelta.changedOnly.mode = \"delta\";\nconst diff = {};\ndiff.changedAny = ()=>{\n    throw new Error(\"not implemented\");\n};\ndiff.changedAny.arity = 3;\ndiff.changedOnly = ()=>{\n    throw new Error(\"not implemented\");\n};\ndiff.changedOnly.arity = 3;\nconst math = {};\nmath.min = async function(args, scope, execute) {\n    const arr = await execute(args[0], scope);\n    if (!arr.isArray()) return NULL_VALUE;\n    let n;\n    for await (const elem of arr)if (elem.type !== \"null\") {\n        if (elem.type !== \"number\") return NULL_VALUE;\n        (n === void 0 || elem.data < n) && (n = elem.data);\n    }\n    return fromJS(n);\n};\nmath.min.arity = 1;\nmath.max = async function(args, scope, execute) {\n    const arr = await execute(args[0], scope);\n    if (!arr.isArray()) return NULL_VALUE;\n    let n;\n    for await (const elem of arr)if (elem.type !== \"null\") {\n        if (elem.type !== \"number\") return NULL_VALUE;\n        (n === void 0 || elem.data > n) && (n = elem.data);\n    }\n    return fromJS(n);\n};\nmath.max.arity = 1;\nmath.sum = async function(args, scope, execute) {\n    const arr = await execute(args[0], scope);\n    if (!arr.isArray()) return NULL_VALUE;\n    let n = 0;\n    for await (const elem of arr)if (elem.type !== \"null\") {\n        if (elem.type !== \"number\") return NULL_VALUE;\n        n += elem.data;\n    }\n    return fromJS(n);\n};\nmath.sum.arity = 1;\nmath.avg = async function(args, scope, execute) {\n    const arr = await execute(args[0], scope);\n    if (!arr.isArray()) return NULL_VALUE;\n    let n = 0, c = 0;\n    for await (const elem of arr)if (elem.type !== \"null\") {\n        if (elem.type !== \"number\") return NULL_VALUE;\n        n += elem.data, c++;\n    }\n    return c === 0 ? NULL_VALUE : fromJS(n / c);\n};\nmath.avg.arity = 1;\nconst dateTime2 = {};\ndateTime2.now = async function(args, scope, execute) {\n    return fromDateTime(new DateTime(scope.context.timestamp));\n};\ndateTime2.now.arity = 0;\nconst namespaces = {\n    global: _global,\n    string: string2,\n    array,\n    pt,\n    delta,\n    diff,\n    sanity,\n    math,\n    dateTime: dateTime2\n};\nvar __defProp$1 = Object.defineProperty, __defNormalProp$1 = (obj, key, value)=>key in obj ? __defProp$1(obj, key, {\n        enumerable: !0,\n        configurable: !0,\n        writable: !0,\n        value\n    }) : obj[key] = value, __publicField$1 = (obj, key, value)=>(__defNormalProp$1(obj, typeof key != \"symbol\" ? key + \"\" : key, value), value);\nclass MarkProcessor {\n    constructor(string, marks, parseOptions){\n        __publicField$1(this, \"string\"), __publicField$1(this, \"marks\"), __publicField$1(this, \"index\"), __publicField$1(this, \"parseOptions\"), __publicField$1(this, \"allowBoost\", !1), this.string = string, this.marks = marks, this.index = 0, this.parseOptions = parseOptions;\n    }\n    hasMark(pos = 0) {\n        return this.index + pos < this.marks.length;\n    }\n    getMark(pos = 0) {\n        return this.marks[this.index + pos];\n    }\n    shift() {\n        this.index += 1;\n    }\n    process(visitor) {\n        const mark = this.marks[this.index];\n        this.shift();\n        const func = visitor[mark.name];\n        if (!func) throw new Error(`Unknown handler: ${mark.name}`);\n        return func.call(visitor, this, mark);\n    }\n    processString() {\n        return this.shift(), this.processStringEnd();\n    }\n    processStringEnd() {\n        const prev = this.marks[this.index - 1], curr = this.marks[this.index];\n        return this.shift(), this.string.slice(prev.position, curr.position);\n    }\n    slice(len) {\n        const pos = this.marks[this.index].position;\n        return this.string.slice(pos, pos + len);\n    }\n}\nconst WS = /^([\\t\\n\\v\\f\\r \\u0085\\u00A0]|(\\/\\/[^\\n]*\\n))+/, NUM = /^\\d+/, IDENT = /^[a-zA-Z_][a-zA-Z_0-9]*/;\nfunction parse$1(str) {\n    let pos = 0;\n    pos = skipWS(str, pos);\n    let result = parseExpr(str, pos, 0);\n    return result.type === \"error\" ? result : (pos = skipWS(str, result.position), pos !== str.length ? (result.failPosition && (pos = result.failPosition - 1), {\n        type: \"error\",\n        position: pos\n    }) : (delete result.position, delete result.failPosition, result));\n}\nfunction parseExpr(str, pos, level) {\n    let startPos = pos, token = str[pos], marks;\n    switch(token){\n        case \"+\":\n            {\n                let rhs = parseExpr(str, skipWS(str, pos + 1), 10);\n                if (rhs.type === \"error\") return rhs;\n                marks = [\n                    {\n                        name: \"pos\",\n                        position: startPos\n                    }\n                ].concat(rhs.marks), pos = rhs.position;\n                break;\n            }\n        case \"-\":\n            {\n                let rhs = parseExpr(str, skipWS(str, pos + 1), 8);\n                if (rhs.type === \"error\") return rhs;\n                marks = [\n                    {\n                        name: \"neg\",\n                        position: startPos\n                    }\n                ].concat(rhs.marks), pos = rhs.position;\n                break;\n            }\n        case \"(\":\n            {\n                let rhs = parseExpr(str, skipWS(str, pos + 1), 0);\n                if (rhs.type === \"error\") return rhs;\n                switch(pos = skipWS(str, rhs.position), str[pos]){\n                    case \",\":\n                        {\n                            for(marks = [\n                                {\n                                    name: \"tuple\",\n                                    position: startPos\n                                }\n                            ].concat(rhs.marks), pos = skipWS(str, pos + 1);;){\n                                if (rhs = parseExpr(str, pos, 0), rhs.type === \"error\") return rhs;\n                                if (pos = skipWS(str, rhs.position), str[pos] !== \",\") break;\n                                pos = skipWS(str, pos + 1);\n                            }\n                            if (str[pos] !== \")\") return {\n                                type: \"error\",\n                                position: pos\n                            };\n                            pos++, marks.push({\n                                name: \"tuple_end\",\n                                position: pos\n                            });\n                            break;\n                        }\n                    case \")\":\n                        {\n                            pos++, marks = [\n                                {\n                                    name: \"group\",\n                                    position: startPos\n                                }\n                            ].concat(rhs.marks);\n                            break;\n                        }\n                    default:\n                        return {\n                            type: \"error\",\n                            position: pos\n                        };\n                }\n                break;\n            }\n        case \"!\":\n            {\n                let rhs = parseExpr(str, skipWS(str, pos + 1), 10);\n                if (rhs.type === \"error\") return rhs;\n                marks = [\n                    {\n                        name: \"not\",\n                        position: startPos\n                    }\n                ].concat(rhs.marks), pos = rhs.position;\n                break;\n            }\n        case \"{\":\n            {\n                let result = parseObject(str, pos);\n                if (result.type === \"error\") return result;\n                marks = result.marks, pos = result.position;\n                break;\n            }\n        case \"[\":\n            if (marks = [\n                {\n                    name: \"array\",\n                    position: pos\n                }\n            ], pos = skipWS(str, pos + 1), str[pos] !== \"]\") for(;;){\n                str.slice(pos, pos + 3) === \"...\" && (marks.push({\n                    name: \"array_splat\",\n                    position: pos\n                }), pos = skipWS(str, pos + 3));\n                let res = parseExpr(str, pos, 0);\n                if (res.type === \"error\") return res;\n                if (marks = marks.concat(res.marks), pos = res.position, pos = skipWS(str, pos), str[pos] !== \",\" || (pos = skipWS(str, pos + 1), str[pos] === \"]\")) break;\n            }\n            if (str[pos] === \"]\") pos++, marks.push({\n                name: \"array_end\",\n                position: pos\n            });\n            else return {\n                type: \"error\",\n                position: pos\n            };\n            break;\n        case \"'\":\n        case '\"':\n            {\n                let result = parseString(str, pos);\n                if (result.type === \"error\") return result;\n                marks = result.marks, pos = result.position;\n                break;\n            }\n        case \"^\":\n            {\n                for(pos++, marks = []; str[pos] === \".\" && str[pos + 1] === \"^\";)marks.push({\n                    name: \"dblparent\",\n                    position: startPos\n                }), pos += 2;\n                marks.push({\n                    name: \"parent\",\n                    position: startPos\n                });\n                break;\n            }\n        case \"@\":\n            marks = [\n                {\n                    name: \"this\",\n                    position: startPos\n                }\n            ], pos++;\n            break;\n        case \"*\":\n            marks = [\n                {\n                    name: \"everything\",\n                    position: startPos\n                }\n            ], pos++;\n            break;\n        case \"$\":\n            {\n                let identLen = parseRegex(str, pos + 1, IDENT);\n                identLen && (pos += 1 + identLen, marks = [\n                    {\n                        name: \"param\",\n                        position: startPos\n                    },\n                    {\n                        name: \"ident\",\n                        position: startPos + 1\n                    },\n                    {\n                        name: \"ident_end\",\n                        position: pos\n                    }\n                ]);\n                break;\n            }\n        default:\n            {\n                let numLen = parseRegex(str, pos, NUM);\n                if (numLen) {\n                    pos += numLen;\n                    let name = \"integer\";\n                    if (str[pos] === \".\") {\n                        let fracLen = parseRegex(str, pos + 1, NUM);\n                        fracLen && (name = \"float\", pos += 1 + fracLen);\n                    }\n                    if (str[pos] === \"e\" || str[pos] === \"E\") {\n                        name = \"sci\", pos++, (str[pos] === \"+\" || str[pos] === \"-\") && pos++;\n                        let expLen = parseRegex(str, pos, NUM);\n                        if (!expLen) return {\n                            type: \"error\",\n                            position: pos\n                        };\n                        pos += expLen;\n                    }\n                    marks = [\n                        {\n                            name,\n                            position: startPos\n                        },\n                        {\n                            name: name + \"_end\",\n                            position: pos\n                        }\n                    ];\n                    break;\n                }\n                let identLen = parseRegex(str, pos, IDENT);\n                if (identLen) {\n                    switch(pos += identLen, str[pos]){\n                        case \":\":\n                        case \"(\":\n                            {\n                                let result = parseFuncCall(str, startPos, pos);\n                                if (result.type === \"error\") return result;\n                                marks = result.marks, pos = result.position;\n                                break;\n                            }\n                        default:\n                            marks = [\n                                {\n                                    name: \"this_attr\",\n                                    position: startPos\n                                },\n                                {\n                                    name: \"ident\",\n                                    position: startPos\n                                },\n                                {\n                                    name: \"ident_end\",\n                                    position: pos\n                                }\n                            ];\n                    }\n                    break;\n                }\n            }\n    }\n    if (!marks) return {\n        type: \"error\",\n        position: pos\n    };\n    let lhsLevel = 12, trav;\n    loop: for(;;){\n        let innerPos = skipWS(str, pos);\n        if (innerPos === str.length) {\n            pos = innerPos;\n            break;\n        }\n        if (trav = parseTraversal(str, innerPos), trav.type === \"success\") {\n            for(marks.unshift({\n                name: \"traverse\",\n                position: startPos\n            }); trav.type === \"success\";)marks = marks.concat(trav.marks), pos = trav.position, trav = parseTraversal(str, skipWS(str, pos));\n            marks.push({\n                name: \"traversal_end\",\n                position: pos\n            });\n            continue;\n        }\n        switch(str[innerPos]){\n            case \"=\":\n                {\n                    switch(str[innerPos + 1]){\n                        case \">\":\n                            {\n                                if (level > 1 || lhsLevel <= 1) break loop;\n                                let rhs = parseExpr(str, skipWS(str, innerPos + 2), 1);\n                                if (rhs.type === \"error\") return rhs;\n                                marks = marks.concat(rhs.marks), marks.unshift({\n                                    name: \"pair\",\n                                    position: startPos\n                                }), pos = rhs.position, lhsLevel = 1;\n                                break;\n                            }\n                        case \"=\":\n                            {\n                                if (level > 4 || lhsLevel <= 4) break loop;\n                                let rhs = parseExpr(str, skipWS(str, innerPos + 2), 5);\n                                if (rhs.type === \"error\") return rhs;\n                                marks.unshift({\n                                    name: \"comp\",\n                                    position: startPos\n                                }), marks.push({\n                                    name: \"op\",\n                                    position: innerPos\n                                }, {\n                                    name: \"op_end\",\n                                    position: innerPos + 2\n                                }), marks = marks.concat(rhs.marks), pos = rhs.position, lhsLevel = 4;\n                                break;\n                            }\n                        default:\n                            break loop;\n                    }\n                    break;\n                }\n            case \"+\":\n                {\n                    if (level > 6 || lhsLevel < 6) break loop;\n                    let rhs = parseExpr(str, skipWS(str, innerPos + 1), 7);\n                    if (rhs.type === \"error\") return rhs;\n                    marks = marks.concat(rhs.marks), marks.unshift({\n                        name: \"add\",\n                        position: startPos\n                    }), pos = rhs.position, lhsLevel = 6;\n                    break;\n                }\n            case \"-\":\n                {\n                    if (level > 6 || lhsLevel < 6) break loop;\n                    let rhs = parseExpr(str, skipWS(str, innerPos + 1), 7);\n                    if (rhs.type === \"error\") return rhs;\n                    marks = marks.concat(rhs.marks), marks.unshift({\n                        name: \"sub\",\n                        position: startPos\n                    }), pos = rhs.position, lhsLevel = 6;\n                    break;\n                }\n            case \"*\":\n                {\n                    if (str[innerPos + 1] === \"*\") {\n                        if (level > 8 || lhsLevel <= 8) break loop;\n                        let rhs2 = parseExpr(str, skipWS(str, innerPos + 2), 8);\n                        if (rhs2.type === \"error\") return rhs2;\n                        marks = marks.concat(rhs2.marks), marks.unshift({\n                            name: \"pow\",\n                            position: startPos\n                        }), pos = rhs2.position, lhsLevel = 8;\n                        break;\n                    }\n                    if (level > 7 || lhsLevel < 7) break loop;\n                    let rhs = parseExpr(str, skipWS(str, innerPos + 1), 8);\n                    if (rhs.type === \"error\") return rhs;\n                    marks = marks.concat(rhs.marks), marks.unshift({\n                        name: \"mul\",\n                        position: startPos\n                    }), pos = rhs.position, lhsLevel = 7;\n                    break;\n                }\n            case \"/\":\n                {\n                    if (level > 7 || lhsLevel < 7) break loop;\n                    let rhs = parseExpr(str, skipWS(str, innerPos + 1), 8);\n                    if (rhs.type === \"error\") return rhs;\n                    marks = marks.concat(rhs.marks), marks.unshift({\n                        name: \"div\",\n                        position: startPos\n                    }), pos = rhs.position, lhsLevel = 7;\n                    break;\n                }\n            case \"%\":\n                {\n                    if (level > 7 || lhsLevel < 7) break loop;\n                    let rhs = parseExpr(str, skipWS(str, innerPos + 1), 8);\n                    if (rhs.type === \"error\") return rhs;\n                    marks = marks.concat(rhs.marks), marks.unshift({\n                        name: \"mod\",\n                        position: startPos\n                    }), pos = rhs.position, lhsLevel = 7;\n                    break;\n                }\n            case \"<\":\n            case \">\":\n                {\n                    if (level > 4 || lhsLevel <= 4) break loop;\n                    let nextPos = innerPos + 1;\n                    str[nextPos] === \"=\" && nextPos++;\n                    let rhs = parseExpr(str, skipWS(str, nextPos), 5);\n                    if (rhs.type === \"error\") return rhs;\n                    marks.unshift({\n                        name: \"comp\",\n                        position: startPos\n                    }), marks.push({\n                        name: \"op\",\n                        position: innerPos\n                    }, {\n                        name: \"op_end\",\n                        position: nextPos\n                    }), marks = marks.concat(rhs.marks), pos = rhs.position, lhsLevel = 4;\n                    break;\n                }\n            case \"|\":\n                {\n                    if (str[innerPos + 1] === \"|\") {\n                        if (level > 2 || lhsLevel < 2) break loop;\n                        let rhs = parseExpr(str, skipWS(str, innerPos + 2), 3);\n                        if (rhs.type === \"error\") return rhs;\n                        marks = marks.concat(rhs.marks), marks.unshift({\n                            name: \"or\",\n                            position: startPos\n                        }), pos = rhs.position, lhsLevel = 2;\n                    } else {\n                        if (level > 11 || lhsLevel < 11) break loop;\n                        let identPos = skipWS(str, innerPos + 1), identLen = parseRegex(str, identPos, IDENT);\n                        if (!identLen) return {\n                            type: \"error\",\n                            position: identPos\n                        };\n                        if (pos = identPos + identLen, str[pos] === \"(\" || str[pos] === \":\") {\n                            let result = parseFuncCall(str, identPos, pos);\n                            if (result.type === \"error\") return result;\n                            marks = marks.concat(result.marks), marks.unshift({\n                                name: \"pipecall\",\n                                position: startPos\n                            }), pos = result.position, lhsLevel = 11;\n                        }\n                    }\n                    break;\n                }\n            case \"&\":\n                {\n                    if (str[innerPos + 1] != \"&\" || level > 3 || lhsLevel < 3) break loop;\n                    let rhs = parseExpr(str, skipWS(str, innerPos + 2), 4);\n                    if (rhs.type === \"error\") return rhs;\n                    marks = marks.concat(rhs.marks), marks.unshift({\n                        name: \"and\",\n                        position: startPos\n                    }), pos = rhs.position, lhsLevel = 3;\n                    break;\n                }\n            case \"!\":\n                {\n                    if (str[innerPos + 1] !== \"=\" || level > 4 || lhsLevel <= 4) break loop;\n                    let rhs = parseExpr(str, skipWS(str, innerPos + 2), 5);\n                    if (rhs.type === \"error\") return rhs;\n                    marks.unshift({\n                        name: \"comp\",\n                        position: startPos\n                    }), marks.push({\n                        name: \"op\",\n                        position: innerPos\n                    }, {\n                        name: \"op_end\",\n                        position: innerPos + 2\n                    }), marks = marks.concat(rhs.marks), pos = rhs.position, lhsLevel = 4;\n                    break;\n                }\n            case \"d\":\n                {\n                    if (str.slice(innerPos, innerPos + 4) !== \"desc\" || level > 4 || lhsLevel < 4) break loop;\n                    marks.unshift({\n                        name: \"desc\",\n                        position: startPos\n                    }), pos = innerPos + 4, lhsLevel = 4;\n                    break;\n                }\n            case \"a\":\n                {\n                    if (str.slice(innerPos, innerPos + 3) !== \"asc\" || level > 4 || lhsLevel < 4) break loop;\n                    marks.unshift({\n                        name: \"asc\",\n                        position: startPos\n                    }), pos = innerPos + 3, lhsLevel = 4;\n                    break;\n                }\n            default:\n                switch(parseRegexStr(str, innerPos, IDENT)){\n                    case \"in\":\n                        {\n                            if (level > 4 || lhsLevel <= 4) break loop;\n                            pos = skipWS(str, innerPos + 2);\n                            let isGroup = !1;\n                            str[pos] === \"(\" && (isGroup = !0, pos = skipWS(str, pos + 1));\n                            let rangePos = pos, result = parseExpr(str, pos, 5);\n                            if (result.type === \"error\") return result;\n                            if (pos = skipWS(str, result.position), str[pos] === \".\" && str[pos + 1] === \".\") {\n                                let type = \"inc_range\";\n                                str[pos + 2] === \".\" ? (type = \"exc_range\", pos = skipWS(str, pos + 3)) : pos = skipWS(str, pos + 2);\n                                let rhs = parseExpr(str, pos, 5);\n                                if (rhs.type === \"error\") return rhs;\n                                marks.unshift({\n                                    name: \"in_range\",\n                                    position: startPos\n                                }), marks = marks.concat({\n                                    name: type,\n                                    position: rangePos\n                                }, result.marks, rhs.marks), pos = rhs.position;\n                            } else marks.unshift({\n                                name: \"comp\",\n                                position: startPos\n                            }), marks.push({\n                                name: \"op\",\n                                position: innerPos\n                            }, {\n                                name: \"op_end\",\n                                position: innerPos + 2\n                            }), marks = marks.concat(result.marks);\n                            if (isGroup) {\n                                if (pos = skipWS(str, pos), str[pos] !== \")\") return {\n                                    type: \"error\",\n                                    position: pos\n                                };\n                                pos++;\n                            }\n                            lhsLevel = 4;\n                            break;\n                        }\n                    case \"match\":\n                        {\n                            if (level > 4 || lhsLevel <= 4) break loop;\n                            let rhs = parseExpr(str, skipWS(str, innerPos + 5), 5);\n                            if (rhs.type === \"error\") return rhs;\n                            marks.unshift({\n                                name: \"comp\",\n                                position: startPos\n                            }), marks.push({\n                                name: \"op\",\n                                position: innerPos\n                            }, {\n                                name: \"op_end\",\n                                position: innerPos + 5\n                            }), marks = marks.concat(rhs.marks), pos = rhs.position, lhsLevel = 4;\n                            break;\n                        }\n                    default:\n                        break loop;\n                }\n        }\n    }\n    let failPosition = (trav == null ? void 0 : trav.type) === \"error\" && trav.position;\n    return {\n        type: \"success\",\n        marks,\n        position: pos,\n        failPosition\n    };\n}\nfunction parseTraversal(str, pos) {\n    let startPos = pos;\n    switch(str[pos]){\n        case \".\":\n            {\n                pos = skipWS(str, pos + 1);\n                let identStart = pos, identLen2 = parseRegex(str, pos, IDENT);\n                return identLen2 ? (pos += identLen2, {\n                    type: \"success\",\n                    marks: [\n                        {\n                            name: \"attr_access\",\n                            position: startPos\n                        },\n                        {\n                            name: \"ident\",\n                            position: identStart\n                        },\n                        {\n                            name: \"ident_end\",\n                            position: pos\n                        }\n                    ],\n                    position: pos\n                }) : {\n                    type: \"error\",\n                    position: pos\n                };\n            }\n        case \"-\":\n            if (str[pos + 1] !== \">\") return {\n                type: \"error\",\n                position: pos\n            };\n            let marks = [\n                {\n                    name: \"deref\",\n                    position: startPos\n                }\n            ];\n            pos += 2;\n            let identPos = skipWS(str, pos), identLen = parseRegex(str, identPos, IDENT);\n            return identLen && (pos = identPos + identLen, marks.push({\n                name: \"deref_attr\",\n                position: identPos\n            }, {\n                name: \"ident\",\n                position: identPos\n            }, {\n                name: \"ident_end\",\n                position: pos\n            })), {\n                type: \"success\",\n                marks,\n                position: pos\n            };\n        case \"[\":\n            {\n                if (pos = skipWS(str, pos + 1), str[pos] === \"]\") return {\n                    type: \"success\",\n                    marks: [\n                        {\n                            name: \"array_postfix\",\n                            position: startPos\n                        }\n                    ],\n                    position: pos + 1\n                };\n                let rangePos = pos, result = parseExpr(str, pos, 0);\n                if (result.type === \"error\") return result;\n                if (pos = skipWS(str, result.position), str[pos] === \".\" && str[pos + 1] === \".\") {\n                    let type = \"inc_range\";\n                    str[pos + 2] === \".\" ? (type = \"exc_range\", pos += 3) : pos += 2, pos = skipWS(str, pos);\n                    let rhs = parseExpr(str, pos, 0);\n                    return rhs.type === \"error\" ? rhs : (pos = skipWS(str, rhs.position), str[pos] !== \"]\" ? {\n                        type: \"error\",\n                        position: pos\n                    } : {\n                        type: \"success\",\n                        marks: [\n                            {\n                                name: \"slice\",\n                                position: startPos\n                            },\n                            {\n                                name: type,\n                                position: rangePos\n                            }\n                        ].concat(result.marks, rhs.marks),\n                        position: pos + 1\n                    });\n                }\n                return str[pos] !== \"]\" ? {\n                    type: \"error\",\n                    position: pos\n                } : {\n                    type: \"success\",\n                    marks: [\n                        {\n                            name: \"square_bracket\",\n                            position: startPos\n                        }\n                    ].concat(result.marks),\n                    position: pos + 1\n                };\n            }\n        case \"|\":\n            {\n                if (pos = skipWS(str, pos + 1), str[pos] === \"{\") {\n                    let result = parseObject(str, pos);\n                    return result.type === \"error\" || result.marks.unshift({\n                        name: \"projection\",\n                        position: startPos\n                    }), result;\n                }\n                break;\n            }\n        case \"{\":\n            {\n                let result = parseObject(str, pos);\n                return result.type === \"error\" || result.marks.unshift({\n                    name: \"projection\",\n                    position: startPos\n                }), result;\n            }\n    }\n    return {\n        type: \"error\",\n        position: pos\n    };\n}\nfunction parseFuncCall(str, startPos, pos) {\n    let marks = [];\n    if (marks.push({\n        name: \"func_call\",\n        position: startPos\n    }), str[pos] === \":\" && str[pos + 1] === \":\") {\n        marks.push({\n            name: \"namespace\",\n            position: startPos\n        }), marks.push({\n            name: \"ident\",\n            position: startPos\n        }, {\n            name: \"ident_end\",\n            position: pos\n        }), pos = skipWS(str, pos + 2);\n        let nameLen = parseRegex(str, pos, IDENT);\n        if (!nameLen) return {\n            type: \"error\",\n            position: pos\n        };\n        if (marks.push({\n            name: \"ident\",\n            position: pos\n        }, {\n            name: \"ident_end\",\n            position: pos + nameLen\n        }), pos = skipWS(str, pos + nameLen), str[pos] !== \"(\") return {\n            type: \"error\",\n            position: pos\n        };\n        pos++, pos = skipWS(str, pos);\n    } else marks.push({\n        name: \"ident\",\n        position: startPos\n    }, {\n        name: \"ident_end\",\n        position: pos\n    }), pos = skipWS(str, pos + 1);\n    let lastPos = pos;\n    if (str[pos] !== \")\") for(;;){\n        let result = parseExpr(str, pos, 0);\n        if (result.type === \"error\") return result;\n        if (marks = marks.concat(result.marks), lastPos = result.position, pos = skipWS(str, result.position), str[pos] !== \",\" || (pos = skipWS(str, pos + 1), str[pos] === \")\")) break;\n    }\n    return str[pos] !== \")\" ? {\n        type: \"error\",\n        position: pos\n    } : (marks.push({\n        name: \"func_args_end\",\n        position: lastPos\n    }), {\n        type: \"success\",\n        marks,\n        position: pos + 1\n    });\n}\nfunction parseObject(str, pos) {\n    let marks = [\n        {\n            name: \"object\",\n            position: pos\n        }\n    ];\n    for(pos = skipWS(str, pos + 1); str[pos] !== \"}\";){\n        let pairPos = pos;\n        if (str.slice(pos, pos + 3) === \"...\") if (pos = skipWS(str, pos + 3), str[pos] !== \"}\" && str[pos] !== \",\") {\n            let expr = parseExpr(str, pos, 0);\n            if (expr.type === \"error\") return expr;\n            marks.push({\n                name: \"object_splat\",\n                position: pairPos\n            }), marks = marks.concat(expr.marks), pos = expr.position;\n        } else marks.push({\n            name: \"object_splat_this\",\n            position: pairPos\n        });\n        else {\n            let expr = parseExpr(str, pos, 0);\n            if (expr.type === \"error\") return expr;\n            let nextPos = skipWS(str, expr.position);\n            if (expr.marks[0].name === \"str\" && str[nextPos] === \":\") {\n                let value = parseExpr(str, skipWS(str, nextPos + 1), 0);\n                if (value.type === \"error\") return value;\n                marks.push({\n                    name: \"object_pair\",\n                    position: pairPos\n                }), marks = marks.concat(expr.marks, value.marks), pos = value.position;\n            } else marks = marks.concat({\n                name: \"object_expr\",\n                position: pos\n            }, expr.marks), pos = expr.position;\n        }\n        if (pos = skipWS(str, pos), str[pos] !== \",\") break;\n        pos = skipWS(str, pos + 1);\n    }\n    return str[pos] !== \"}\" ? {\n        type: \"error\",\n        position: pos\n    } : (pos++, marks.push({\n        name: \"object_end\",\n        position: pos\n    }), {\n        type: \"success\",\n        marks,\n        position: pos\n    });\n}\nfunction parseString(str, pos) {\n    let token = str[pos];\n    pos = pos + 1;\n    const marks = [\n        {\n            name: \"str\",\n            position: pos\n        }\n    ];\n    str: for(;; pos++){\n        if (pos > str.length) return {\n            type: \"error\",\n            position: pos\n        };\n        switch(str[pos]){\n            case token:\n                {\n                    marks.push({\n                        name: \"str_end\",\n                        position: pos\n                    }), pos++;\n                    break str;\n                }\n            case \"\\\\\":\n                marks.push({\n                    name: \"str_pause\",\n                    position: pos\n                }), str[pos + 1] === \"u\" ? str[pos + 2] === \"{\" ? (marks.push({\n                    name: \"unicode_hex\",\n                    position: pos + 3\n                }), pos = str.indexOf(\"}\", pos + 3), marks.push({\n                    name: \"unicode_hex_end\",\n                    position: pos\n                })) : (marks.push({\n                    name: \"unicode_hex\",\n                    position: pos + 2\n                }), marks.push({\n                    name: \"unicode_hex_end\",\n                    position: pos + 6\n                }), pos += 5) : (marks.push({\n                    name: \"single_escape\",\n                    position: pos + 1\n                }), pos += 1), marks.push({\n                    name: \"str_start\",\n                    position: pos + 1\n                });\n        }\n    }\n    return {\n        type: \"success\",\n        marks,\n        position: pos\n    };\n}\nfunction skipWS(str, pos) {\n    return pos + parseRegex(str, pos, WS);\n}\nfunction parseRegex(str, pos, re) {\n    let m = re.exec(str.slice(pos));\n    return m ? m[0].length : 0;\n}\nfunction parseRegexStr(str, pos, re) {\n    let m = re.exec(str.slice(pos));\n    return m ? m[0] : null;\n}\nfunction join(a, b) {\n    return (base)=>b(a(base));\n}\nfunction map(inner) {\n    return (base)=>({\n            type: \"Map\",\n            base,\n            expr: inner({\n                type: \"This\"\n            })\n        });\n}\nfunction flatMap(inner) {\n    return (base)=>({\n            type: \"FlatMap\",\n            base,\n            expr: inner({\n                type: \"This\"\n            })\n        });\n}\nfunction traverseArray(build, right) {\n    if (!right) return {\n        type: \"a-a\",\n        build\n    };\n    switch(right.type){\n        case \"a-a\":\n            return {\n                type: \"a-a\",\n                build: join(build, right.build)\n            };\n        case \"a-b\":\n            return {\n                type: \"a-b\",\n                build: join(build, right.build)\n            };\n        case \"b-b\":\n            return {\n                type: \"a-a\",\n                build: join(build, map(right.build))\n            };\n        case \"b-a\":\n            return {\n                type: \"a-a\",\n                build: join(build, flatMap(right.build))\n            };\n        default:\n            throw new Error(`unknown type: ${right.type}`);\n    }\n}\nfunction traversePlain(mapper, right) {\n    if (!right) return {\n        type: \"b-b\",\n        build: mapper\n    };\n    switch(right.type){\n        case \"a-a\":\n        case \"b-a\":\n            return {\n                type: \"b-a\",\n                build: join(mapper, right.build)\n            };\n        case \"a-b\":\n        case \"b-b\":\n            return {\n                type: \"b-b\",\n                build: join(mapper, right.build)\n            };\n        default:\n            throw new Error(`unknown type: ${right.type}`);\n    }\n}\nfunction traverseElement(mapper, right) {\n    if (!right) return {\n        type: \"a-b\",\n        build: mapper\n    };\n    switch(right.type){\n        case \"a-a\":\n        case \"b-a\":\n            return {\n                type: \"a-a\",\n                build: join(mapper, right.build)\n            };\n        case \"a-b\":\n        case \"b-b\":\n            return {\n                type: \"a-b\",\n                build: join(mapper, right.build)\n            };\n        default:\n            throw new Error(`unknown type: ${right.type}`);\n    }\n}\nfunction traverseProjection(mapper, right) {\n    if (!right) return {\n        type: \"b-b\",\n        build: mapper\n    };\n    switch(right.type){\n        case \"a-a\":\n            return {\n                type: \"a-a\",\n                build: join(map(mapper), right.build)\n            };\n        case \"a-b\":\n            return {\n                type: \"a-b\",\n                build: join(map(mapper), right.build)\n            };\n        case \"b-a\":\n            return {\n                type: \"b-a\",\n                build: join(mapper, right.build)\n            };\n        case \"b-b\":\n            return {\n                type: \"b-b\",\n                build: join(mapper, right.build)\n            };\n        default:\n            throw new Error(`unknown type: ${right.type}`);\n    }\n}\nvar __defProp = Object.defineProperty, __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {\n        enumerable: !0,\n        configurable: !0,\n        writable: !0,\n        value\n    }) : obj[key] = value, __publicField = (obj, key, value)=>(__defNormalProp(obj, typeof key != \"symbol\" ? key + \"\" : key, value), value);\nconst ESCAPE_SEQUENCE = {\n    \"'\": \"'\",\n    '\"': '\"',\n    \"\\\\\": \"\\\\\",\n    \"/\": \"/\",\n    b: \"\\b\",\n    f: \"\\f\",\n    n: `\n`,\n    r: \"\\r\",\n    t: \"\t\"\n};\nfunction expandHex(str) {\n    const charCode = parseInt(str, 16);\n    return String.fromCharCode(charCode);\n}\nclass GroqQueryError extends Error {\n    constructor(){\n        super(...arguments), __publicField(this, \"name\", \"GroqQueryError\");\n    }\n}\nconst EXPR_BUILDER = {\n    group (p) {\n        return {\n            type: \"Group\",\n            base: p.process(EXPR_BUILDER)\n        };\n    },\n    everything () {\n        return {\n            type: \"Everything\"\n        };\n    },\n    this () {\n        return {\n            type: \"This\"\n        };\n    },\n    parent () {\n        return {\n            type: \"Parent\",\n            n: 1\n        };\n    },\n    dblparent (p) {\n        return {\n            type: \"Parent\",\n            n: p.process(EXPR_BUILDER).n + 1\n        };\n    },\n    traverse (p) {\n        const base = p.process(EXPR_BUILDER), traversalList = [];\n        for(; p.getMark().name !== \"traversal_end\";)traversalList.push(p.process(TRAVERSE_BUILDER));\n        p.shift();\n        let traversal = null;\n        for(let i = traversalList.length - 1; i >= 0; i--)traversal = traversalList[i](traversal);\n        if ((base.type === \"Everything\" || base.type === \"Array\" || base.type === \"PipeFuncCall\") && (traversal = traverseArray((val)=>val, traversal)), traversal === null) throw new Error(\"BUG: unexpected empty traversal\");\n        return traversal.build(base);\n    },\n    this_attr (p) {\n        const name = p.processString();\n        return name === \"null\" ? {\n            type: \"Value\",\n            value: null\n        } : name === \"true\" ? {\n            type: \"Value\",\n            value: !0\n        } : name === \"false\" ? {\n            type: \"Value\",\n            value: !1\n        } : {\n            type: \"AccessAttribute\",\n            name\n        };\n    },\n    neg (p) {\n        return {\n            type: \"Neg\",\n            base: p.process(EXPR_BUILDER)\n        };\n    },\n    pos (p) {\n        return {\n            type: \"Pos\",\n            base: p.process(EXPR_BUILDER)\n        };\n    },\n    add (p) {\n        const left = p.process(EXPR_BUILDER), right = p.process(EXPR_BUILDER);\n        return {\n            type: \"OpCall\",\n            op: \"+\",\n            left,\n            right\n        };\n    },\n    sub (p) {\n        const left = p.process(EXPR_BUILDER), right = p.process(EXPR_BUILDER);\n        return {\n            type: \"OpCall\",\n            op: \"-\",\n            left,\n            right\n        };\n    },\n    mul (p) {\n        const left = p.process(EXPR_BUILDER), right = p.process(EXPR_BUILDER);\n        return {\n            type: \"OpCall\",\n            op: \"*\",\n            left,\n            right\n        };\n    },\n    div (p) {\n        const left = p.process(EXPR_BUILDER), right = p.process(EXPR_BUILDER);\n        return {\n            type: \"OpCall\",\n            op: \"/\",\n            left,\n            right\n        };\n    },\n    mod (p) {\n        const left = p.process(EXPR_BUILDER), right = p.process(EXPR_BUILDER);\n        return {\n            type: \"OpCall\",\n            op: \"%\",\n            left,\n            right\n        };\n    },\n    pow (p) {\n        const left = p.process(EXPR_BUILDER), right = p.process(EXPR_BUILDER);\n        return {\n            type: \"OpCall\",\n            op: \"**\",\n            left,\n            right\n        };\n    },\n    comp (p) {\n        const left = p.process(EXPR_BUILDER), op = p.processString(), right = p.process(EXPR_BUILDER);\n        return {\n            type: \"OpCall\",\n            op,\n            left,\n            right\n        };\n    },\n    in_range (p) {\n        const base = p.process(EXPR_BUILDER), isInclusive = p.getMark().name === \"inc_range\";\n        p.shift();\n        const left = p.process(EXPR_BUILDER), right = p.process(EXPR_BUILDER);\n        return {\n            type: \"InRange\",\n            base,\n            left,\n            right,\n            isInclusive\n        };\n    },\n    str (p) {\n        let value = \"\";\n        loop: for(; p.hasMark();){\n            const mark = p.getMark();\n            switch(mark.name){\n                case \"str_end\":\n                    value += p.processStringEnd();\n                    break loop;\n                case \"str_pause\":\n                    value += p.processStringEnd();\n                    break;\n                case \"str_start\":\n                    p.shift();\n                    break;\n                case \"single_escape\":\n                    {\n                        const char = p.slice(1);\n                        p.shift(), value += ESCAPE_SEQUENCE[char];\n                        break;\n                    }\n                case \"unicode_hex\":\n                    p.shift(), value += expandHex(p.processStringEnd());\n                    break;\n                default:\n                    throw new Error(`unexpected mark: ${mark.name}`);\n            }\n        }\n        return {\n            type: \"Value\",\n            value\n        };\n    },\n    integer (p) {\n        const strValue = p.processStringEnd();\n        return {\n            type: \"Value\",\n            value: Number(strValue)\n        };\n    },\n    float (p) {\n        const strValue = p.processStringEnd();\n        return {\n            type: \"Value\",\n            value: Number(strValue)\n        };\n    },\n    sci (p) {\n        const strValue = p.processStringEnd();\n        return {\n            type: \"Value\",\n            value: Number(strValue)\n        };\n    },\n    object (p) {\n        const attributes = [];\n        for(; p.getMark().name !== \"object_end\";)attributes.push(p.process(OBJECT_BUILDER));\n        return p.shift(), {\n            type: \"Object\",\n            attributes\n        };\n    },\n    array (p) {\n        const elements = [];\n        for(; p.getMark().name !== \"array_end\";){\n            let isSplat = !1;\n            p.getMark().name === \"array_splat\" && (isSplat = !0, p.shift());\n            const value = p.process(EXPR_BUILDER);\n            elements.push({\n                type: \"ArrayElement\",\n                value,\n                isSplat\n            });\n        }\n        return p.shift(), {\n            type: \"Array\",\n            elements\n        };\n    },\n    tuple (p) {\n        const members = [];\n        for(; p.getMark().name !== \"tuple_end\";)members.push(p.process(EXPR_BUILDER));\n        return p.shift(), {\n            type: \"Tuple\",\n            members\n        };\n    },\n    func_call (p) {\n        let namespace = \"global\";\n        p.getMark().name === \"namespace\" && (p.shift(), namespace = p.processString());\n        const name = p.processString();\n        if (namespace === \"global\" && name === \"select\") {\n            const result = {\n                type: \"Select\",\n                alternatives: []\n            };\n            for(; p.getMark().name !== \"func_args_end\";)if (p.getMark().name === \"pair\") {\n                if (result.fallback) throw new GroqQueryError(\"unexpected argument to select()\");\n                p.shift();\n                const condition = p.process(EXPR_BUILDER), value = p.process(EXPR_BUILDER);\n                result.alternatives.push({\n                    type: \"SelectAlternative\",\n                    condition,\n                    value\n                });\n            } else {\n                if (result.fallback) throw new GroqQueryError(\"unexpected argument to select()\");\n                const value = p.process(EXPR_BUILDER);\n                result.fallback = value;\n            }\n            return p.shift(), result;\n        }\n        const args = [];\n        for(; p.getMark().name !== \"func_args_end\";)argumentShouldBeSelector(namespace, name, args.length) ? (p.process(SELECTOR_BUILDER), args.push({\n            type: \"Selector\"\n        })) : args.push(p.process(EXPR_BUILDER));\n        if (p.shift(), namespace === \"global\" && (name === \"before\" || name === \"after\") && p.parseOptions.mode === \"delta\") return {\n            type: \"Context\",\n            key: name\n        };\n        if (namespace === \"global\" && name === \"boost\" && !p.allowBoost) throw new GroqQueryError(\"unexpected boost\");\n        const funcs = namespaces[namespace];\n        if (!funcs) throw new GroqQueryError(`Undefined namespace: ${namespace}`);\n        const func = funcs[name];\n        if (!func) throw new GroqQueryError(`Undefined function: ${name}`);\n        if (func.arity !== void 0 && validateArity(name, func.arity, args.length), func.mode !== void 0 && func.mode !== p.parseOptions.mode) throw new GroqQueryError(`Undefined function: ${name}`);\n        return {\n            type: \"FuncCall\",\n            func,\n            namespace,\n            name,\n            args\n        };\n    },\n    pipecall (p) {\n        const base = p.process(EXPR_BUILDER);\n        p.shift();\n        let namespace = \"global\";\n        if (p.getMark().name === \"namespace\" && (p.shift(), namespace = p.processString()), namespace !== \"global\") throw new GroqQueryError(`Undefined namespace: ${namespace}`);\n        const name = p.processString(), args = [], oldAllowBoost = p.allowBoost;\n        for(name === \"score\" && (p.allowBoost = !0);;){\n            const markName = p.getMark().name;\n            if (markName === \"func_args_end\") break;\n            if (name === \"order\") {\n                if (markName === \"asc\") {\n                    p.shift(), args.push({\n                        type: \"Asc\",\n                        base: p.process(EXPR_BUILDER)\n                    });\n                    continue;\n                } else if (markName === \"desc\") {\n                    p.shift(), args.push({\n                        type: \"Desc\",\n                        base: p.process(EXPR_BUILDER)\n                    });\n                    continue;\n                }\n            }\n            args.push(p.process(EXPR_BUILDER));\n        }\n        p.shift(), p.allowBoost = oldAllowBoost;\n        const func = pipeFunctions[name];\n        if (!func) throw new GroqQueryError(`Undefined pipe function: ${name}`);\n        return func.arity && validateArity(name, func.arity, args.length), {\n            type: \"PipeFuncCall\",\n            func,\n            base,\n            name,\n            args\n        };\n    },\n    pair (p) {\n        throw new GroqQueryError(\"unexpected =>\");\n    },\n    and (p) {\n        const left = p.process(EXPR_BUILDER), right = p.process(EXPR_BUILDER);\n        return {\n            type: \"And\",\n            left,\n            right\n        };\n    },\n    or (p) {\n        const left = p.process(EXPR_BUILDER), right = p.process(EXPR_BUILDER);\n        return {\n            type: \"Or\",\n            left,\n            right\n        };\n    },\n    not (p) {\n        return {\n            type: \"Not\",\n            base: p.process(EXPR_BUILDER)\n        };\n    },\n    asc (p) {\n        throw new GroqQueryError(\"unexpected asc\");\n    },\n    desc (p) {\n        throw new GroqQueryError(\"unexpected desc\");\n    },\n    param (p) {\n        const name = p.processString();\n        return p.parseOptions.params && p.parseOptions.params.hasOwnProperty(name) ? {\n            type: \"Value\",\n            value: p.parseOptions.params[name]\n        } : {\n            type: \"Parameter\",\n            name\n        };\n    }\n}, OBJECT_BUILDER = {\n    object_expr (p) {\n        if (p.getMark().name === \"pair\") {\n            p.shift();\n            const condition = p.process(EXPR_BUILDER), value2 = p.process(EXPR_BUILDER);\n            return {\n                type: \"ObjectConditionalSplat\",\n                condition,\n                value: value2\n            };\n        }\n        const value = p.process(EXPR_BUILDER);\n        return {\n            type: \"ObjectAttributeValue\",\n            name: extractPropertyKey(value),\n            value\n        };\n    },\n    object_pair (p) {\n        const name = p.process(EXPR_BUILDER);\n        if (name.type !== \"Value\") throw new Error(\"name must be string\");\n        const value = p.process(EXPR_BUILDER);\n        return {\n            type: \"ObjectAttributeValue\",\n            name: name.value,\n            value\n        };\n    },\n    object_splat (p) {\n        return {\n            type: \"ObjectSplat\",\n            value: p.process(EXPR_BUILDER)\n        };\n    },\n    object_splat_this () {\n        return {\n            type: \"ObjectSplat\",\n            value: {\n                type: \"This\"\n            }\n        };\n    }\n}, TRAVERSE_BUILDER = {\n    square_bracket (p) {\n        const expr = p.process(EXPR_BUILDER), value = tryConstantEvaluate(expr);\n        return value && value.type === \"number\" ? (right)=>traverseElement((base)=>({\n                    type: \"AccessElement\",\n                    base,\n                    index: value.data\n                }), right) : value && value.type === \"string\" ? (right)=>traversePlain((base)=>({\n                    type: \"AccessAttribute\",\n                    base,\n                    name: value.data\n                }), right) : (right)=>traverseArray((base)=>({\n                    type: \"Filter\",\n                    base,\n                    expr\n                }), right);\n    },\n    slice (p) {\n        const isInclusive = p.getMark().name === \"inc_range\";\n        p.shift();\n        const left = p.process(EXPR_BUILDER), right = p.process(EXPR_BUILDER), leftValue = tryConstantEvaluate(left), rightValue = tryConstantEvaluate(right);\n        if (!leftValue || !rightValue || leftValue.type !== \"number\" || rightValue.type !== \"number\") throw new GroqQueryError(\"slicing must use constant numbers\");\n        return (rhs)=>traverseArray((base)=>({\n                    type: \"Slice\",\n                    base,\n                    left: leftValue.data,\n                    right: rightValue.data,\n                    isInclusive\n                }), rhs);\n    },\n    projection (p) {\n        const obj = p.process(EXPR_BUILDER);\n        return (right)=>traverseProjection((base)=>({\n                    type: \"Projection\",\n                    base,\n                    expr: obj\n                }), right);\n    },\n    attr_access (p) {\n        const name = p.processString();\n        return (right)=>traversePlain((base)=>({\n                    type: \"AccessAttribute\",\n                    base,\n                    name\n                }), right);\n    },\n    deref (p) {\n        let attr = null;\n        p.getMark().name === \"deref_attr\" && (p.shift(), attr = p.processString());\n        const wrap = (base)=>attr ? {\n                type: \"AccessAttribute\",\n                base,\n                name: attr\n            } : base;\n        return (right)=>traversePlain((base)=>wrap({\n                    type: \"Deref\",\n                    base\n                }), right);\n    },\n    array_postfix (p) {\n        return (right)=>traverseArray((base)=>({\n                    type: \"ArrayCoerce\",\n                    base\n                }), right);\n    }\n}, SELECTOR_BUILDER = {\n    group (p) {\n        return p.process(SELECTOR_BUILDER), null;\n    },\n    everything () {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    this () {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    parent () {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    dblparent (p) {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    traverse (p) {\n        for(p.process(SELECTOR_BUILDER); p.getMark().name !== \"traversal_end\";)p.process(TRAVERSE_BUILDER);\n        return p.shift(), null;\n    },\n    this_attr (p) {\n        return p.processString(), null;\n    },\n    neg (p) {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    pos (p) {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    add (p) {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    sub (p) {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    mul (p) {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    div (p) {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    mod (p) {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    pow (p) {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    comp (p) {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    in_range (p) {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    str (p) {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    integer (p) {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    float (p) {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    sci (p) {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    object (p) {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    array (p) {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    tuple (p) {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    func_call (p, mark) {\n        const func = EXPR_BUILDER.func_call(p, mark);\n        if (func.name === \"anywhere\" && func.args.length === 1) return null;\n        throw new Error(\"Invalid selector syntax\");\n    },\n    pipecall (p) {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    pair (p) {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    and (p) {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    or (p) {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    not (p) {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    asc (p) {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    desc (p) {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    param (p) {\n        throw new Error(\"Invalid selector syntax\");\n    }\n};\nfunction extractPropertyKey(node) {\n    if (node.type === \"AccessAttribute\" && !node.base) return node.name;\n    if (node.type === \"Deref\" || node.type === \"Map\" || node.type === \"Projection\" || node.type === \"Slice\" || node.type === \"Filter\" || node.type === \"AccessElement\" || node.type === \"ArrayCoerce\") return extractPropertyKey(node.base);\n    throw new GroqQueryError(`Cannot determine property key for type: ${node.type}`);\n}\nfunction validateArity(name, arity, count) {\n    if (typeof arity == \"number\") {\n        if (count !== arity) throw new GroqQueryError(`Incorrect number of arguments to function ${name}(). Expected ${arity}, got ${count}.`);\n    } else if (arity && !arity(count)) throw new GroqQueryError(`Incorrect number of arguments to function ${name}().`);\n}\nfunction argumentShouldBeSelector(namespace, functionName, argCount) {\n    const functionsRequiringSelectors = [\n        \"changedAny\",\n        \"changedOnly\"\n    ];\n    return namespace == \"diff\" && argCount == 2 && functionsRequiringSelectors.includes(functionName);\n}\nclass GroqSyntaxError extends Error {\n    constructor(position){\n        super(`Syntax error in GROQ query at position ${position}`), __publicField(this, \"position\"), __publicField(this, \"name\", \"GroqSyntaxError\"), this.position = position;\n    }\n}\nfunction parse(input, options = {}) {\n    const result = parse$1(input);\n    if (result.type === \"error\") throw new GroqSyntaxError(result.position);\n    return new MarkProcessor(input, result.marks, options).process(EXPR_BUILDER);\n}\n //# sourceMappingURL=1.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ3JvcS1qcy9kaXN0LzEubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQSxJQUFJQSxjQUFjQyxPQUFPQyxjQUFjLEVBQUVDLG9CQUFvQixDQUFDQyxLQUFLQyxLQUFLQyxRQUFVRCxPQUFPRCxNQUFNSixZQUFZSSxLQUFLQyxLQUFLO1FBQUVFLFlBQVksQ0FBQztRQUFHQyxjQUFjLENBQUM7UUFBR0MsVUFBVSxDQUFDO1FBQUdIO0lBQU0sS0FBS0YsR0FBRyxDQUFDQyxJQUFJLEdBQUdDLE9BQU9JLGtCQUFrQixDQUFDTixLQUFLQyxLQUFLQyxRQUFXSCxDQUFBQSxrQkFBa0JDLEtBQUssT0FBT0MsT0FBTyxXQUFXQSxNQUFNLEtBQUtBLEtBQUtDLFFBQVFBLEtBQUk7QUFDeFQsU0FBU0ssYUFBYUMsTUFBTTtJQUMxQixPQUFPQSxPQUFPQyxPQUFPLENBQUMsdUJBQXVCO0FBQy9DO0FBQ0EsU0FBU0MsV0FBV0MsT0FBTztJQUN6QixNQUFNQyxLQUFLLEVBQUU7SUFDYixLQUFLLE1BQU1DLFFBQVFGLFFBQVFHLEtBQUssQ0FBQyxLQUMvQkQsU0FBUyxNQUFNRCxHQUFHRyxJQUFJLENBQUMsV0FBV0YsU0FBUyxPQUFPRCxHQUFHRyxJQUFJLENBQUMsUUFBUUgsR0FBR0csSUFBSSxDQUFDUixhQUFhTTtJQUN6RixPQUFPLElBQUlHLE9BQU8sQ0FBQyxDQUFDLEVBQUVKLEdBQUdLLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUN2QztBQUNBLE1BQU1DO0lBQ0pDLFlBQVlSLE9BQU8sQ0FBRTtRQUNuQkwsZ0JBQWdCLElBQUksRUFBRSxZQUFZQSxnQkFBZ0IsSUFBSSxFQUFFLGNBQWMsSUFBSSxDQUFDSyxPQUFPLEdBQUdBLFNBQVMsSUFBSSxDQUFDUyxTQUFTLEdBQUdWLFdBQVdDO0lBQzVIO0lBQ0FVLFFBQVFDLEdBQUcsRUFBRTtRQUNYLE9BQU8sSUFBSSxDQUFDRixTQUFTLENBQUNHLElBQUksQ0FBQ0Q7SUFDN0I7SUFD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LE1BQU1DLDhCQUE4QjtRQUFDO1FBQWM7S0FBYztJQUNqRSxPQUFPOUIsYUFBYSxVQUFVNkIsWUFBWSxLQUFLQyw0QkFBNEJDLFFBQVEsQ0FBQ0g7QUFDdEY7QUFDQSxNQUFNSSx3QkFBd0IvWjtJQUM1QjVELFlBQVlvVyxRQUFRLENBQUU7UUFDcEIsS0FBSyxDQUFDLENBQUMsdUNBQXVDLEVBQUVBLFNBQVMsQ0FBQyxHQUFHZ0QsY0FBYyxJQUFJLEVBQUUsYUFBYUEsY0FBYyxJQUFJLEVBQUUsUUFBUSxvQkFBb0IsSUFBSSxDQUFDaEQsUUFBUSxHQUFHQTtJQUNoSztBQUNGO0FBQ0EsU0FBU3dILE1BQU1DLEtBQUssRUFBRTVQLFVBQVUsQ0FBQyxDQUFDO0lBQ2hDLE1BQU1qTixTQUFTeVYsUUFBUW9IO0lBQ3ZCLElBQUk3YyxPQUFPd0MsSUFBSSxLQUFLLFNBQ2xCLE1BQU0sSUFBSW1hLGdCQUFnQjNjLE9BQU9vVixRQUFRO0lBQzNDLE9BQU8sSUFBSWYsY0FBY3dJLE9BQU83YyxPQUFPc1UsS0FBSyxFQUFFckgsU0FBUzJILE9BQU8sQ0FBQ29FO0FBQ2pFO0FBTUUsQ0FDRiw4QkFBOEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pYW5vbG1zdGVhZC5jb20vLi9ub2RlX21vZHVsZXMvZ3JvcS1qcy9kaXN0LzEubWpzPzk4YzEiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fZGVmUHJvcCQ1ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5LCBfX2RlZk5vcm1hbFByb3AkNSA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3AkNShvYmosIGtleSwgeyBlbnVtZXJhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCwgd3JpdGFibGU6ICEwLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWUsIF9fcHVibGljRmllbGQkNSA9IChvYmosIGtleSwgdmFsdWUpID0+IChfX2RlZk5vcm1hbFByb3AkNShvYmosIHR5cGVvZiBrZXkgIT0gXCJzeW1ib2xcIiA/IGtleSArIFwiXCIgOiBrZXksIHZhbHVlKSwgdmFsdWUpO1xuZnVuY3Rpb24gZXNjYXBlUmVnRXhwKHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoL1suKis/XiR7fSgpfFtcXF1cXFxcXS9nLCBcIlxcXFwkJlwiKTtcbn1cbmZ1bmN0aW9uIHBhdGhSZWdFeHAocGF0dGVybikge1xuICBjb25zdCByZSA9IFtdO1xuICBmb3IgKGNvbnN0IHBhcnQgb2YgcGF0dGVybi5zcGxpdChcIi5cIikpXG4gICAgcGFydCA9PT0gXCIqXCIgPyByZS5wdXNoKFwiW14uXStcIikgOiBwYXJ0ID09PSBcIioqXCIgPyByZS5wdXNoKFwiLipcIikgOiByZS5wdXNoKGVzY2FwZVJlZ0V4cChwYXJ0KSk7XG4gIHJldHVybiBuZXcgUmVnRXhwKGBeJHtyZS5qb2luKFwiLlwiKX0kYCk7XG59XG5jbGFzcyBQYXRoIHtcbiAgY29uc3RydWN0b3IocGF0dGVybikge1xuICAgIF9fcHVibGljRmllbGQkNSh0aGlzLCBcInBhdHRlcm5cIiksIF9fcHVibGljRmllbGQkNSh0aGlzLCBcInBhdHRlcm5SZVwiKSwgdGhpcy5wYXR0ZXJuID0gcGF0dGVybiwgdGhpcy5wYXR0ZXJuUmUgPSBwYXRoUmVnRXhwKHBhdHRlcm4pO1xuICB9XG4gIG1hdGNoZXMoc3RyKSB7XG4gICAgcmV0dXJuIHRoaXMucGF0dGVyblJlLnRlc3Qoc3RyKTtcbiAgfVxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHRoaXMucGF0dGVybjtcbiAgfVxufVxudmFyIF9fZGVmUHJvcCQ0ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5LCBfX2RlZk5vcm1hbFByb3AkNCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3AkNChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCwgd3JpdGFibGU6ICEwLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWUsIF9fcHVibGljRmllbGQkNCA9IChvYmosIGtleSwgdmFsdWUpID0+IChfX2RlZk5vcm1hbFByb3AkNChvYmosIHR5cGVvZiBrZXkgIT0gXCJzeW1ib2xcIiA/IGtleSArIFwiXCIgOiBrZXksIHZhbHVlKSwgdmFsdWUpO1xuY2xhc3MgU3RyZWFtVmFsdWUge1xuICBjb25zdHJ1Y3RvcihnZW5lcmF0b3IpIHtcbiAgICBfX3B1YmxpY0ZpZWxkJDQodGhpcywgXCJ0eXBlXCIsIFwic3RyZWFtXCIpLCBfX3B1YmxpY0ZpZWxkJDQodGhpcywgXCJnZW5lcmF0b3JcIiksIF9fcHVibGljRmllbGQkNCh0aGlzLCBcInRpY2tlclwiKSwgX19wdWJsaWNGaWVsZCQ0KHRoaXMsIFwiaXNEb25lXCIpLCBfX3B1YmxpY0ZpZWxkJDQodGhpcywgXCJkYXRhXCIpLCB0aGlzLmdlbmVyYXRvciA9IGdlbmVyYXRvciwgdGhpcy50aWNrZXIgPSBudWxsLCB0aGlzLmlzRG9uZSA9ICExLCB0aGlzLmRhdGEgPSBbXTtcbiAgfVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY2xhc3MtbWV0aG9kcy11c2UtdGhpc1xuICBpc0FycmF5KCkge1xuICAgIHJldHVybiAhMDtcbiAgfVxuICBhc3luYyBnZXQoKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgZm9yIGF3YWl0IChjb25zdCB2YWx1ZSBvZiB0aGlzKVxuICAgICAgcmVzdWx0LnB1c2goYXdhaXQgdmFsdWUuZ2V0KCkpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgYXN5bmMgKltTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSB7XG4gICAgbGV0IGkgPSAwO1xuICAgIGZvciAoOyA7ICkge1xuICAgICAgZm9yICg7IGkgPCB0aGlzLmRhdGEubGVuZ3RoOyBpKyspXG4gICAgICAgIHlpZWxkIHRoaXMuZGF0YVtpXTtcbiAgICAgIGlmICh0aGlzLmlzRG9uZSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgYXdhaXQgdGhpcy5fbmV4dFRpY2soKTtcbiAgICB9XG4gIH1cbiAgX25leHRUaWNrKCkge1xuICAgIGlmICh0aGlzLnRpY2tlcilcbiAgICAgIHJldHVybiB0aGlzLnRpY2tlcjtcbiAgICBsZXQgY3VycmVudFJlc29sdmVyO1xuICAgIGNvbnN0IHNldHVwVGlja2VyID0gKCkgPT4ge1xuICAgICAgdGhpcy50aWNrZXIgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICBjdXJyZW50UmVzb2x2ZXIgPSByZXNvbHZlO1xuICAgICAgfSk7XG4gICAgfSwgdGljayA9ICgpID0+IHtcbiAgICAgIGN1cnJlbnRSZXNvbHZlcigpLCBzZXR1cFRpY2tlcigpO1xuICAgIH0sIGZldGNoID0gYXN5bmMgKCkgPT4ge1xuICAgICAgZm9yIGF3YWl0IChjb25zdCB2YWx1ZSBvZiB0aGlzLmdlbmVyYXRvcigpKVxuICAgICAgICB0aGlzLmRhdGEucHVzaCh2YWx1ZSksIHRpY2soKTtcbiAgICAgIHRoaXMuaXNEb25lID0gITAsIHRpY2soKTtcbiAgICB9O1xuICAgIHJldHVybiBzZXR1cFRpY2tlcigpLCBmZXRjaCgpLCB0aGlzLnRpY2tlcjtcbiAgfVxufVxuY29uc3QgUkZDMzMzOV9SRUdFWCA9IC9eXFxkezR9LVxcZHsyfS1cXGR7Mn1UXFxkezJ9OlxcZHsyfTpcXGR7Mn0oXFwuXFxkKyk/KFp8KFstK11cXGR7Mn06XFxkezJ9KSkkLztcbmZ1bmN0aW9uIHBhcnNlUkZDMzMzOShzdHIpIHtcbiAgcmV0dXJuIFJGQzMzMzlfUkVHRVgudGVzdChzdHIpID8gbmV3IERhdGUoc3RyKSA6IG51bGw7XG59XG5mdW5jdGlvbiBmb3JtYXRSRkMzMzM5KGQpIHtcbiAgY29uc3QgeWVhciA9IGFkZExlYWRpbmdaZXJvKGQuZ2V0VVRDRnVsbFllYXIoKSwgNCksIG1vbnRoID0gYWRkTGVhZGluZ1plcm8oZC5nZXRVVENNb250aCgpICsgMSwgMiksIGRheSA9IGFkZExlYWRpbmdaZXJvKGQuZ2V0VVRDRGF0ZSgpLCAyKSwgaG91ciA9IGFkZExlYWRpbmdaZXJvKGQuZ2V0VVRDSG91cnMoKSwgMiksIG1pbnV0ZSA9IGFkZExlYWRpbmdaZXJvKGQuZ2V0VVRDTWludXRlcygpLCAyKSwgc2Vjb25kID0gYWRkTGVhZGluZ1plcm8oZC5nZXRVVENTZWNvbmRzKCksIDIpO1xuICBsZXQgZnJhY3Rpb25hbFNlY29uZCA9IFwiXCI7XG4gIGNvbnN0IG1pbGxpcyA9IGQuZ2V0TWlsbGlzZWNvbmRzKCk7XG4gIHJldHVybiBtaWxsaXMgIT0gMCAmJiAoZnJhY3Rpb25hbFNlY29uZCA9IGAuJHthZGRMZWFkaW5nWmVybyhtaWxsaXMsIDMpfWApLCBgJHt5ZWFyfS0ke21vbnRofS0ke2RheX1UJHtob3VyfToke21pbnV0ZX06JHtzZWNvbmR9JHtmcmFjdGlvbmFsU2Vjb25kfVpgO1xufVxuZnVuY3Rpb24gYWRkTGVhZGluZ1plcm8obnVtLCB0YXJnZXRMZW5ndGgpIHtcbiAgbGV0IHN0ciA9IG51bS50b1N0cmluZygpO1xuICBmb3IgKDsgc3RyLmxlbmd0aCA8IHRhcmdldExlbmd0aDsgKVxuICAgIHN0ciA9IGAwJHtzdHJ9YDtcbiAgcmV0dXJuIHN0cjtcbn1cbnZhciBfX2RlZlByb3AkMyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSwgX19kZWZOb3JtYWxQcm9wJDMgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wJDMob2JqLCBrZXksIHsgZW51bWVyYWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAsIHdyaXRhYmxlOiAhMCwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlLCBfX3B1YmxpY0ZpZWxkJDMgPSAob2JqLCBrZXksIHZhbHVlKSA9PiAoX19kZWZOb3JtYWxQcm9wJDMob2JqLCB0eXBlb2Yga2V5ICE9IFwic3ltYm9sXCIgPyBrZXkgKyBcIlwiIDoga2V5LCB2YWx1ZSksIHZhbHVlKTtcbmNsYXNzIFN0YXRpY1ZhbHVlIHtcbiAgY29uc3RydWN0b3IoZGF0YSwgdHlwZSkge1xuICAgIF9fcHVibGljRmllbGQkMyh0aGlzLCBcImRhdGFcIiksIF9fcHVibGljRmllbGQkMyh0aGlzLCBcInR5cGVcIiksIHRoaXMuZGF0YSA9IGRhdGEsIHRoaXMudHlwZSA9IHR5cGU7XG4gIH1cbiAgaXNBcnJheSgpIHtcbiAgICByZXR1cm4gdGhpcy50eXBlID09PSBcImFycmF5XCI7XG4gIH1cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlcXVpcmUtYXdhaXRcbiAgYXN5bmMgZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLmRhdGE7XG4gIH1cbiAgW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLmRhdGEpKVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKiAoZGF0YSkge1xuICAgICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgZGF0YSlcbiAgICAgICAgICB5aWVsZCBmcm9tSlMoZWxlbWVudCk7XG4gICAgICB9KHRoaXMuZGF0YSk7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgaXRlcmF0ZSBvdmVyOiAke3RoaXMudHlwZX1gKTtcbiAgfVxufVxuY29uc3QgTlVMTF9WQUxVRSA9IG5ldyBTdGF0aWNWYWx1ZShudWxsLCBcIm51bGxcIiksIFRSVUVfVkFMVUUgPSBuZXcgU3RhdGljVmFsdWUoITAsIFwiYm9vbGVhblwiKSwgRkFMU0VfVkFMVUUgPSBuZXcgU3RhdGljVmFsdWUoITEsIFwiYm9vbGVhblwiKTtcbmNsYXNzIERhdGVUaW1lIHtcbiAgY29uc3RydWN0b3IoZGF0ZSkge1xuICAgIF9fcHVibGljRmllbGQkMyh0aGlzLCBcImRhdGVcIiksIHRoaXMuZGF0ZSA9IGRhdGU7XG4gIH1cbiAgc3RhdGljIHBhcnNlVG9WYWx1ZShzdHIpIHtcbiAgICBjb25zdCBkYXRlID0gcGFyc2VSRkMzMzM5KHN0cik7XG4gICAgcmV0dXJuIGRhdGUgPyBuZXcgU3RhdGljVmFsdWUobmV3IERhdGVUaW1lKGRhdGUpLCBcImRhdGV0aW1lXCIpIDogTlVMTF9WQUxVRTtcbiAgfVxuICBlcXVhbHMob3RoZXIpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRlLmdldFRpbWUoKSA9PSBvdGhlci5kYXRlLmdldFRpbWUoKTtcbiAgfVxuICBhZGQoc2Vjcykge1xuICAgIGNvbnN0IGNvcHkgPSBuZXcgRGF0ZSh0aGlzLmRhdGUuZ2V0VGltZSgpKTtcbiAgICByZXR1cm4gY29weS5zZXRUaW1lKGNvcHkuZ2V0VGltZSgpICsgc2VjcyAqIDFlMyksIG5ldyBEYXRlVGltZShjb3B5KTtcbiAgfVxuICBkaWZmZXJlbmNlKG90aGVyKSB7XG4gICAgcmV0dXJuICh0aGlzLmRhdGUuZ2V0VGltZSgpIC0gb3RoZXIuZGF0ZS5nZXRUaW1lKCkpIC8gMWUzO1xuICB9XG4gIGNvbXBhcmVUbyhvdGhlcikge1xuICAgIHJldHVybiB0aGlzLmRhdGUuZ2V0VGltZSgpIC0gb3RoZXIuZGF0ZS5nZXRUaW1lKCk7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIGZvcm1hdFJGQzMzMzkodGhpcy5kYXRlKTtcbiAgfVxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHRoaXMudG9TdHJpbmcoKTtcbiAgfVxufVxuZnVuY3Rpb24gZnJvbU51bWJlcihudW0pIHtcbiAgcmV0dXJuIE51bWJlci5pc0Zpbml0ZShudW0pID8gbmV3IFN0YXRpY1ZhbHVlKG51bSwgXCJudW1iZXJcIikgOiBOVUxMX1ZBTFVFO1xufVxuZnVuY3Rpb24gZnJvbVN0cmluZyhzdHIpIHtcbiAgcmV0dXJuIG5ldyBTdGF0aWNWYWx1ZShzdHIsIFwic3RyaW5nXCIpO1xufVxuZnVuY3Rpb24gZnJvbURhdGVUaW1lKGR0KSB7XG4gIHJldHVybiBuZXcgU3RhdGljVmFsdWUoZHQsIFwiZGF0ZXRpbWVcIik7XG59XG5mdW5jdGlvbiBmcm9tUGF0aChwYXRoKSB7XG4gIHJldHVybiBuZXcgU3RhdGljVmFsdWUocGF0aCwgXCJwYXRoXCIpO1xufVxuZnVuY3Rpb24gaXNJdGVyYXRvcihvYmopIHtcbiAgcmV0dXJuIG9iaiAmJiB0eXBlb2Ygb2JqLm5leHQgPT0gXCJmdW5jdGlvblwiO1xufVxuZnVuY3Rpb24gZnJvbUpTKHZhbCkge1xuICByZXR1cm4gaXNJdGVyYXRvcih2YWwpID8gbmV3IFN0cmVhbVZhbHVlKGFzeW5jIGZ1bmN0aW9uKiAoKSB7XG4gICAgZm9yIGF3YWl0IChjb25zdCB2YWx1ZSBvZiB2YWwpXG4gICAgICB5aWVsZCBmcm9tSlModmFsdWUpO1xuICB9KSA6IHZhbCA9PSBudWxsID8gTlVMTF9WQUxVRSA6IG5ldyBTdGF0aWNWYWx1ZSh2YWwsIGdldFR5cGUodmFsKSk7XG59XG5mdW5jdGlvbiBnZXRUeXBlKGRhdGEpIHtcbiAgcmV0dXJuIGRhdGEgPT09IG51bGwgfHwgdHlwZW9mIGRhdGEgPiBcInVcIiA/IFwibnVsbFwiIDogQXJyYXkuaXNBcnJheShkYXRhKSA/IFwiYXJyYXlcIiA6IGRhdGEgaW5zdGFuY2VvZiBQYXRoID8gXCJwYXRoXCIgOiBkYXRhIGluc3RhbmNlb2YgRGF0ZVRpbWUgPyBcImRhdGV0aW1lXCIgOiB0eXBlb2YgZGF0YTtcbn1cbmZ1bmN0aW9uIGlzRXF1YWwoYSwgYikge1xuICByZXR1cm4gYS50eXBlID09PSBcInN0cmluZ1wiICYmIGIudHlwZSA9PT0gXCJzdHJpbmdcIiB8fCBhLnR5cGUgPT09IFwiYm9vbGVhblwiICYmIGIudHlwZSA9PT0gXCJib29sZWFuXCIgfHwgYS50eXBlID09PSBcIm51bGxcIiAmJiBiLnR5cGUgPT09IFwibnVsbFwiIHx8IGEudHlwZSA9PT0gXCJudW1iZXJcIiAmJiBiLnR5cGUgPT09IFwibnVtYmVyXCIgPyBhLmRhdGEgPT09IGIuZGF0YSA6IGEudHlwZSA9PT0gXCJkYXRldGltZVwiICYmIGIudHlwZSA9PT0gXCJkYXRldGltZVwiID8gYS5kYXRhLmVxdWFscyhiLmRhdGEpIDogITE7XG59XG5jb25zdCBDSEFSUyA9IC8oW14hQCMkJV4mKigpLFxcXFwvP1wiOzp7fXxbXFxdKzw+XFxzLV0pKy9nLCBDSEFSU19XSVRIX1dJTERDQVJEID0gLyhbXiFAIyQlXiYoKSxcXFxcLz9cIjs6e318W1xcXSs8Plxccy1dKSsvZywgRURHRV9DSEFSUyA9IC8oXFxiXFwuK3xcXC4rXFxiKS9nLCBNQVhfVEVSTV9MRU5HVEggPSAxMDI0O1xuZnVuY3Rpb24gbWF0Y2hUZXh0KHRva2VucywgcGF0dGVybnMpIHtcbiAgcmV0dXJuIHRva2Vucy5sZW5ndGggPT09IDAgfHwgcGF0dGVybnMubGVuZ3RoID09PSAwID8gITEgOiBwYXR0ZXJucy5ldmVyeSgocGF0dGVybikgPT4gcGF0dGVybih0b2tlbnMpKTtcbn1cbmZ1bmN0aW9uIG1hdGNoVG9rZW5pemUodGV4dCkge1xuICByZXR1cm4gdGV4dC5yZXBsYWNlKEVER0VfQ0hBUlMsIFwiXCIpLm1hdGNoKENIQVJTKSB8fCBbXTtcbn1cbmZ1bmN0aW9uIG1hdGNoQW5hbHl6ZVBhdHRlcm4odGV4dCkge1xuICByZXR1cm4gbWF0Y2hQYXR0ZXJuUmVnZXgodGV4dCkubWFwKChyZSkgPT4gKHRva2VucykgPT4gdG9rZW5zLnNvbWUoKHRva2VuKSA9PiByZS50ZXN0KHRva2VuKSkpO1xufVxuZnVuY3Rpb24gbWF0Y2hQYXR0ZXJuUmVnZXgodGV4dCkge1xuICByZXR1cm4gKHRleHQucmVwbGFjZShFREdFX0NIQVJTLCBcIlwiKS5tYXRjaChDSEFSU19XSVRIX1dJTERDQVJEKSB8fCBbXSkubWFwKFxuICAgICh0ZXJtKSA9PiBuZXcgUmVnRXhwKGBeJHt0ZXJtLnNsaWNlKDAsIE1BWF9URVJNX0xFTkdUSCkucmVwbGFjZSgvXFwqL2csIFwiLipcIil9JGAsIFwiaVwiKVxuICApO1xufVxuYXN5bmMgZnVuY3Rpb24gZ2F0aGVyVGV4dCh2YWx1ZSwgY2IpIHtcbiAgaWYgKHZhbHVlLnR5cGUgPT09IFwic3RyaW5nXCIpXG4gICAgcmV0dXJuIGNiKHZhbHVlLmRhdGEpLCAhMDtcbiAgaWYgKHZhbHVlLmlzQXJyYXkoKSkge1xuICAgIGxldCBzdWNjZXNzID0gITA7XG4gICAgZm9yIGF3YWl0IChjb25zdCBwYXJ0IG9mIHZhbHVlKVxuICAgICAgcGFydC50eXBlID09PSBcInN0cmluZ1wiID8gY2IocGFydC5kYXRhKSA6IHN1Y2Nlc3MgPSAhMTtcbiAgICByZXR1cm4gc3VjY2VzcztcbiAgfVxuICByZXR1cm4gITE7XG59XG5jb25zdCBUWVBFX09SREVSID0ge1xuICBkYXRldGltZTogMSxcbiAgbnVtYmVyOiAyLFxuICBzdHJpbmc6IDMsXG4gIGJvb2xlYW46IDRcbn07XG5mdW5jdGlvbiBwYXJ0aWFsQ29tcGFyZShhLCBiKSB7XG4gIGNvbnN0IGFUeXBlID0gZ2V0VHlwZShhKSwgYlR5cGUgPSBnZXRUeXBlKGIpO1xuICBpZiAoYVR5cGUgIT09IGJUeXBlKVxuICAgIHJldHVybiBudWxsO1xuICBzd2l0Y2ggKGFUeXBlKSB7XG4gICAgY2FzZSBcIm51bWJlclwiOlxuICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICByZXR1cm4gYSAtIGI7XG4gICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgcmV0dXJuIGEgPCBiID8gLTEgOiBhID4gYiA/IDEgOiAwO1xuICAgIGNhc2UgXCJkYXRldGltZVwiOlxuICAgICAgcmV0dXJuIGEuY29tcGFyZVRvKGIpO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuZnVuY3Rpb24gdG90YWxDb21wYXJlKGEsIGIpIHtcbiAgY29uc3QgYVR5cGUgPSBnZXRUeXBlKGEpLCBiVHlwZSA9IGdldFR5cGUoYiksIGFUeXBlT3JkZXIgPSBUWVBFX09SREVSW2FUeXBlXSB8fCAxMDAsIGJUeXBlT3JkZXIgPSBUWVBFX09SREVSW2JUeXBlXSB8fCAxMDA7XG4gIGlmIChhVHlwZU9yZGVyICE9PSBiVHlwZU9yZGVyKVxuICAgIHJldHVybiBhVHlwZU9yZGVyIC0gYlR5cGVPcmRlcjtcbiAgbGV0IHJlc3VsdCA9IHBhcnRpYWxDb21wYXJlKGEsIGIpO1xuICByZXR1cm4gcmVzdWx0ID09PSBudWxsICYmIChyZXN1bHQgPSAwKSwgcmVzdWx0O1xufVxuY29uc3Qgb3BlcmF0b3JzID0ge1xuICBcIj09XCI6IGZ1bmN0aW9uKGxlZnQsIHJpZ2h0KSB7XG4gICAgcmV0dXJuIGlzRXF1YWwobGVmdCwgcmlnaHQpID8gVFJVRV9WQUxVRSA6IEZBTFNFX1ZBTFVFO1xuICB9LFxuICBcIiE9XCI6IGZ1bmN0aW9uKGxlZnQsIHJpZ2h0KSB7XG4gICAgcmV0dXJuIGlzRXF1YWwobGVmdCwgcmlnaHQpID8gRkFMU0VfVkFMVUUgOiBUUlVFX1ZBTFVFO1xuICB9LFxuICBcIj5cIjogZnVuY3Rpb24obGVmdCwgcmlnaHQpIHtcbiAgICBpZiAobGVmdC50eXBlID09PSBcInN0cmVhbVwiIHx8IHJpZ2h0LnR5cGUgPT09IFwic3RyZWFtXCIpXG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICBjb25zdCByZXN1bHQgPSBwYXJ0aWFsQ29tcGFyZShsZWZ0LmRhdGEsIHJpZ2h0LmRhdGEpO1xuICAgIHJldHVybiByZXN1bHQgPT09IG51bGwgPyBOVUxMX1ZBTFVFIDogcmVzdWx0ID4gMCA/IFRSVUVfVkFMVUUgOiBGQUxTRV9WQUxVRTtcbiAgfSxcbiAgXCI+PVwiOiBmdW5jdGlvbihsZWZ0LCByaWdodCkge1xuICAgIGlmIChsZWZ0LnR5cGUgPT09IFwic3RyZWFtXCIgfHwgcmlnaHQudHlwZSA9PT0gXCJzdHJlYW1cIilcbiAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgIGNvbnN0IHJlc3VsdCA9IHBhcnRpYWxDb21wYXJlKGxlZnQuZGF0YSwgcmlnaHQuZGF0YSk7XG4gICAgcmV0dXJuIHJlc3VsdCA9PT0gbnVsbCA/IE5VTExfVkFMVUUgOiByZXN1bHQgPj0gMCA/IFRSVUVfVkFMVUUgOiBGQUxTRV9WQUxVRTtcbiAgfSxcbiAgXCI8XCI6IGZ1bmN0aW9uKGxlZnQsIHJpZ2h0KSB7XG4gICAgaWYgKGxlZnQudHlwZSA9PT0gXCJzdHJlYW1cIiB8fCByaWdodC50eXBlID09PSBcInN0cmVhbVwiKVxuICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgY29uc3QgcmVzdWx0ID0gcGFydGlhbENvbXBhcmUobGVmdC5kYXRhLCByaWdodC5kYXRhKTtcbiAgICByZXR1cm4gcmVzdWx0ID09PSBudWxsID8gTlVMTF9WQUxVRSA6IHJlc3VsdCA8IDAgPyBUUlVFX1ZBTFVFIDogRkFMU0VfVkFMVUU7XG4gIH0sXG4gIFwiPD1cIjogZnVuY3Rpb24obGVmdCwgcmlnaHQpIHtcbiAgICBpZiAobGVmdC50eXBlID09PSBcInN0cmVhbVwiIHx8IHJpZ2h0LnR5cGUgPT09IFwic3RyZWFtXCIpXG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICBjb25zdCByZXN1bHQgPSBwYXJ0aWFsQ29tcGFyZShsZWZ0LmRhdGEsIHJpZ2h0LmRhdGEpO1xuICAgIHJldHVybiByZXN1bHQgPT09IG51bGwgPyBOVUxMX1ZBTFVFIDogcmVzdWx0IDw9IDAgPyBUUlVFX1ZBTFVFIDogRkFMU0VfVkFMVUU7XG4gIH0sXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWUtbWF0Y2hpbmdcbiAgaW46IGFzeW5jIGZ1bmN0aW9uKGxlZnQsIHJpZ2h0KSB7XG4gICAgaWYgKHJpZ2h0LnR5cGUgPT09IFwicGF0aFwiKVxuICAgICAgcmV0dXJuIGxlZnQudHlwZSAhPT0gXCJzdHJpbmdcIiA/IE5VTExfVkFMVUUgOiByaWdodC5kYXRhLm1hdGNoZXMobGVmdC5kYXRhKSA/IFRSVUVfVkFMVUUgOiBGQUxTRV9WQUxVRTtcbiAgICBpZiAocmlnaHQuaXNBcnJheSgpKSB7XG4gICAgICBmb3IgYXdhaXQgKGNvbnN0IGIgb2YgcmlnaHQpXG4gICAgICAgIGlmIChpc0VxdWFsKGxlZnQsIGIpKVxuICAgICAgICAgIHJldHVybiBUUlVFX1ZBTFVFO1xuICAgICAgcmV0dXJuIEZBTFNFX1ZBTFVFO1xuICAgIH1cbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgfSxcbiAgbWF0Y2g6IGFzeW5jIGZ1bmN0aW9uKGxlZnQsIHJpZ2h0KSB7XG4gICAgbGV0IHRva2VucyA9IFtdLCBwYXR0ZXJucyA9IFtdO1xuICAgIHJldHVybiBhd2FpdCBnYXRoZXJUZXh0KGxlZnQsIChwYXJ0KSA9PiB7XG4gICAgICB0b2tlbnMgPSB0b2tlbnMuY29uY2F0KG1hdGNoVG9rZW5pemUocGFydCkpO1xuICAgIH0pLCBhd2FpdCBnYXRoZXJUZXh0KHJpZ2h0LCAocGFydCkgPT4ge1xuICAgICAgcGF0dGVybnMgPSBwYXR0ZXJucy5jb25jYXQobWF0Y2hBbmFseXplUGF0dGVybihwYXJ0KSk7XG4gICAgfSkgJiYgbWF0Y2hUZXh0KHRva2VucywgcGF0dGVybnMpID8gVFJVRV9WQUxVRSA6IEZBTFNFX1ZBTFVFO1xuICB9LFxuICBcIitcIjogZnVuY3Rpb24obGVmdCwgcmlnaHQpIHtcbiAgICByZXR1cm4gbGVmdC50eXBlID09PSBcImRhdGV0aW1lXCIgJiYgcmlnaHQudHlwZSA9PT0gXCJudW1iZXJcIiA/IGZyb21EYXRlVGltZShsZWZ0LmRhdGEuYWRkKHJpZ2h0LmRhdGEpKSA6IGxlZnQudHlwZSA9PT0gXCJudW1iZXJcIiAmJiByaWdodC50eXBlID09PSBcIm51bWJlclwiID8gZnJvbU51bWJlcihsZWZ0LmRhdGEgKyByaWdodC5kYXRhKSA6IGxlZnQudHlwZSA9PT0gXCJzdHJpbmdcIiAmJiByaWdodC50eXBlID09PSBcInN0cmluZ1wiID8gZnJvbVN0cmluZyhsZWZ0LmRhdGEgKyByaWdodC5kYXRhKSA6IGxlZnQudHlwZSA9PT0gXCJvYmplY3RcIiAmJiByaWdodC50eXBlID09PSBcIm9iamVjdFwiID8gZnJvbUpTKHsgLi4ubGVmdC5kYXRhLCAuLi5yaWdodC5kYXRhIH0pIDogbGVmdC50eXBlID09PSBcImFycmF5XCIgJiYgcmlnaHQudHlwZSA9PT0gXCJhcnJheVwiID8gZnJvbUpTKGxlZnQuZGF0YS5jb25jYXQocmlnaHQuZGF0YSkpIDogbGVmdC5pc0FycmF5KCkgJiYgcmlnaHQuaXNBcnJheSgpID8gbmV3IFN0cmVhbVZhbHVlKGFzeW5jIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBmb3IgYXdhaXQgKGNvbnN0IHZhbCBvZiBsZWZ0KVxuICAgICAgICB5aWVsZCB2YWw7XG4gICAgICBmb3IgYXdhaXQgKGNvbnN0IHZhbCBvZiByaWdodClcbiAgICAgICAgeWllbGQgdmFsO1xuICAgIH0pIDogTlVMTF9WQUxVRTtcbiAgfSxcbiAgXCItXCI6IGZ1bmN0aW9uKGxlZnQsIHJpZ2h0KSB7XG4gICAgcmV0dXJuIGxlZnQudHlwZSA9PT0gXCJkYXRldGltZVwiICYmIHJpZ2h0LnR5cGUgPT09IFwibnVtYmVyXCIgPyBmcm9tRGF0ZVRpbWUobGVmdC5kYXRhLmFkZCgtcmlnaHQuZGF0YSkpIDogbGVmdC50eXBlID09PSBcImRhdGV0aW1lXCIgJiYgcmlnaHQudHlwZSA9PT0gXCJkYXRldGltZVwiID8gZnJvbU51bWJlcihsZWZ0LmRhdGEuZGlmZmVyZW5jZShyaWdodC5kYXRhKSkgOiBsZWZ0LnR5cGUgPT09IFwibnVtYmVyXCIgJiYgcmlnaHQudHlwZSA9PT0gXCJudW1iZXJcIiA/IGZyb21OdW1iZXIobGVmdC5kYXRhIC0gcmlnaHQuZGF0YSkgOiBOVUxMX1ZBTFVFO1xuICB9LFxuICBcIipcIjogbnVtZXJpY09wZXJhdG9yKChhLCBiKSA9PiBhICogYiksXG4gIFwiL1wiOiBudW1lcmljT3BlcmF0b3IoKGEsIGIpID0+IGEgLyBiKSxcbiAgXCIlXCI6IG51bWVyaWNPcGVyYXRvcigoYSwgYikgPT4gYSAlIGIpLFxuICBcIioqXCI6IG51bWVyaWNPcGVyYXRvcigoYSwgYikgPT4gTWF0aC5wb3coYSwgYikpXG59O1xuZnVuY3Rpb24gbnVtZXJpY09wZXJhdG9yKGltcGwpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGxlZnQsIHJpZ2h0KSB7XG4gICAgaWYgKGxlZnQudHlwZSA9PT0gXCJudW1iZXJcIiAmJiByaWdodC50eXBlID09PSBcIm51bWJlclwiKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBpbXBsKGxlZnQuZGF0YSwgcmlnaHQuZGF0YSk7XG4gICAgICByZXR1cm4gZnJvbU51bWJlcihyZXN1bHQpO1xuICAgIH1cbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgfTtcbn1cbnZhciBfX2RlZlByb3AkMiA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSwgX19kZWZOb3JtYWxQcm9wJDIgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wJDIob2JqLCBrZXksIHsgZW51bWVyYWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAsIHdyaXRhYmxlOiAhMCwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlLCBfX3B1YmxpY0ZpZWxkJDIgPSAob2JqLCBrZXksIHZhbHVlKSA9PiAoX19kZWZOb3JtYWxQcm9wJDIob2JqLCB0eXBlb2Yga2V5ICE9IFwic3ltYm9sXCIgPyBrZXkgKyBcIlwiIDoga2V5LCB2YWx1ZSksIHZhbHVlKTtcbmNsYXNzIFNjb3BlIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9leHBsaWNpdC1tb2R1bGUtYm91bmRhcnktdHlwZXNcbiAgY29uc3RydWN0b3IocGFyYW1zLCBzb3VyY2UsIHZhbHVlLCBjb250ZXh0LCBwYXJlbnQpIHtcbiAgICBfX3B1YmxpY0ZpZWxkJDIodGhpcywgXCJwYXJhbXNcIiksIF9fcHVibGljRmllbGQkMih0aGlzLCBcInNvdXJjZVwiKSwgX19wdWJsaWNGaWVsZCQyKHRoaXMsIFwidmFsdWVcIiksIF9fcHVibGljRmllbGQkMih0aGlzLCBcInBhcmVudFwiKSwgX19wdWJsaWNGaWVsZCQyKHRoaXMsIFwiY29udGV4dFwiKSwgX19wdWJsaWNGaWVsZCQyKHRoaXMsIFwiaXNIaWRkZW5cIiwgITEpLCB0aGlzLnBhcmFtcyA9IHBhcmFtcywgdGhpcy5zb3VyY2UgPSBzb3VyY2UsIHRoaXMudmFsdWUgPSB2YWx1ZSwgdGhpcy5jb250ZXh0ID0gY29udGV4dCwgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gIH1cbiAgY3JlYXRlTmVzdGVkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNIaWRkZW4gPyBuZXcgU2NvcGUodGhpcy5wYXJhbXMsIHRoaXMuc291cmNlLCB2YWx1ZSwgdGhpcy5jb250ZXh0LCB0aGlzLnBhcmVudCkgOiBuZXcgU2NvcGUodGhpcy5wYXJhbXMsIHRoaXMuc291cmNlLCB2YWx1ZSwgdGhpcy5jb250ZXh0LCB0aGlzKTtcbiAgfVxuICBjcmVhdGVIaWRkZW4odmFsdWUpIHtcbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLmNyZWF0ZU5lc3RlZCh2YWx1ZSk7XG4gICAgcmV0dXJuIHJlc3VsdC5pc0hpZGRlbiA9ICEwLCByZXN1bHQ7XG4gIH1cbn1cbmZ1bmN0aW9uIGV2YWx1YXRlKG5vZGUsIHNjb3BlLCBleGVjdXRlID0gZXZhbHVhdGUpIHtcbiAgY29uc3QgZnVuYyA9IEVYRUNVVE9SU1tub2RlLnR5cGVdO1xuICByZXR1cm4gZnVuYyhub2RlLCBzY29wZSwgZXhlY3V0ZSk7XG59XG5mdW5jdGlvbiBwcm9taXNlbGVzc0FwcGx5KHZhbHVlLCBjYikge1xuICByZXR1cm4gXCJ0aGVuXCIgaW4gdmFsdWUgPyB2YWx1ZS50aGVuKGNiKSA6IGNiKHZhbHVlKTtcbn1cbmNvbnN0IEVYRUNVVE9SUyA9IHtcbiAgVGhpcyhfLCBzY29wZSkge1xuICAgIHJldHVybiBzY29wZS52YWx1ZTtcbiAgfSxcbiAgU2VsZWN0b3IoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiU2VsZWN0b3JzIGNhbiBub3QgYmUgZXZhbHVhdGVkXCIpO1xuICB9LFxuICBFdmVyeXRoaW5nKF8sIHNjb3BlKSB7XG4gICAgcmV0dXJuIHNjb3BlLnNvdXJjZTtcbiAgfSxcbiAgUGFyYW1ldGVyKHsgbmFtZSB9LCBzY29wZSkge1xuICAgIHJldHVybiBmcm9tSlMoc2NvcGUucGFyYW1zW25hbWVdKTtcbiAgfSxcbiAgQ29udGV4dCh7IGtleSB9LCBzY29wZSkge1xuICAgIGlmIChrZXkgPT09IFwiYmVmb3JlXCIgfHwga2V5ID09PSBcImFmdGVyXCIpXG4gICAgICByZXR1cm4gc2NvcGUuY29udGV4dFtrZXldIHx8IE5VTExfVkFMVUU7XG4gICAgdGhyb3cgbmV3IEVycm9yKGB1bmtub3duIGNvbnRleHQga2V5OiAke2tleX1gKTtcbiAgfSxcbiAgUGFyZW50KHsgbiB9LCBzY29wZSkge1xuICAgIGxldCBjdXJyZW50ID0gc2NvcGU7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgIGlmICghY3VycmVudC5wYXJlbnQpXG4gICAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50O1xuICAgIH1cbiAgICByZXR1cm4gY3VycmVudC52YWx1ZTtcbiAgfSxcbiAgT3BDYWxsKHsgb3AsIGxlZnQsIHJpZ2h0IH0sIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgY29uc3QgZnVuYyA9IG9wZXJhdG9yc1tvcF07XG4gICAgaWYgKCFmdW5jKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIG9wZXJhdG9yOiAke29wfWApO1xuICAgIGNvbnN0IGxlZnRWYWx1ZSA9IGV4ZWN1dGUobGVmdCwgc2NvcGUpLCByaWdodFZhbHVlID0gZXhlY3V0ZShyaWdodCwgc2NvcGUpO1xuICAgIHJldHVybiBcInRoZW5cIiBpbiBsZWZ0VmFsdWUgfHwgXCJ0aGVuXCIgaW4gcmlnaHRWYWx1ZSA/IChhc3luYyAoKSA9PiBmdW5jKGF3YWl0IGxlZnRWYWx1ZSwgYXdhaXQgcmlnaHRWYWx1ZSkpKCkgOiBmdW5jKGxlZnRWYWx1ZSwgcmlnaHRWYWx1ZSk7XG4gIH0sXG4gIGFzeW5jIFNlbGVjdCh7IGFsdGVybmF0aXZlcywgZmFsbGJhY2sgfSwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICBmb3IgKGNvbnN0IGFsdCBvZiBhbHRlcm5hdGl2ZXMpIHtcbiAgICAgIGNvbnN0IGFsdENvbmQgPSBhd2FpdCBleGVjdXRlKGFsdC5jb25kaXRpb24sIHNjb3BlKTtcbiAgICAgIGlmIChhbHRDb25kLnR5cGUgPT09IFwiYm9vbGVhblwiICYmIGFsdENvbmQuZGF0YSA9PT0gITApXG4gICAgICAgIHJldHVybiBleGVjdXRlKGFsdC52YWx1ZSwgc2NvcGUpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsbGJhY2sgPyBleGVjdXRlKGZhbGxiYWNrLCBzY29wZSkgOiBOVUxMX1ZBTFVFO1xuICB9LFxuICBhc3luYyBJblJhbmdlKHsgYmFzZSwgbGVmdCwgcmlnaHQsIGlzSW5jbHVzaXZlIH0sIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgY29uc3QgdmFsdWUgPSBhd2FpdCBleGVjdXRlKGJhc2UsIHNjb3BlKSwgbGVmdFZhbHVlID0gYXdhaXQgZXhlY3V0ZShsZWZ0LCBzY29wZSksIHJpZ2h0VmFsdWUgPSBhd2FpdCBleGVjdXRlKHJpZ2h0LCBzY29wZSksIGxlZnRDbXAgPSBwYXJ0aWFsQ29tcGFyZShhd2FpdCB2YWx1ZS5nZXQoKSwgYXdhaXQgbGVmdFZhbHVlLmdldCgpKTtcbiAgICBpZiAobGVmdENtcCA9PT0gbnVsbClcbiAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgIGNvbnN0IHJpZ2h0Q21wID0gcGFydGlhbENvbXBhcmUoYXdhaXQgdmFsdWUuZ2V0KCksIGF3YWl0IHJpZ2h0VmFsdWUuZ2V0KCkpO1xuICAgIHJldHVybiByaWdodENtcCA9PT0gbnVsbCA/IE5VTExfVkFMVUUgOiBpc0luY2x1c2l2ZSA/IGxlZnRDbXAgPj0gMCAmJiByaWdodENtcCA8PSAwID8gVFJVRV9WQUxVRSA6IEZBTFNFX1ZBTFVFIDogbGVmdENtcCA+PSAwICYmIHJpZ2h0Q21wIDwgMCA/IFRSVUVfVkFMVUUgOiBGQUxTRV9WQUxVRTtcbiAgfSxcbiAgYXN5bmMgRmlsdGVyKHsgYmFzZSwgZXhwciB9LCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIGNvbnN0IGJhc2VWYWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYmFzZSwgc2NvcGUpO1xuICAgIHJldHVybiBiYXNlVmFsdWUuaXNBcnJheSgpID8gbmV3IFN0cmVhbVZhbHVlKGFzeW5jIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBmb3IgYXdhaXQgKGNvbnN0IGVsZW0gb2YgYmFzZVZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG5ld1Njb3BlID0gc2NvcGUuY3JlYXRlTmVzdGVkKGVsZW0pLCBleHByVmFsdWUgPSBhd2FpdCBleGVjdXRlKGV4cHIsIG5ld1Njb3BlKTtcbiAgICAgICAgZXhwclZhbHVlLnR5cGUgPT09IFwiYm9vbGVhblwiICYmIGV4cHJWYWx1ZS5kYXRhID09PSAhMCAmJiAoeWllbGQgZWxlbSk7XG4gICAgICB9XG4gICAgfSkgOiBOVUxMX1ZBTFVFO1xuICB9LFxuICBhc3luYyBQcm9qZWN0aW9uKHsgYmFzZSwgZXhwciB9LCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIGNvbnN0IGJhc2VWYWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYmFzZSwgc2NvcGUpO1xuICAgIGlmIChiYXNlVmFsdWUudHlwZSAhPT0gXCJvYmplY3RcIilcbiAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgIGNvbnN0IG5ld1Njb3BlID0gc2NvcGUuY3JlYXRlTmVzdGVkKGJhc2VWYWx1ZSk7XG4gICAgcmV0dXJuIGV4ZWN1dGUoZXhwciwgbmV3U2NvcGUpO1xuICB9LFxuICBGdW5jQ2FsbCh7IGZ1bmMsIGFyZ3MgfSwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICByZXR1cm4gZnVuYyhhcmdzLCBzY29wZSwgZXhlY3V0ZSk7XG4gIH0sXG4gIGFzeW5jIFBpcGVGdW5jQ2FsbCh7IGZ1bmMsIGJhc2UsIGFyZ3MgfSwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICBjb25zdCBiYXNlVmFsdWUgPSBhd2FpdCBleGVjdXRlKGJhc2UsIHNjb3BlKTtcbiAgICByZXR1cm4gZnVuYyhiYXNlVmFsdWUsIGFyZ3MsIHNjb3BlLCBleGVjdXRlKTtcbiAgfSxcbiAgYXN5bmMgQWNjZXNzQXR0cmlidXRlKHsgYmFzZSwgbmFtZSB9LCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIGxldCB2YWx1ZSA9IHNjb3BlLnZhbHVlO1xuICAgIHJldHVybiBiYXNlICYmICh2YWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYmFzZSwgc2NvcGUpKSwgdmFsdWUudHlwZSA9PT0gXCJvYmplY3RcIiAmJiB2YWx1ZS5kYXRhLmhhc093blByb3BlcnR5KG5hbWUpID8gZnJvbUpTKHZhbHVlLmRhdGFbbmFtZV0pIDogTlVMTF9WQUxVRTtcbiAgfSxcbiAgYXN5bmMgQWNjZXNzRWxlbWVudCh7IGJhc2UsIGluZGV4IH0sIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgY29uc3QgYmFzZVZhbHVlID0gYXdhaXQgZXhlY3V0ZShiYXNlLCBzY29wZSk7XG4gICAgaWYgKCFiYXNlVmFsdWUuaXNBcnJheSgpKVxuICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IGJhc2VWYWx1ZS5nZXQoKSwgZmluYWxJbmRleCA9IGluZGV4IDwgMCA/IGluZGV4ICsgZGF0YS5sZW5ndGggOiBpbmRleDtcbiAgICByZXR1cm4gZnJvbUpTKGRhdGFbZmluYWxJbmRleF0pO1xuICB9LFxuICBhc3luYyBTbGljZSh7IGJhc2UsIGxlZnQsIHJpZ2h0LCBpc0luY2x1c2l2ZSB9LCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIGNvbnN0IGJhc2VWYWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYmFzZSwgc2NvcGUpO1xuICAgIGlmICghYmFzZVZhbHVlLmlzQXJyYXkoKSlcbiAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgIGNvbnN0IGFycmF5MiA9IGF3YWl0IGJhc2VWYWx1ZS5nZXQoKTtcbiAgICBsZXQgbGVmdElkeCA9IGxlZnQsIHJpZ2h0SWR4ID0gcmlnaHQ7XG4gICAgcmV0dXJuIGxlZnRJZHggPCAwICYmIChsZWZ0SWR4ID0gYXJyYXkyLmxlbmd0aCArIGxlZnRJZHgpLCByaWdodElkeCA8IDAgJiYgKHJpZ2h0SWR4ID0gYXJyYXkyLmxlbmd0aCArIHJpZ2h0SWR4KSwgaXNJbmNsdXNpdmUgJiYgcmlnaHRJZHgrKywgbGVmdElkeCA8IDAgJiYgKGxlZnRJZHggPSAwKSwgcmlnaHRJZHggPCAwICYmIChyaWdodElkeCA9IDApLCBmcm9tSlMoYXJyYXkyLnNsaWNlKGxlZnRJZHgsIHJpZ2h0SWR4KSk7XG4gIH0sXG4gIGFzeW5jIERlcmVmKHsgYmFzZSB9LCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgZXhlY3V0ZShiYXNlLCBzY29wZSk7XG4gICAgaWYgKCFzY29wZS5zb3VyY2UuaXNBcnJheSgpIHx8IHZhbHVlLnR5cGUgIT09IFwib2JqZWN0XCIpXG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICBjb25zdCBpZCA9IHZhbHVlLmRhdGEuX3JlZjtcbiAgICBpZiAodHlwZW9mIGlkICE9IFwic3RyaW5nXCIpXG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICBpZiAoc2NvcGUuY29udGV4dC5kZXJlZmVyZW5jZSlcbiAgICAgIHJldHVybiBmcm9tSlMoYXdhaXQgc2NvcGUuY29udGV4dC5kZXJlZmVyZW5jZSh7IF9yZWY6IGlkIH0pKTtcbiAgICBmb3IgYXdhaXQgKGNvbnN0IGRvYyBvZiBzY29wZS5zb3VyY2UpXG4gICAgICBpZiAoZG9jLnR5cGUgPT09IFwib2JqZWN0XCIgJiYgaWQgPT09IGRvYy5kYXRhLl9pZClcbiAgICAgICAgcmV0dXJuIGRvYztcbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgfSxcbiAgVmFsdWUoeyB2YWx1ZSB9KSB7XG4gICAgcmV0dXJuIGZyb21KUyh2YWx1ZSk7XG4gIH0sXG4gIEdyb3VwKHsgYmFzZSB9LCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIHJldHVybiBleGVjdXRlKGJhc2UsIHNjb3BlKTtcbiAgfSxcbiAgYXN5bmMgT2JqZWN0KHsgYXR0cmlidXRlcyB9LCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGZvciAoY29uc3QgYXR0ciBvZiBhdHRyaWJ1dGVzKSB7XG4gICAgICBjb25zdCBhdHRyVHlwZSA9IGF0dHIudHlwZTtcbiAgICAgIHN3aXRjaCAoYXR0ci50eXBlKSB7XG4gICAgICAgIGNhc2UgXCJPYmplY3RBdHRyaWJ1dGVWYWx1ZVwiOiB7XG4gICAgICAgICAgY29uc3QgdmFsdWUgPSBhd2FpdCBleGVjdXRlKGF0dHIudmFsdWUsIHNjb3BlKTtcbiAgICAgICAgICByZXN1bHRbYXR0ci5uYW1lXSA9IGF3YWl0IHZhbHVlLmdldCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJPYmplY3RDb25kaXRpb25hbFNwbGF0XCI6IHtcbiAgICAgICAgICBjb25zdCBjb25kID0gYXdhaXQgZXhlY3V0ZShhdHRyLmNvbmRpdGlvbiwgc2NvcGUpO1xuICAgICAgICAgIGlmIChjb25kLnR5cGUgIT09IFwiYm9vbGVhblwiIHx8IGNvbmQuZGF0YSA9PT0gITEpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYXR0ci52YWx1ZSwgc2NvcGUpO1xuICAgICAgICAgIHZhbHVlLnR5cGUgPT09IFwib2JqZWN0XCIgJiYgT2JqZWN0LmFzc2lnbihyZXN1bHQsIHZhbHVlLmRhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJPYmplY3RTcGxhdFwiOiB7XG4gICAgICAgICAgY29uc3QgdmFsdWUgPSBhd2FpdCBleGVjdXRlKGF0dHIudmFsdWUsIHNjb3BlKTtcbiAgICAgICAgICB2YWx1ZS50eXBlID09PSBcIm9iamVjdFwiICYmIE9iamVjdC5hc3NpZ24ocmVzdWx0LCB2YWx1ZS5kYXRhKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBub2RlIHR5cGU6ICR7YXR0clR5cGV9YCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmcm9tSlMocmVzdWx0KTtcbiAgfSxcbiAgQXJyYXkoeyBlbGVtZW50cyB9LCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIHJldHVybiBuZXcgU3RyZWFtVmFsdWUoYXN5bmMgZnVuY3Rpb24qICgpIHtcbiAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBlbGVtZW50cykge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IGV4ZWN1dGUoZWxlbWVudC52YWx1ZSwgc2NvcGUpO1xuICAgICAgICBpZiAoZWxlbWVudC5pc1NwbGF0KSB7XG4gICAgICAgICAgaWYgKHZhbHVlLmlzQXJyYXkoKSlcbiAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgdiBvZiB2YWx1ZSlcbiAgICAgICAgICAgICAgeWllbGQgdjtcbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgeWllbGQgdmFsdWU7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG4gIFR1cGxlKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcInR1cGxlcyBjYW4gbm90IGJlIGV2YWx1YXRlZFwiKTtcbiAgfSxcbiAgYXN5bmMgT3IoeyBsZWZ0LCByaWdodCB9LCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIGNvbnN0IGxlZnRWYWx1ZSA9IGF3YWl0IGV4ZWN1dGUobGVmdCwgc2NvcGUpLCByaWdodFZhbHVlID0gYXdhaXQgZXhlY3V0ZShyaWdodCwgc2NvcGUpO1xuICAgIHJldHVybiBsZWZ0VmFsdWUudHlwZSA9PT0gXCJib29sZWFuXCIgJiYgbGVmdFZhbHVlLmRhdGEgPT09ICEwIHx8IHJpZ2h0VmFsdWUudHlwZSA9PT0gXCJib29sZWFuXCIgJiYgcmlnaHRWYWx1ZS5kYXRhID09PSAhMCA/IFRSVUVfVkFMVUUgOiBsZWZ0VmFsdWUudHlwZSAhPT0gXCJib29sZWFuXCIgfHwgcmlnaHRWYWx1ZS50eXBlICE9PSBcImJvb2xlYW5cIiA/IE5VTExfVkFMVUUgOiBGQUxTRV9WQUxVRTtcbiAgfSxcbiAgYXN5bmMgQW5kKHsgbGVmdCwgcmlnaHQgfSwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICBjb25zdCBsZWZ0VmFsdWUgPSBhd2FpdCBleGVjdXRlKGxlZnQsIHNjb3BlKSwgcmlnaHRWYWx1ZSA9IGF3YWl0IGV4ZWN1dGUocmlnaHQsIHNjb3BlKTtcbiAgICByZXR1cm4gbGVmdFZhbHVlLnR5cGUgPT09IFwiYm9vbGVhblwiICYmIGxlZnRWYWx1ZS5kYXRhID09PSAhMSB8fCByaWdodFZhbHVlLnR5cGUgPT09IFwiYm9vbGVhblwiICYmIHJpZ2h0VmFsdWUuZGF0YSA9PT0gITEgPyBGQUxTRV9WQUxVRSA6IGxlZnRWYWx1ZS50eXBlICE9PSBcImJvb2xlYW5cIiB8fCByaWdodFZhbHVlLnR5cGUgIT09IFwiYm9vbGVhblwiID8gTlVMTF9WQUxVRSA6IFRSVUVfVkFMVUU7XG4gIH0sXG4gIGFzeW5jIE5vdCh7IGJhc2UgfSwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYmFzZSwgc2NvcGUpO1xuICAgIHJldHVybiB2YWx1ZS50eXBlICE9PSBcImJvb2xlYW5cIiA/IE5VTExfVkFMVUUgOiB2YWx1ZS5kYXRhID8gRkFMU0VfVkFMVUUgOiBUUlVFX1ZBTFVFO1xuICB9LFxuICBOZWcoeyBiYXNlIH0sIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgcmV0dXJuIHByb21pc2VsZXNzQXBwbHkoZXhlY3V0ZShiYXNlLCBzY29wZSksICh2YWx1ZSkgPT4gdmFsdWUudHlwZSAhPT0gXCJudW1iZXJcIiA/IE5VTExfVkFMVUUgOiBmcm9tTnVtYmVyKC12YWx1ZS5kYXRhKSk7XG4gIH0sXG4gIFBvcyh7IGJhc2UgfSwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICByZXR1cm4gcHJvbWlzZWxlc3NBcHBseShleGVjdXRlKGJhc2UsIHNjb3BlKSwgKHZhbHVlKSA9PiB2YWx1ZS50eXBlICE9PSBcIm51bWJlclwiID8gTlVMTF9WQUxVRSA6IGZyb21OdW1iZXIodmFsdWUuZGF0YSkpO1xuICB9LFxuICBBc2MoKSB7XG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIH0sXG4gIERlc2MoKSB7XG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIH0sXG4gIGFzeW5jIEFycmF5Q29lcmNlKHsgYmFzZSB9LCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgZXhlY3V0ZShiYXNlLCBzY29wZSk7XG4gICAgcmV0dXJuIHZhbHVlLmlzQXJyYXkoKSA/IHZhbHVlIDogTlVMTF9WQUxVRTtcbiAgfSxcbiAgYXN5bmMgTWFwKHsgYmFzZSwgZXhwciB9LCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgZXhlY3V0ZShiYXNlLCBzY29wZSk7XG4gICAgcmV0dXJuIHZhbHVlLmlzQXJyYXkoKSA/IG5ldyBTdHJlYW1WYWx1ZShhc3luYyBmdW5jdGlvbiogKCkge1xuICAgICAgZm9yIGF3YWl0IChjb25zdCBlbGVtIG9mIHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG5ld1Njb3BlID0gc2NvcGUuY3JlYXRlSGlkZGVuKGVsZW0pO1xuICAgICAgICB5aWVsZCBhd2FpdCBleGVjdXRlKGV4cHIsIG5ld1Njb3BlKTtcbiAgICAgIH1cbiAgICB9KSA6IE5VTExfVkFMVUU7XG4gIH0sXG4gIGFzeW5jIEZsYXRNYXAoeyBiYXNlLCBleHByIH0sIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgY29uc3QgdmFsdWUgPSBhd2FpdCBleGVjdXRlKGJhc2UsIHNjb3BlKTtcbiAgICByZXR1cm4gdmFsdWUuaXNBcnJheSgpID8gbmV3IFN0cmVhbVZhbHVlKGFzeW5jIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBmb3IgYXdhaXQgKGNvbnN0IGVsZW0gb2YgdmFsdWUpIHtcbiAgICAgICAgY29uc3QgbmV3U2NvcGUgPSBzY29wZS5jcmVhdGVIaWRkZW4oZWxlbSksIGlubmVyVmFsdWUgPSBhd2FpdCBleGVjdXRlKGV4cHIsIG5ld1Njb3BlKTtcbiAgICAgICAgaWYgKGlubmVyVmFsdWUuaXNBcnJheSgpKVxuICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgaW5uZXIgb2YgaW5uZXJWYWx1ZSlcbiAgICAgICAgICAgIHlpZWxkIGlubmVyO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgeWllbGQgaW5uZXJWYWx1ZTtcbiAgICAgIH1cbiAgICB9KSA6IE5VTExfVkFMVUU7XG4gIH1cbn07XG5mdW5jdGlvbiBldmFsdWF0ZVF1ZXJ5KHRyZWUsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCByb290ID0gZnJvbUpTKG9wdGlvbnMucm9vdCksIGRhdGFzZXQgPSBmcm9tSlMob3B0aW9ucy5kYXRhc2V0KSwgcGFyYW1zID0geyAuLi5vcHRpb25zLnBhcmFtcyB9LCBzY29wZSA9IG5ldyBTY29wZShcbiAgICBwYXJhbXMsXG4gICAgZGF0YXNldCxcbiAgICByb290LFxuICAgIHtcbiAgICAgIHRpbWVzdGFtcDogb3B0aW9ucy50aW1lc3RhbXAgfHwgLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCksXG4gICAgICBpZGVudGl0eTogb3B0aW9ucy5pZGVudGl0eSA9PT0gdm9pZCAwID8gXCJtZVwiIDogb3B0aW9ucy5pZGVudGl0eSxcbiAgICAgIHNhbml0eTogb3B0aW9ucy5zYW5pdHksXG4gICAgICBhZnRlcjogb3B0aW9ucy5hZnRlciA/IGZyb21KUyhvcHRpb25zLmFmdGVyKSA6IG51bGwsXG4gICAgICBiZWZvcmU6IG9wdGlvbnMuYmVmb3JlID8gZnJvbUpTKG9wdGlvbnMuYmVmb3JlKSA6IG51bGwsXG4gICAgICBkZXJlZmVyZW5jZTogb3B0aW9ucy5kZXJlZmVyZW5jZVxuICAgIH0sXG4gICAgbnVsbFxuICApO1xuICByZXR1cm4gZXZhbHVhdGUodHJlZSwgc2NvcGUpO1xufVxuZnVuY3Rpb24gY2FuQ29uc3RhbnRFdmFsdWF0ZShub2RlKSB7XG4gIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgY2FzZSBcIkdyb3VwXCI6XG4gICAgICByZXR1cm4gY2FuQ29uc3RhbnRFdmFsdWF0ZShub2RlLmJhc2UpO1xuICAgIGNhc2UgXCJWYWx1ZVwiOlxuICAgIGNhc2UgXCJQYXJhbWV0ZXJcIjpcbiAgICAgIHJldHVybiAhMDtcbiAgICBjYXNlIFwiUG9zXCI6XG4gICAgY2FzZSBcIk5lZ1wiOlxuICAgICAgcmV0dXJuIGNhbkNvbnN0YW50RXZhbHVhdGUobm9kZS5iYXNlKTtcbiAgICBjYXNlIFwiT3BDYWxsXCI6XG4gICAgICBzd2l0Y2ggKG5vZGUub3ApIHtcbiAgICAgICAgY2FzZSBcIitcIjpcbiAgICAgICAgY2FzZSBcIi1cIjpcbiAgICAgICAgY2FzZSBcIipcIjpcbiAgICAgICAgY2FzZSBcIi9cIjpcbiAgICAgICAgY2FzZSBcIiVcIjpcbiAgICAgICAgY2FzZSBcIioqXCI6XG4gICAgICAgICAgcmV0dXJuIGNhbkNvbnN0YW50RXZhbHVhdGUobm9kZS5sZWZ0KSAmJiBjYW5Db25zdGFudEV2YWx1YXRlKG5vZGUucmlnaHQpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgIH1cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuICExO1xuICB9XG59XG5jb25zdCBEVU1NWV9TQ09QRSA9IG5ldyBTY29wZShcbiAge30sXG4gIE5VTExfVkFMVUUsXG4gIE5VTExfVkFMVUUsXG4gIHsgdGltZXN0YW1wOiAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoMCksIGlkZW50aXR5OiBcIm1lXCIsIGJlZm9yZTogbnVsbCwgYWZ0ZXI6IG51bGwgfSxcbiAgbnVsbFxuKTtcbmZ1bmN0aW9uIHRyeUNvbnN0YW50RXZhbHVhdGUobm9kZSkge1xuICByZXR1cm4gY2FuQ29uc3RhbnRFdmFsdWF0ZShub2RlKSA/IGNvbnN0YW50RXZhbHVhdGUobm9kZSkgOiBudWxsO1xufVxuZnVuY3Rpb24gY29uc3RhbnRFdmFsdWF0ZShub2RlKSB7XG4gIGNvbnN0IHZhbHVlID0gZXZhbHVhdGUobm9kZSwgRFVNTVlfU0NPUEUsIGNvbnN0YW50RXZhbHVhdGUpO1xuICBpZiAoXCJ0aGVuXCIgaW4gdmFsdWUpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQlVHOiBjb25zdGFudCBldmFsdWF0ZSBzaG91bGQgbmV2ZXIgcmV0dXJuIGEgcHJvbWlzZVwiKTtcbiAgcmV0dXJuIHZhbHVlO1xufVxuYXN5bmMgZnVuY3Rpb24gcG9ydGFibGVUZXh0Q29udGVudCh2YWx1ZSkge1xuICBpZiAodmFsdWUudHlwZSA9PT0gXCJvYmplY3RcIilcbiAgICByZXR1cm4gYmxvY2tUZXh0KHZhbHVlLmRhdGEpO1xuICBpZiAodmFsdWUuaXNBcnJheSgpKSB7XG4gICAgY29uc3QgdGV4dHMgPSBhd2FpdCBhcnJheVRleHQodmFsdWUpO1xuICAgIGlmICh0ZXh0cy5sZW5ndGggPiAwKVxuICAgICAgcmV0dXJuIHRleHRzLmpvaW4oYFxuXG5gKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmFzeW5jIGZ1bmN0aW9uIGFycmF5VGV4dCh2YWx1ZSwgcmVzdWx0ID0gW10pIHtcbiAgZm9yIGF3YWl0IChjb25zdCBibG9jayBvZiB2YWx1ZSlcbiAgICBpZiAoYmxvY2sudHlwZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgY29uc3QgdGV4dCA9IGJsb2NrVGV4dChibG9jay5kYXRhKTtcbiAgICAgIHRleHQgIT09IG51bGwgJiYgcmVzdWx0LnB1c2godGV4dCk7XG4gICAgfSBlbHNlXG4gICAgICBibG9jay5pc0FycmF5KCkgJiYgYXdhaXQgYXJyYXlUZXh0KGJsb2NrLCByZXN1bHQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gYmxvY2tUZXh0KG9iaikge1xuICBpZiAodHlwZW9mIG9iai5fdHlwZSAhPSBcInN0cmluZ1wiKVxuICAgIHJldHVybiBudWxsO1xuICBjb25zdCBjaGlsZHJlbiA9IG9iai5jaGlsZHJlbjtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGNoaWxkcmVuKSlcbiAgICByZXR1cm4gbnVsbDtcbiAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gIGZvciAoY29uc3QgY2hpbGQgb2YgY2hpbGRyZW4pXG4gICAgY2hpbGQgJiYgdHlwZW9mIGNoaWxkID09IFwib2JqZWN0XCIgJiYgdHlwZW9mIGNoaWxkLl90eXBlID09IFwic3RyaW5nXCIgJiYgY2hpbGQuX3R5cGUgPT09IFwic3BhblwiICYmIHR5cGVvZiBjaGlsZC50ZXh0ID09IFwic3RyaW5nXCIgJiYgKHJlc3VsdCArPSBjaGlsZC50ZXh0KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmNvbnN0IEJNMjVrID0gMS4yO1xuYXN5bmMgZnVuY3Rpb24gZXZhbHVhdGVTY29yZShub2RlLCBzY29wZSwgZXhlY3V0ZSkge1xuICBpZiAobm9kZS50eXBlID09PSBcIk9wQ2FsbFwiICYmIG5vZGUub3AgPT09IFwibWF0Y2hcIilcbiAgICByZXR1cm4gZXZhbHVhdGVNYXRjaFNjb3JlKG5vZGUubGVmdCwgbm9kZS5yaWdodCwgc2NvcGUsIGV4ZWN1dGUpO1xuICBpZiAobm9kZS50eXBlID09PSBcIkZ1bmNDYWxsXCIgJiYgbm9kZS5uYW1lID09PSBcImJvb3N0XCIpIHtcbiAgICBjb25zdCBpbm5lclNjb3JlID0gYXdhaXQgZXZhbHVhdGVTY29yZShub2RlLmFyZ3NbMF0sIHNjb3BlLCBleGVjdXRlKSwgYm9vc3QgPSBhd2FpdCBleGVjdXRlKG5vZGUuYXJnc1sxXSwgc2NvcGUpO1xuICAgIHJldHVybiBib29zdC50eXBlID09PSBcIm51bWJlclwiICYmIGlubmVyU2NvcmUgPiAwID8gaW5uZXJTY29yZSArIGJvb3N0LmRhdGEgOiAwO1xuICB9XG4gIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgY2FzZSBcIk9yXCI6IHtcbiAgICAgIGNvbnN0IGxlZnRTY29yZSA9IGF3YWl0IGV2YWx1YXRlU2NvcmUobm9kZS5sZWZ0LCBzY29wZSwgZXhlY3V0ZSksIHJpZ2h0U2NvcmUgPSBhd2FpdCBldmFsdWF0ZVNjb3JlKG5vZGUucmlnaHQsIHNjb3BlLCBleGVjdXRlKTtcbiAgICAgIHJldHVybiBsZWZ0U2NvcmUgKyByaWdodFNjb3JlO1xuICAgIH1cbiAgICBjYXNlIFwiQW5kXCI6IHtcbiAgICAgIGNvbnN0IGxlZnRTY29yZSA9IGF3YWl0IGV2YWx1YXRlU2NvcmUobm9kZS5sZWZ0LCBzY29wZSwgZXhlY3V0ZSksIHJpZ2h0U2NvcmUgPSBhd2FpdCBldmFsdWF0ZVNjb3JlKG5vZGUucmlnaHQsIHNjb3BlLCBleGVjdXRlKTtcbiAgICAgIHJldHVybiBsZWZ0U2NvcmUgPT09IDAgfHwgcmlnaHRTY29yZSA9PT0gMCA/IDAgOiBsZWZ0U2NvcmUgKyByaWdodFNjb3JlO1xuICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICBjb25zdCByZXMgPSBhd2FpdCBleGVjdXRlKG5vZGUsIHNjb3BlKTtcbiAgICAgIHJldHVybiByZXMudHlwZSA9PT0gXCJib29sZWFuXCIgJiYgcmVzLmRhdGEgPT09ICEwID8gMSA6IDA7XG4gICAgfVxuICB9XG59XG5hc3luYyBmdW5jdGlvbiBldmFsdWF0ZU1hdGNoU2NvcmUobGVmdCwgcmlnaHQsIHNjb3BlLCBleGVjdXRlKSB7XG4gIGNvbnN0IHRleHQgPSBhd2FpdCBleGVjdXRlKGxlZnQsIHNjb3BlKSwgcGF0dGVybiA9IGF3YWl0IGV4ZWN1dGUocmlnaHQsIHNjb3BlKTtcbiAgbGV0IHRva2VucyA9IFtdLCB0ZXJtcyA9IFtdO1xuICBpZiAoYXdhaXQgZ2F0aGVyVGV4dCh0ZXh0LCAocGFydCkgPT4ge1xuICAgIHRva2VucyA9IHRva2Vucy5jb25jYXQobWF0Y2hUb2tlbml6ZShwYXJ0KSk7XG4gIH0pLCAhYXdhaXQgZ2F0aGVyVGV4dChwYXR0ZXJuLCAocGFydCkgPT4ge1xuICAgIHRlcm1zID0gdGVybXMuY29uY2F0KG1hdGNoUGF0dGVyblJlZ2V4KHBhcnQpKTtcbiAgfSkgfHwgdG9rZW5zLmxlbmd0aCA9PT0gMCB8fCB0ZXJtcy5sZW5ndGggPT09IDApXG4gICAgcmV0dXJuIDA7XG4gIGxldCBzY29yZSA9IDA7XG4gIGZvciAoY29uc3QgcmUgb2YgdGVybXMpIHtcbiAgICBjb25zdCBmcmVxID0gdG9rZW5zLnJlZHVjZSgoYywgdG9rZW4pID0+IGMgKyAocmUudGVzdCh0b2tlbikgPyAxIDogMCksIDApO1xuICAgIHNjb3JlICs9IGZyZXEgKiAoQk0yNWsgKyAxKSAvIChmcmVxICsgQk0yNWspO1xuICB9XG4gIHJldHVybiBzY29yZTtcbn1cbmZ1bmN0aW9uIGhhc1JlZmVyZW5jZSh2YWx1ZSwgcGF0aFNldCkge1xuICBzd2l0Y2ggKGdldFR5cGUodmFsdWUpKSB7XG4gICAgY2FzZSBcImFycmF5XCI6XG4gICAgICBmb3IgKGNvbnN0IHYgb2YgdmFsdWUpXG4gICAgICAgIGlmIChoYXNSZWZlcmVuY2UodiwgcGF0aFNldCkpXG4gICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgaWYgKHZhbHVlLl9yZWYpXG4gICAgICAgIHJldHVybiBwYXRoU2V0Lmhhcyh2YWx1ZS5fcmVmKTtcbiAgICAgIGZvciAoY29uc3QgdiBvZiBPYmplY3QudmFsdWVzKHZhbHVlKSlcbiAgICAgICAgaWYgKGhhc1JlZmVyZW5jZSh2LCBwYXRoU2V0KSlcbiAgICAgICAgICByZXR1cm4gITA7XG4gICAgICBicmVhaztcbiAgfVxuICByZXR1cm4gITE7XG59XG5mdW5jdGlvbiBjb3VudFVURjgoc3RyKSB7XG4gIGxldCBjb3VudDIgPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGNvZGUgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICBjb2RlID49IDU1Mjk2ICYmIGNvZGUgPD0gNTYzMTkgfHwgY291bnQyKys7XG4gIH1cbiAgcmV0dXJuIGNvdW50Mjtcbn1cbmNvbnN0IF9nbG9iYWwgPSB7fTtcbl9nbG9iYWwuYW55d2hlcmUgPSBhc3luYyBmdW5jdGlvbigpIHtcbiAgdGhyb3cgbmV3IEVycm9yKFwibm90IGltcGxlbWVudGVkXCIpO1xufTtcbl9nbG9iYWwuYW55d2hlcmUuYXJpdHkgPSAxO1xuX2dsb2JhbC5jb2FsZXNjZSA9IGFzeW5jIGZ1bmN0aW9uKGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gIGZvciAoY29uc3QgYXJnIG9mIGFyZ3MpIHtcbiAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYXJnLCBzY29wZSk7XG4gICAgaWYgKHZhbHVlLnR5cGUgIT09IFwibnVsbFwiKVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJldHVybiBOVUxMX1ZBTFVFO1xufTtcbl9nbG9iYWwuY291bnQgPSBhc3luYyBmdW5jdGlvbihhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICBjb25zdCBpbm5lciA9IGF3YWl0IGV4ZWN1dGUoYXJnc1swXSwgc2NvcGUpO1xuICBpZiAoIWlubmVyLmlzQXJyYXkoKSlcbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgbGV0IG51bSA9IDA7XG4gIGZvciBhd2FpdCAoY29uc3QgXyBvZiBpbm5lcilcbiAgICBudW0rKztcbiAgcmV0dXJuIGZyb21OdW1iZXIobnVtKTtcbn07XG5fZ2xvYmFsLmNvdW50LmFyaXR5ID0gMTtcbl9nbG9iYWwuZGF0ZVRpbWUgPSBhc3luYyBmdW5jdGlvbihhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICBjb25zdCB2YWwgPSBhd2FpdCBleGVjdXRlKGFyZ3NbMF0sIHNjb3BlKTtcbiAgcmV0dXJuIHZhbC50eXBlID09PSBcImRhdGV0aW1lXCIgPyB2YWwgOiB2YWwudHlwZSAhPT0gXCJzdHJpbmdcIiA/IE5VTExfVkFMVUUgOiBEYXRlVGltZS5wYXJzZVRvVmFsdWUodmFsLmRhdGEpO1xufTtcbl9nbG9iYWwuZGF0ZVRpbWUuYXJpdHkgPSAxO1xuX2dsb2JhbC5kZWZpbmVkID0gYXN5bmMgZnVuY3Rpb24oYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgcmV0dXJuIChhd2FpdCBleGVjdXRlKGFyZ3NbMF0sIHNjb3BlKSkudHlwZSA9PT0gXCJudWxsXCIgPyBGQUxTRV9WQUxVRSA6IFRSVUVfVkFMVUU7XG59O1xuX2dsb2JhbC5kZWZpbmVkLmFyaXR5ID0gMTtcbl9nbG9iYWwuaWRlbnRpdHkgPSBhc3luYyBmdW5jdGlvbihhcmdzLCBzY29wZSkge1xuICByZXR1cm4gZnJvbVN0cmluZyhzY29wZS5jb250ZXh0LmlkZW50aXR5KTtcbn07XG5fZ2xvYmFsLmlkZW50aXR5LmFyaXR5ID0gMDtcbl9nbG9iYWwubGVuZ3RoID0gYXN5bmMgZnVuY3Rpb24oYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgY29uc3QgaW5uZXIgPSBhd2FpdCBleGVjdXRlKGFyZ3NbMF0sIHNjb3BlKTtcbiAgaWYgKGlubmVyLnR5cGUgPT09IFwic3RyaW5nXCIpXG4gICAgcmV0dXJuIGZyb21OdW1iZXIoY291bnRVVEY4KGlubmVyLmRhdGEpKTtcbiAgaWYgKGlubmVyLmlzQXJyYXkoKSkge1xuICAgIGxldCBudW0gPSAwO1xuICAgIGZvciBhd2FpdCAoY29uc3QgXyBvZiBpbm5lcilcbiAgICAgIG51bSsrO1xuICAgIHJldHVybiBmcm9tTnVtYmVyKG51bSk7XG4gIH1cbiAgcmV0dXJuIE5VTExfVkFMVUU7XG59O1xuX2dsb2JhbC5sZW5ndGguYXJpdHkgPSAxO1xuX2dsb2JhbC5wYXRoID0gYXN5bmMgZnVuY3Rpb24oYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgY29uc3QgaW5uZXIgPSBhd2FpdCBleGVjdXRlKGFyZ3NbMF0sIHNjb3BlKTtcbiAgcmV0dXJuIGlubmVyLnR5cGUgIT09IFwic3RyaW5nXCIgPyBOVUxMX1ZBTFVFIDogZnJvbVBhdGgobmV3IFBhdGgoaW5uZXIuZGF0YSkpO1xufTtcbl9nbG9iYWwucGF0aC5hcml0eSA9IDE7XG5fZ2xvYmFsLnN0cmluZyA9IGFzeW5jIGZ1bmN0aW9uKGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gIGNvbnN0IHZhbHVlID0gYXdhaXQgZXhlY3V0ZShhcmdzWzBdLCBzY29wZSk7XG4gIHN3aXRjaCAodmFsdWUudHlwZSkge1xuICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICBjYXNlIFwiZGF0ZXRpbWVcIjpcbiAgICAgIHJldHVybiBmcm9tU3RyaW5nKGAke3ZhbHVlLmRhdGF9YCk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICB9XG59O1xuX2dsb2JhbC5zdHJpbmcuYXJpdHkgPSAxO1xuX2dsb2JhbC5yZWZlcmVuY2VzID0gYXN5bmMgZnVuY3Rpb24oYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgY29uc3QgcGF0aFNldCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGZvciAoY29uc3QgYXJnIG9mIGFyZ3MpIHtcbiAgICBjb25zdCBwYXRoMiA9IGF3YWl0IGV4ZWN1dGUoYXJnLCBzY29wZSk7XG4gICAgaWYgKHBhdGgyLnR5cGUgPT09IFwic3RyaW5nXCIpXG4gICAgICBwYXRoU2V0LmFkZChwYXRoMi5kYXRhKTtcbiAgICBlbHNlIGlmIChwYXRoMi5pc0FycmF5KCkpXG4gICAgICBmb3IgYXdhaXQgKGNvbnN0IGVsZW0gb2YgcGF0aDIpXG4gICAgICAgIGVsZW0udHlwZSA9PT0gXCJzdHJpbmdcIiAmJiBwYXRoU2V0LmFkZChlbGVtLmRhdGEpO1xuICB9XG4gIGlmIChwYXRoU2V0LnNpemUgPT09IDApXG4gICAgcmV0dXJuIEZBTFNFX1ZBTFVFO1xuICBjb25zdCBzY29wZVZhbHVlID0gYXdhaXQgc2NvcGUudmFsdWUuZ2V0KCk7XG4gIHJldHVybiBoYXNSZWZlcmVuY2Uoc2NvcGVWYWx1ZSwgcGF0aFNldCkgPyBUUlVFX1ZBTFVFIDogRkFMU0VfVkFMVUU7XG59O1xuX2dsb2JhbC5yZWZlcmVuY2VzLmFyaXR5ID0gKGMpID0+IGMgPj0gMTtcbl9nbG9iYWwucm91bmQgPSBhc3luYyBmdW5jdGlvbihhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICBjb25zdCB2YWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYXJnc1swXSwgc2NvcGUpO1xuICBpZiAodmFsdWUudHlwZSAhPT0gXCJudW1iZXJcIilcbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgY29uc3QgbnVtID0gdmFsdWUuZGF0YTtcbiAgbGV0IHByZWMgPSAwO1xuICBpZiAoYXJncy5sZW5ndGggPT09IDIpIHtcbiAgICBjb25zdCBwcmVjVmFsdWUgPSBhd2FpdCBleGVjdXRlKGFyZ3NbMV0sIHNjb3BlKTtcbiAgICBpZiAocHJlY1ZhbHVlLnR5cGUgIT09IFwibnVtYmVyXCIgfHwgcHJlY1ZhbHVlLmRhdGEgPCAwIHx8ICFOdW1iZXIuaXNJbnRlZ2VyKHByZWNWYWx1ZS5kYXRhKSlcbiAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgIHByZWMgPSBwcmVjVmFsdWUuZGF0YTtcbiAgfVxuICByZXR1cm4gcHJlYyA9PT0gMCA/IG51bSA8IDAgPyBmcm9tTnVtYmVyKC1NYXRoLnJvdW5kKC1udW0pKSA6IGZyb21OdW1iZXIoTWF0aC5yb3VuZChudW0pKSA6IGZyb21OdW1iZXIoTnVtYmVyKG51bS50b0ZpeGVkKHByZWMpKSk7XG59O1xuX2dsb2JhbC5yb3VuZC5hcml0eSA9IChjb3VudDIpID0+IGNvdW50MiA+PSAxICYmIGNvdW50MiA8PSAyO1xuX2dsb2JhbC5ub3cgPSBhc3luYyBmdW5jdGlvbihhcmdzLCBzY29wZSkge1xuICByZXR1cm4gZnJvbVN0cmluZyhzY29wZS5jb250ZXh0LnRpbWVzdGFtcC50b0lTT1N0cmluZygpKTtcbn07XG5fZ2xvYmFsLm5vdy5hcml0eSA9IDA7XG5fZ2xvYmFsLmJvb3N0ID0gYXN5bmMgZnVuY3Rpb24oKSB7XG4gIHRocm93IG5ldyBFcnJvcihcInVuZXhwZWN0ZWQgYm9vc3QgY2FsbFwiKTtcbn07XG5fZ2xvYmFsLmJvb3N0LmFyaXR5ID0gMjtcbmNvbnN0IHN0cmluZzIgPSB7fTtcbnN0cmluZzIubG93ZXIgPSBhc3luYyBmdW5jdGlvbihhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICBjb25zdCB2YWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYXJnc1swXSwgc2NvcGUpO1xuICByZXR1cm4gdmFsdWUudHlwZSAhPT0gXCJzdHJpbmdcIiA/IE5VTExfVkFMVUUgOiBmcm9tU3RyaW5nKHZhbHVlLmRhdGEudG9Mb3dlckNhc2UoKSk7XG59O1xuc3RyaW5nMi5sb3dlci5hcml0eSA9IDE7XG5zdHJpbmcyLnVwcGVyID0gYXN5bmMgZnVuY3Rpb24oYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgY29uc3QgdmFsdWUgPSBhd2FpdCBleGVjdXRlKGFyZ3NbMF0sIHNjb3BlKTtcbiAgcmV0dXJuIHZhbHVlLnR5cGUgIT09IFwic3RyaW5nXCIgPyBOVUxMX1ZBTFVFIDogZnJvbVN0cmluZyh2YWx1ZS5kYXRhLnRvVXBwZXJDYXNlKCkpO1xufTtcbnN0cmluZzIudXBwZXIuYXJpdHkgPSAxO1xuc3RyaW5nMi5zcGxpdCA9IGFzeW5jIGZ1bmN0aW9uKGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gIGNvbnN0IHN0ciA9IGF3YWl0IGV4ZWN1dGUoYXJnc1swXSwgc2NvcGUpO1xuICBpZiAoc3RyLnR5cGUgIT09IFwic3RyaW5nXCIpXG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIGNvbnN0IHNlcCA9IGF3YWl0IGV4ZWN1dGUoYXJnc1sxXSwgc2NvcGUpO1xuICByZXR1cm4gc2VwLnR5cGUgIT09IFwic3RyaW5nXCIgPyBOVUxMX1ZBTFVFIDogc3RyLmRhdGEubGVuZ3RoID09PSAwID8gZnJvbUpTKFtdKSA6IHNlcC5kYXRhLmxlbmd0aCA9PT0gMCA/IGZyb21KUyhBcnJheS5mcm9tKHN0ci5kYXRhKSkgOiBmcm9tSlMoc3RyLmRhdGEuc3BsaXQoc2VwLmRhdGEpKTtcbn07XG5zdHJpbmcyLnNwbGl0LmFyaXR5ID0gMjtcbl9nbG9iYWwubG93ZXIgPSBzdHJpbmcyLmxvd2VyO1xuX2dsb2JhbC51cHBlciA9IHN0cmluZzIudXBwZXI7XG5zdHJpbmcyLnN0YXJ0c1dpdGggPSBhc3luYyBmdW5jdGlvbihhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICBjb25zdCBzdHIgPSBhd2FpdCBleGVjdXRlKGFyZ3NbMF0sIHNjb3BlKTtcbiAgaWYgKHN0ci50eXBlICE9PSBcInN0cmluZ1wiKVxuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICBjb25zdCBwcmVmaXggPSBhd2FpdCBleGVjdXRlKGFyZ3NbMV0sIHNjb3BlKTtcbiAgcmV0dXJuIHByZWZpeC50eXBlICE9PSBcInN0cmluZ1wiID8gTlVMTF9WQUxVRSA6IHN0ci5kYXRhLnN0YXJ0c1dpdGgocHJlZml4LmRhdGEpID8gVFJVRV9WQUxVRSA6IEZBTFNFX1ZBTFVFO1xufTtcbnN0cmluZzIuc3RhcnRzV2l0aC5hcml0eSA9IDI7XG5jb25zdCBhcnJheSA9IHt9O1xuYXJyYXkuam9pbiA9IGFzeW5jIGZ1bmN0aW9uKGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gIGNvbnN0IGFyciA9IGF3YWl0IGV4ZWN1dGUoYXJnc1swXSwgc2NvcGUpO1xuICBpZiAoIWFyci5pc0FycmF5KCkpXG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIGNvbnN0IHNlcCA9IGF3YWl0IGV4ZWN1dGUoYXJnc1sxXSwgc2NvcGUpO1xuICBpZiAoc2VwLnR5cGUgIT09IFwic3RyaW5nXCIpXG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIGxldCBidWYgPSBcIlwiLCBuZWVkU2VwID0gITE7XG4gIGZvciBhd2FpdCAoY29uc3QgZWxlbSBvZiBhcnIpIHtcbiAgICBzd2l0Y2ggKG5lZWRTZXAgJiYgKGJ1ZiArPSBzZXAuZGF0YSksIGVsZW0udHlwZSkge1xuICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgIGNhc2UgXCJkYXRldGltZVwiOlxuICAgICAgICBidWYgKz0gYCR7ZWxlbS5kYXRhfWA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgfVxuICAgIG5lZWRTZXAgPSAhMDtcbiAgfVxuICByZXR1cm4gZnJvbUpTKGJ1Zik7XG59O1xuYXJyYXkuam9pbi5hcml0eSA9IDI7XG5hcnJheS5jb21wYWN0ID0gYXN5bmMgZnVuY3Rpb24oYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgY29uc3QgYXJyID0gYXdhaXQgZXhlY3V0ZShhcmdzWzBdLCBzY29wZSk7XG4gIHJldHVybiBhcnIuaXNBcnJheSgpID8gbmV3IFN0cmVhbVZhbHVlKGFzeW5jIGZ1bmN0aW9uKiAoKSB7XG4gICAgZm9yIGF3YWl0IChjb25zdCBlbGVtIG9mIGFycilcbiAgICAgIGVsZW0udHlwZSAhPT0gXCJudWxsXCIgJiYgKHlpZWxkIGVsZW0pO1xuICB9KSA6IE5VTExfVkFMVUU7XG59O1xuYXJyYXkuY29tcGFjdC5hcml0eSA9IDE7XG5hcnJheS51bmlxdWUgPSBhc3luYyBmdW5jdGlvbihhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICBjb25zdCB2YWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYXJnc1swXSwgc2NvcGUpO1xuICByZXR1cm4gdmFsdWUuaXNBcnJheSgpID8gbmV3IFN0cmVhbVZhbHVlKGFzeW5jIGZ1bmN0aW9uKiAoKSB7XG4gICAgY29uc3QgYWRkZWQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIGZvciBhd2FpdCAoY29uc3QgaXRlciBvZiB2YWx1ZSlcbiAgICAgIHN3aXRjaCAoaXRlci50eXBlKSB7XG4gICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgICBjYXNlIFwiZGF0ZXRpbWVcIjpcbiAgICAgICAgICBhZGRlZC5oYXMoaXRlci5kYXRhKSB8fCAoYWRkZWQuYWRkKGl0ZXIuZGF0YSksIHlpZWxkIGl0ZXIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHlpZWxkIGl0ZXI7XG4gICAgICB9XG4gIH0pIDogTlVMTF9WQUxVRTtcbn07XG5hcnJheS51bmlxdWUuYXJpdHkgPSAxO1xuY29uc3QgcHQgPSB7fTtcbnB0LnRleHQgPSBhc3luYyBmdW5jdGlvbihhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICBjb25zdCB2YWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYXJnc1swXSwgc2NvcGUpLCB0ZXh0ID0gYXdhaXQgcG9ydGFibGVUZXh0Q29udGVudCh2YWx1ZSk7XG4gIHJldHVybiB0ZXh0ID09PSBudWxsID8gTlVMTF9WQUxVRSA6IGZyb21TdHJpbmcodGV4dCk7XG59O1xucHQudGV4dC5hcml0eSA9IDE7XG5jb25zdCBzYW5pdHkgPSB7fTtcbnNhbml0eS5wcm9qZWN0SWQgPSBhc3luYyBmdW5jdGlvbihhcmdzLCBzY29wZSkge1xuICByZXR1cm4gc2NvcGUuY29udGV4dC5zYW5pdHkgPyBmcm9tU3RyaW5nKHNjb3BlLmNvbnRleHQuc2FuaXR5LnByb2plY3RJZCkgOiBOVUxMX1ZBTFVFO1xufTtcbnNhbml0eS5kYXRhc2V0ID0gYXN5bmMgZnVuY3Rpb24oYXJncywgc2NvcGUpIHtcbiAgcmV0dXJuIHNjb3BlLmNvbnRleHQuc2FuaXR5ID8gZnJvbVN0cmluZyhzY29wZS5jb250ZXh0LnNhbml0eS5kYXRhc2V0KSA6IE5VTExfVkFMVUU7XG59O1xuY29uc3QgcGlwZUZ1bmN0aW9ucyA9IHt9O1xucGlwZUZ1bmN0aW9ucy5vcmRlciA9IGFzeW5jIGZ1bmN0aW9uKGJhc2UsIGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gIGlmIChhd2FpdCAhMCwgIWJhc2UuaXNBcnJheSgpKVxuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICBjb25zdCBtYXBwZXJzID0gW10sIGRpcmVjdGlvbnMgPSBbXTtcbiAgbGV0IG4gPSAwO1xuICBmb3IgKGxldCBtYXBwZXIgb2YgYXJncykge1xuICAgIGxldCBkaXJlY3Rpb24gPSBcImFzY1wiO1xuICAgIG1hcHBlci50eXBlID09PSBcIkRlc2NcIiA/IChkaXJlY3Rpb24gPSBcImRlc2NcIiwgbWFwcGVyID0gbWFwcGVyLmJhc2UpIDogbWFwcGVyLnR5cGUgPT09IFwiQXNjXCIgJiYgKG1hcHBlciA9IG1hcHBlci5iYXNlKSwgbWFwcGVycy5wdXNoKG1hcHBlciksIGRpcmVjdGlvbnMucHVzaChkaXJlY3Rpb24pLCBuKys7XG4gIH1cbiAgY29uc3QgYXV4ID0gW107XG4gIGxldCBpZHggPSAwO1xuICBmb3IgYXdhaXQgKGNvbnN0IHZhbHVlIG9mIGJhc2UpIHtcbiAgICBjb25zdCBuZXdTY29wZSA9IHNjb3BlLmNyZWF0ZU5lc3RlZCh2YWx1ZSksIHR1cGxlID0gW2F3YWl0IHZhbHVlLmdldCgpLCBpZHhdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBleGVjdXRlKG1hcHBlcnNbaV0sIG5ld1Njb3BlKTtcbiAgICAgIHR1cGxlLnB1c2goYXdhaXQgcmVzdWx0LmdldCgpKTtcbiAgICB9XG4gICAgYXV4LnB1c2godHVwbGUpLCBpZHgrKztcbiAgfVxuICByZXR1cm4gYXV4LnNvcnQoKGFUdXBsZSwgYlR1cGxlKSA9PiB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgIGxldCBjID0gdG90YWxDb21wYXJlKGFUdXBsZVtpICsgMl0sIGJUdXBsZVtpICsgMl0pO1xuICAgICAgaWYgKGRpcmVjdGlvbnNbaV0gPT09IFwiZGVzY1wiICYmIChjID0gLWMpLCBjICE9PSAwKVxuICAgICAgICByZXR1cm4gYztcbiAgICB9XG4gICAgcmV0dXJuIGFUdXBsZVsxXSAtIGJUdXBsZVsxXTtcbiAgfSksIGZyb21KUyhhdXgubWFwKCh2KSA9PiB2WzBdKSk7XG59O1xucGlwZUZ1bmN0aW9ucy5vcmRlci5hcml0eSA9IChjb3VudDIpID0+IGNvdW50MiA+PSAxO1xucGlwZUZ1bmN0aW9ucy5zY29yZSA9IGFzeW5jIGZ1bmN0aW9uKGJhc2UsIGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gIGlmICghYmFzZS5pc0FycmF5KCkpXG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIGNvbnN0IHVua25vd24gPSBbXSwgc2NvcmVkID0gW107XG4gIGZvciBhd2FpdCAoY29uc3QgdmFsdWUgb2YgYmFzZSkge1xuICAgIGlmICh2YWx1ZS50eXBlICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICB1bmtub3duLnB1c2goYXdhaXQgdmFsdWUuZ2V0KCkpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IG5ld1Njb3BlID0gc2NvcGUuY3JlYXRlTmVzdGVkKHZhbHVlKTtcbiAgICBsZXQgdmFsdWVTY29yZSA9IHR5cGVvZiB2YWx1ZS5kYXRhLl9zY29yZSA9PSBcIm51bWJlclwiID8gdmFsdWUuZGF0YS5fc2NvcmUgOiAwO1xuICAgIGZvciAoY29uc3QgYXJnIG9mIGFyZ3MpXG4gICAgICB2YWx1ZVNjb3JlICs9IGF3YWl0IGV2YWx1YXRlU2NvcmUoYXJnLCBuZXdTY29wZSwgZXhlY3V0ZSk7XG4gICAgY29uc3QgbmV3T2JqZWN0ID0gT2JqZWN0LmFzc2lnbih7fSwgdmFsdWUuZGF0YSwgeyBfc2NvcmU6IHZhbHVlU2NvcmUgfSk7XG4gICAgc2NvcmVkLnB1c2gobmV3T2JqZWN0KTtcbiAgfVxuICByZXR1cm4gc2NvcmVkLnNvcnQoKGEsIGIpID0+IGIuX3Njb3JlIC0gYS5fc2NvcmUpLCBmcm9tSlMoc2NvcmVkKTtcbn07XG5waXBlRnVuY3Rpb25zLnNjb3JlLmFyaXR5ID0gKGNvdW50MikgPT4gY291bnQyID49IDE7XG5jb25zdCBkZWx0YSA9IHt9O1xuZGVsdGEub3BlcmF0aW9uID0gYXN5bmMgZnVuY3Rpb24oYXJncywgc2NvcGUpIHtcbiAgY29uc3QgaGFzQmVmb3JlID0gc2NvcGUuY29udGV4dC5iZWZvcmUgIT09IG51bGwsIGhhc0FmdGVyID0gc2NvcGUuY29udGV4dC5hZnRlciAhPT0gbnVsbDtcbiAgcmV0dXJuIGhhc0JlZm9yZSAmJiBoYXNBZnRlciA/IGZyb21TdHJpbmcoXCJ1cGRhdGVcIikgOiBoYXNBZnRlciA/IGZyb21TdHJpbmcoXCJjcmVhdGVcIikgOiBoYXNCZWZvcmUgPyBmcm9tU3RyaW5nKFwiZGVsZXRlXCIpIDogTlVMTF9WQUxVRTtcbn07XG5kZWx0YS5jaGFuZ2VkQW55ID0gKCkgPT4ge1xuICB0aHJvdyBuZXcgRXJyb3IoXCJub3QgaW1wbGVtZW50ZWRcIik7XG59O1xuZGVsdGEuY2hhbmdlZEFueS5hcml0eSA9IDE7XG5kZWx0YS5jaGFuZ2VkQW55Lm1vZGUgPSBcImRlbHRhXCI7XG5kZWx0YS5jaGFuZ2VkT25seSA9ICgpID0+IHtcbiAgdGhyb3cgbmV3IEVycm9yKFwibm90IGltcGxlbWVudGVkXCIpO1xufTtcbmRlbHRhLmNoYW5nZWRPbmx5LmFyaXR5ID0gMTtcbmRlbHRhLmNoYW5nZWRPbmx5Lm1vZGUgPSBcImRlbHRhXCI7XG5jb25zdCBkaWZmID0ge307XG5kaWZmLmNoYW5nZWRBbnkgPSAoKSA9PiB7XG4gIHRocm93IG5ldyBFcnJvcihcIm5vdCBpbXBsZW1lbnRlZFwiKTtcbn07XG5kaWZmLmNoYW5nZWRBbnkuYXJpdHkgPSAzO1xuZGlmZi5jaGFuZ2VkT25seSA9ICgpID0+IHtcbiAgdGhyb3cgbmV3IEVycm9yKFwibm90IGltcGxlbWVudGVkXCIpO1xufTtcbmRpZmYuY2hhbmdlZE9ubHkuYXJpdHkgPSAzO1xuY29uc3QgbWF0aCA9IHt9O1xubWF0aC5taW4gPSBhc3luYyBmdW5jdGlvbihhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICBjb25zdCBhcnIgPSBhd2FpdCBleGVjdXRlKGFyZ3NbMF0sIHNjb3BlKTtcbiAgaWYgKCFhcnIuaXNBcnJheSgpKVxuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICBsZXQgbjtcbiAgZm9yIGF3YWl0IChjb25zdCBlbGVtIG9mIGFycilcbiAgICBpZiAoZWxlbS50eXBlICE9PSBcIm51bGxcIikge1xuICAgICAgaWYgKGVsZW0udHlwZSAhPT0gXCJudW1iZXJcIilcbiAgICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgICAobiA9PT0gdm9pZCAwIHx8IGVsZW0uZGF0YSA8IG4pICYmIChuID0gZWxlbS5kYXRhKTtcbiAgICB9XG4gIHJldHVybiBmcm9tSlMobik7XG59O1xubWF0aC5taW4uYXJpdHkgPSAxO1xubWF0aC5tYXggPSBhc3luYyBmdW5jdGlvbihhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICBjb25zdCBhcnIgPSBhd2FpdCBleGVjdXRlKGFyZ3NbMF0sIHNjb3BlKTtcbiAgaWYgKCFhcnIuaXNBcnJheSgpKVxuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICBsZXQgbjtcbiAgZm9yIGF3YWl0IChjb25zdCBlbGVtIG9mIGFycilcbiAgICBpZiAoZWxlbS50eXBlICE9PSBcIm51bGxcIikge1xuICAgICAgaWYgKGVsZW0udHlwZSAhPT0gXCJudW1iZXJcIilcbiAgICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgICAobiA9PT0gdm9pZCAwIHx8IGVsZW0uZGF0YSA+IG4pICYmIChuID0gZWxlbS5kYXRhKTtcbiAgICB9XG4gIHJldHVybiBmcm9tSlMobik7XG59O1xubWF0aC5tYXguYXJpdHkgPSAxO1xubWF0aC5zdW0gPSBhc3luYyBmdW5jdGlvbihhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICBjb25zdCBhcnIgPSBhd2FpdCBleGVjdXRlKGFyZ3NbMF0sIHNjb3BlKTtcbiAgaWYgKCFhcnIuaXNBcnJheSgpKVxuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICBsZXQgbiA9IDA7XG4gIGZvciBhd2FpdCAoY29uc3QgZWxlbSBvZiBhcnIpXG4gICAgaWYgKGVsZW0udHlwZSAhPT0gXCJudWxsXCIpIHtcbiAgICAgIGlmIChlbGVtLnR5cGUgIT09IFwibnVtYmVyXCIpXG4gICAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgICAgbiArPSBlbGVtLmRhdGE7XG4gICAgfVxuICByZXR1cm4gZnJvbUpTKG4pO1xufTtcbm1hdGguc3VtLmFyaXR5ID0gMTtcbm1hdGguYXZnID0gYXN5bmMgZnVuY3Rpb24oYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgY29uc3QgYXJyID0gYXdhaXQgZXhlY3V0ZShhcmdzWzBdLCBzY29wZSk7XG4gIGlmICghYXJyLmlzQXJyYXkoKSlcbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgbGV0IG4gPSAwLCBjID0gMDtcbiAgZm9yIGF3YWl0IChjb25zdCBlbGVtIG9mIGFycilcbiAgICBpZiAoZWxlbS50eXBlICE9PSBcIm51bGxcIikge1xuICAgICAgaWYgKGVsZW0udHlwZSAhPT0gXCJudW1iZXJcIilcbiAgICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgICBuICs9IGVsZW0uZGF0YSwgYysrO1xuICAgIH1cbiAgcmV0dXJuIGMgPT09IDAgPyBOVUxMX1ZBTFVFIDogZnJvbUpTKG4gLyBjKTtcbn07XG5tYXRoLmF2Zy5hcml0eSA9IDE7XG5jb25zdCBkYXRlVGltZTIgPSB7fTtcbmRhdGVUaW1lMi5ub3cgPSBhc3luYyBmdW5jdGlvbihhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICByZXR1cm4gZnJvbURhdGVUaW1lKG5ldyBEYXRlVGltZShzY29wZS5jb250ZXh0LnRpbWVzdGFtcCkpO1xufTtcbmRhdGVUaW1lMi5ub3cuYXJpdHkgPSAwO1xuY29uc3QgbmFtZXNwYWNlcyA9IHtcbiAgZ2xvYmFsOiBfZ2xvYmFsLFxuICBzdHJpbmc6IHN0cmluZzIsXG4gIGFycmF5LFxuICBwdCxcbiAgZGVsdGEsXG4gIGRpZmYsXG4gIHNhbml0eSxcbiAgbWF0aCxcbiAgZGF0ZVRpbWU6IGRhdGVUaW1lMlxufTtcbnZhciBfX2RlZlByb3AkMSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSwgX19kZWZOb3JtYWxQcm9wJDEgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wJDEob2JqLCBrZXksIHsgZW51bWVyYWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAsIHdyaXRhYmxlOiAhMCwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlLCBfX3B1YmxpY0ZpZWxkJDEgPSAob2JqLCBrZXksIHZhbHVlKSA9PiAoX19kZWZOb3JtYWxQcm9wJDEob2JqLCB0eXBlb2Yga2V5ICE9IFwic3ltYm9sXCIgPyBrZXkgKyBcIlwiIDoga2V5LCB2YWx1ZSksIHZhbHVlKTtcbmNsYXNzIE1hcmtQcm9jZXNzb3Ige1xuICBjb25zdHJ1Y3RvcihzdHJpbmcsIG1hcmtzLCBwYXJzZU9wdGlvbnMpIHtcbiAgICBfX3B1YmxpY0ZpZWxkJDEodGhpcywgXCJzdHJpbmdcIiksIF9fcHVibGljRmllbGQkMSh0aGlzLCBcIm1hcmtzXCIpLCBfX3B1YmxpY0ZpZWxkJDEodGhpcywgXCJpbmRleFwiKSwgX19wdWJsaWNGaWVsZCQxKHRoaXMsIFwicGFyc2VPcHRpb25zXCIpLCBfX3B1YmxpY0ZpZWxkJDEodGhpcywgXCJhbGxvd0Jvb3N0XCIsICExKSwgdGhpcy5zdHJpbmcgPSBzdHJpbmcsIHRoaXMubWFya3MgPSBtYXJrcywgdGhpcy5pbmRleCA9IDAsIHRoaXMucGFyc2VPcHRpb25zID0gcGFyc2VPcHRpb25zO1xuICB9XG4gIGhhc01hcmsocG9zID0gMCkge1xuICAgIHJldHVybiB0aGlzLmluZGV4ICsgcG9zIDwgdGhpcy5tYXJrcy5sZW5ndGg7XG4gIH1cbiAgZ2V0TWFyayhwb3MgPSAwKSB7XG4gICAgcmV0dXJuIHRoaXMubWFya3NbdGhpcy5pbmRleCArIHBvc107XG4gIH1cbiAgc2hpZnQoKSB7XG4gICAgdGhpcy5pbmRleCArPSAxO1xuICB9XG4gIHByb2Nlc3ModmlzaXRvcikge1xuICAgIGNvbnN0IG1hcmsgPSB0aGlzLm1hcmtzW3RoaXMuaW5kZXhdO1xuICAgIHRoaXMuc2hpZnQoKTtcbiAgICBjb25zdCBmdW5jID0gdmlzaXRvclttYXJrLm5hbWVdO1xuICAgIGlmICghZnVuYylcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBoYW5kbGVyOiAke21hcmsubmFtZX1gKTtcbiAgICByZXR1cm4gZnVuYy5jYWxsKHZpc2l0b3IsIHRoaXMsIG1hcmspO1xuICB9XG4gIHByb2Nlc3NTdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2hpZnQoKSwgdGhpcy5wcm9jZXNzU3RyaW5nRW5kKCk7XG4gIH1cbiAgcHJvY2Vzc1N0cmluZ0VuZCgpIHtcbiAgICBjb25zdCBwcmV2ID0gdGhpcy5tYXJrc1t0aGlzLmluZGV4IC0gMV0sIGN1cnIgPSB0aGlzLm1hcmtzW3RoaXMuaW5kZXhdO1xuICAgIHJldHVybiB0aGlzLnNoaWZ0KCksIHRoaXMuc3RyaW5nLnNsaWNlKHByZXYucG9zaXRpb24sIGN1cnIucG9zaXRpb24pO1xuICB9XG4gIHNsaWNlKGxlbikge1xuICAgIGNvbnN0IHBvcyA9IHRoaXMubWFya3NbdGhpcy5pbmRleF0ucG9zaXRpb247XG4gICAgcmV0dXJuIHRoaXMuc3RyaW5nLnNsaWNlKHBvcywgcG9zICsgbGVuKTtcbiAgfVxufVxuY29uc3QgV1MgPSAvXihbXFx0XFxuXFx2XFxmXFxyIFxcdTAwODVcXHUwMEEwXXwoXFwvXFwvW15cXG5dKlxcbikpKy8sIE5VTSA9IC9eXFxkKy8sIElERU5UID0gL15bYS16QS1aX11bYS16QS1aXzAtOV0qLztcbmZ1bmN0aW9uIHBhcnNlJDEoc3RyKSB7XG4gIGxldCBwb3MgPSAwO1xuICBwb3MgPSBza2lwV1Moc3RyLCBwb3MpO1xuICBsZXQgcmVzdWx0ID0gcGFyc2VFeHByKHN0ciwgcG9zLCAwKTtcbiAgcmV0dXJuIHJlc3VsdC50eXBlID09PSBcImVycm9yXCIgPyByZXN1bHQgOiAocG9zID0gc2tpcFdTKHN0ciwgcmVzdWx0LnBvc2l0aW9uKSwgcG9zICE9PSBzdHIubGVuZ3RoID8gKHJlc3VsdC5mYWlsUG9zaXRpb24gJiYgKHBvcyA9IHJlc3VsdC5mYWlsUG9zaXRpb24gLSAxKSwgeyB0eXBlOiBcImVycm9yXCIsIHBvc2l0aW9uOiBwb3MgfSkgOiAoZGVsZXRlIHJlc3VsdC5wb3NpdGlvbiwgZGVsZXRlIHJlc3VsdC5mYWlsUG9zaXRpb24sIHJlc3VsdCkpO1xufVxuZnVuY3Rpb24gcGFyc2VFeHByKHN0ciwgcG9zLCBsZXZlbCkge1xuICBsZXQgc3RhcnRQb3MgPSBwb3MsIHRva2VuID0gc3RyW3Bvc10sIG1hcmtzO1xuICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgY2FzZSBcIitcIjoge1xuICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIHBvcyArIDEpLCAxMCk7XG4gICAgICBpZiAocmhzLnR5cGUgPT09IFwiZXJyb3JcIilcbiAgICAgICAgcmV0dXJuIHJocztcbiAgICAgIG1hcmtzID0gW3sgbmFtZTogXCJwb3NcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH1dLmNvbmNhdChyaHMubWFya3MpLCBwb3MgPSByaHMucG9zaXRpb247XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcIi1cIjoge1xuICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIHBvcyArIDEpLCA4KTtcbiAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKVxuICAgICAgICByZXR1cm4gcmhzO1xuICAgICAgbWFya3MgPSBbeyBuYW1lOiBcIm5lZ1wiLCBwb3NpdGlvbjogc3RhcnRQb3MgfV0uY29uY2F0KHJocy5tYXJrcyksIHBvcyA9IHJocy5wb3NpdGlvbjtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwiKFwiOiB7XG4gICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgcG9zICsgMSksIDApO1xuICAgICAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpXG4gICAgICAgIHJldHVybiByaHM7XG4gICAgICBzd2l0Y2ggKHBvcyA9IHNraXBXUyhzdHIsIHJocy5wb3NpdGlvbiksIHN0cltwb3NdKSB7XG4gICAgICAgIGNhc2UgXCIsXCI6IHtcbiAgICAgICAgICBmb3IgKG1hcmtzID0gW3sgbmFtZTogXCJ0dXBsZVwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfV0uY29uY2F0KHJocy5tYXJrcyksIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDEpOyA7ICkge1xuICAgICAgICAgICAgaWYgKHJocyA9IHBhcnNlRXhwcihzdHIsIHBvcywgMCksIHJocy50eXBlID09PSBcImVycm9yXCIpXG4gICAgICAgICAgICAgIHJldHVybiByaHM7XG4gICAgICAgICAgICBpZiAocG9zID0gc2tpcFdTKHN0ciwgcmhzLnBvc2l0aW9uKSwgc3RyW3Bvc10gIT09IFwiLFwiKVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3RyW3Bvc10gIT09IFwiKVwiKVxuICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJlcnJvclwiLCBwb3NpdGlvbjogcG9zIH07XG4gICAgICAgICAgcG9zKyssIG1hcmtzLnB1c2goeyBuYW1lOiBcInR1cGxlX2VuZFwiLCBwb3NpdGlvbjogcG9zIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCIpXCI6IHtcbiAgICAgICAgICBwb3MrKywgbWFya3MgPSBbeyBuYW1lOiBcImdyb3VwXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9XS5jb25jYXQocmhzLm1hcmtzKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiB7IHR5cGU6IFwiZXJyb3JcIiwgcG9zaXRpb246IHBvcyB9O1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCIhXCI6IHtcbiAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBwb3MgKyAxKSwgMTApO1xuICAgICAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpXG4gICAgICAgIHJldHVybiByaHM7XG4gICAgICBtYXJrcyA9IFt7IG5hbWU6IFwibm90XCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9XS5jb25jYXQocmhzLm1hcmtzKSwgcG9zID0gcmhzLnBvc2l0aW9uO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJ7XCI6IHtcbiAgICAgIGxldCByZXN1bHQgPSBwYXJzZU9iamVjdChzdHIsIHBvcyk7XG4gICAgICBpZiAocmVzdWx0LnR5cGUgPT09IFwiZXJyb3JcIilcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIG1hcmtzID0gcmVzdWx0Lm1hcmtzLCBwb3MgPSByZXN1bHQucG9zaXRpb247XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcIltcIjpcbiAgICAgIGlmIChtYXJrcyA9IFt7IG5hbWU6IFwiYXJyYXlcIiwgcG9zaXRpb246IHBvcyB9XSwgcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMSksIHN0cltwb3NdICE9PSBcIl1cIilcbiAgICAgICAgZm9yICg7IDsgKSB7XG4gICAgICAgICAgc3RyLnNsaWNlKHBvcywgcG9zICsgMykgPT09IFwiLi4uXCIgJiYgKG1hcmtzLnB1c2goeyBuYW1lOiBcImFycmF5X3NwbGF0XCIsIHBvc2l0aW9uOiBwb3MgfSksIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDMpKTtcbiAgICAgICAgICBsZXQgcmVzID0gcGFyc2VFeHByKHN0ciwgcG9zLCAwKTtcbiAgICAgICAgICBpZiAocmVzLnR5cGUgPT09IFwiZXJyb3JcIilcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgaWYgKG1hcmtzID0gbWFya3MuY29uY2F0KHJlcy5tYXJrcyksIHBvcyA9IHJlcy5wb3NpdGlvbiwgcG9zID0gc2tpcFdTKHN0ciwgcG9zKSwgc3RyW3Bvc10gIT09IFwiLFwiIHx8IChwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAxKSwgc3RyW3Bvc10gPT09IFwiXVwiKSlcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBpZiAoc3RyW3Bvc10gPT09IFwiXVwiKVxuICAgICAgICBwb3MrKywgbWFya3MucHVzaCh7IG5hbWU6IFwiYXJyYXlfZW5kXCIsIHBvc2l0aW9uOiBwb3MgfSk7XG4gICAgICBlbHNlXG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwiZXJyb3JcIiwgcG9zaXRpb246IHBvcyB9O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIidcIjpcbiAgICBjYXNlICdcIic6IHtcbiAgICAgIGxldCByZXN1bHQgPSBwYXJzZVN0cmluZyhzdHIsIHBvcyk7XG4gICAgICBpZiAocmVzdWx0LnR5cGUgPT09IFwiZXJyb3JcIilcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIG1hcmtzID0gcmVzdWx0Lm1hcmtzLCBwb3MgPSByZXN1bHQucG9zaXRpb247XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcIl5cIjoge1xuICAgICAgZm9yIChwb3MrKywgbWFya3MgPSBbXTsgc3RyW3Bvc10gPT09IFwiLlwiICYmIHN0cltwb3MgKyAxXSA9PT0gXCJeXCI7IClcbiAgICAgICAgbWFya3MucHVzaCh7IG5hbWU6IFwiZGJscGFyZW50XCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KSwgcG9zICs9IDI7XG4gICAgICBtYXJrcy5wdXNoKHsgbmFtZTogXCJwYXJlbnRcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJAXCI6XG4gICAgICBtYXJrcyA9IFt7IG5hbWU6IFwidGhpc1wiLCBwb3NpdGlvbjogc3RhcnRQb3MgfV0sIHBvcysrO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIipcIjpcbiAgICAgIG1hcmtzID0gW3sgbmFtZTogXCJldmVyeXRoaW5nXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9XSwgcG9zKys7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiJFwiOiB7XG4gICAgICBsZXQgaWRlbnRMZW4gPSBwYXJzZVJlZ2V4KHN0ciwgcG9zICsgMSwgSURFTlQpO1xuICAgICAgaWRlbnRMZW4gJiYgKHBvcyArPSAxICsgaWRlbnRMZW4sIG1hcmtzID0gW1xuICAgICAgICB7IG5hbWU6IFwicGFyYW1cIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0sXG4gICAgICAgIHsgbmFtZTogXCJpZGVudFwiLCBwb3NpdGlvbjogc3RhcnRQb3MgKyAxIH0sXG4gICAgICAgIHsgbmFtZTogXCJpZGVudF9lbmRcIiwgcG9zaXRpb246IHBvcyB9XG4gICAgICBdKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICBsZXQgbnVtTGVuID0gcGFyc2VSZWdleChzdHIsIHBvcywgTlVNKTtcbiAgICAgIGlmIChudW1MZW4pIHtcbiAgICAgICAgcG9zICs9IG51bUxlbjtcbiAgICAgICAgbGV0IG5hbWUgPSBcImludGVnZXJcIjtcbiAgICAgICAgaWYgKHN0cltwb3NdID09PSBcIi5cIikge1xuICAgICAgICAgIGxldCBmcmFjTGVuID0gcGFyc2VSZWdleChzdHIsIHBvcyArIDEsIE5VTSk7XG4gICAgICAgICAgZnJhY0xlbiAmJiAobmFtZSA9IFwiZmxvYXRcIiwgcG9zICs9IDEgKyBmcmFjTGVuKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RyW3Bvc10gPT09IFwiZVwiIHx8IHN0cltwb3NdID09PSBcIkVcIikge1xuICAgICAgICAgIG5hbWUgPSBcInNjaVwiLCBwb3MrKywgKHN0cltwb3NdID09PSBcIitcIiB8fCBzdHJbcG9zXSA9PT0gXCItXCIpICYmIHBvcysrO1xuICAgICAgICAgIGxldCBleHBMZW4gPSBwYXJzZVJlZ2V4KHN0ciwgcG9zLCBOVU0pO1xuICAgICAgICAgIGlmICghZXhwTGVuKVxuICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJlcnJvclwiLCBwb3NpdGlvbjogcG9zIH07XG4gICAgICAgICAgcG9zICs9IGV4cExlbjtcbiAgICAgICAgfVxuICAgICAgICBtYXJrcyA9IFtcbiAgICAgICAgICB7IG5hbWUsIHBvc2l0aW9uOiBzdGFydFBvcyB9LFxuICAgICAgICAgIHsgbmFtZTogbmFtZSArIFwiX2VuZFwiLCBwb3NpdGlvbjogcG9zIH1cbiAgICAgICAgXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBsZXQgaWRlbnRMZW4gPSBwYXJzZVJlZ2V4KHN0ciwgcG9zLCBJREVOVCk7XG4gICAgICBpZiAoaWRlbnRMZW4pIHtcbiAgICAgICAgc3dpdGNoIChwb3MgKz0gaWRlbnRMZW4sIHN0cltwb3NdKSB7XG4gICAgICAgICAgY2FzZSBcIjpcIjpcbiAgICAgICAgICBjYXNlIFwiKFwiOiB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gcGFyc2VGdW5jQ2FsbChzdHIsIHN0YXJ0UG9zLCBwb3MpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdC50eXBlID09PSBcImVycm9yXCIpXG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICBtYXJrcyA9IHJlc3VsdC5tYXJrcywgcG9zID0gcmVzdWx0LnBvc2l0aW9uO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBtYXJrcyA9IFtcbiAgICAgICAgICAgICAgeyBuYW1lOiBcInRoaXNfYXR0clwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSxcbiAgICAgICAgICAgICAgeyBuYW1lOiBcImlkZW50XCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9LFxuICAgICAgICAgICAgICB7IG5hbWU6IFwiaWRlbnRfZW5kXCIsIHBvc2l0aW9uOiBwb3MgfVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKCFtYXJrcylcbiAgICByZXR1cm4geyB0eXBlOiBcImVycm9yXCIsIHBvc2l0aW9uOiBwb3MgfTtcbiAgbGV0IGxoc0xldmVsID0gMTIsIHRyYXY7XG4gIGxvb3A6XG4gICAgZm9yICg7IDsgKSB7XG4gICAgICBsZXQgaW5uZXJQb3MgPSBza2lwV1Moc3RyLCBwb3MpO1xuICAgICAgaWYgKGlubmVyUG9zID09PSBzdHIubGVuZ3RoKSB7XG4gICAgICAgIHBvcyA9IGlubmVyUG9zO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmICh0cmF2ID0gcGFyc2VUcmF2ZXJzYWwoc3RyLCBpbm5lclBvcyksIHRyYXYudHlwZSA9PT0gXCJzdWNjZXNzXCIpIHtcbiAgICAgICAgZm9yIChtYXJrcy51bnNoaWZ0KHsgbmFtZTogXCJ0cmF2ZXJzZVwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSk7IHRyYXYudHlwZSA9PT0gXCJzdWNjZXNzXCI7IClcbiAgICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdCh0cmF2Lm1hcmtzKSwgcG9zID0gdHJhdi5wb3NpdGlvbiwgdHJhdiA9IHBhcnNlVHJhdmVyc2FsKHN0ciwgc2tpcFdTKHN0ciwgcG9zKSk7XG4gICAgICAgIG1hcmtzLnB1c2goeyBuYW1lOiBcInRyYXZlcnNhbF9lbmRcIiwgcG9zaXRpb246IHBvcyB9KTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKHN0cltpbm5lclBvc10pIHtcbiAgICAgICAgY2FzZSBcIj1cIjoge1xuICAgICAgICAgIHN3aXRjaCAoc3RyW2lubmVyUG9zICsgMV0pIHtcbiAgICAgICAgICAgIGNhc2UgXCI+XCI6IHtcbiAgICAgICAgICAgICAgaWYgKGxldmVsID4gMSB8fCBsaHNMZXZlbCA8PSAxKVxuICAgICAgICAgICAgICAgIGJyZWFrIGxvb3A7XG4gICAgICAgICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBpbm5lclBvcyArIDIpLCAxKTtcbiAgICAgICAgICAgICAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJocztcbiAgICAgICAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQocmhzLm1hcmtzKSwgbWFya3MudW5zaGlmdCh7IG5hbWU6IFwicGFpclwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSksIHBvcyA9IHJocy5wb3NpdGlvbiwgbGhzTGV2ZWwgPSAxO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCI9XCI6IHtcbiAgICAgICAgICAgICAgaWYgKGxldmVsID4gNCB8fCBsaHNMZXZlbCA8PSA0KVxuICAgICAgICAgICAgICAgIGJyZWFrIGxvb3A7XG4gICAgICAgICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBpbm5lclBvcyArIDIpLCA1KTtcbiAgICAgICAgICAgICAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJocztcbiAgICAgICAgICAgICAgbWFya3MudW5zaGlmdCh7IG5hbWU6IFwiY29tcFwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSksIG1hcmtzLnB1c2goeyBuYW1lOiBcIm9wXCIsIHBvc2l0aW9uOiBpbm5lclBvcyB9LCB7IG5hbWU6IFwib3BfZW5kXCIsIHBvc2l0aW9uOiBpbm5lclBvcyArIDIgfSksIG1hcmtzID0gbWFya3MuY29uY2F0KHJocy5tYXJrcyksIHBvcyA9IHJocy5wb3NpdGlvbiwgbGhzTGV2ZWwgPSA0O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIGJyZWFrIGxvb3A7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCIrXCI6IHtcbiAgICAgICAgICBpZiAobGV2ZWwgPiA2IHx8IGxoc0xldmVsIDwgNilcbiAgICAgICAgICAgIGJyZWFrIGxvb3A7XG4gICAgICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIGlubmVyUG9zICsgMSksIDcpO1xuICAgICAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKVxuICAgICAgICAgICAgcmV0dXJuIHJocztcbiAgICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChyaHMubWFya3MpLCBtYXJrcy51bnNoaWZ0KHsgbmFtZTogXCJhZGRcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pLCBwb3MgPSByaHMucG9zaXRpb24sIGxoc0xldmVsID0gNjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiLVwiOiB7XG4gICAgICAgICAgaWYgKGxldmVsID4gNiB8fCBsaHNMZXZlbCA8IDYpXG4gICAgICAgICAgICBicmVhayBsb29wO1xuICAgICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBpbm5lclBvcyArIDEpLCA3KTtcbiAgICAgICAgICBpZiAocmhzLnR5cGUgPT09IFwiZXJyb3JcIilcbiAgICAgICAgICAgIHJldHVybiByaHM7XG4gICAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQocmhzLm1hcmtzKSwgbWFya3MudW5zaGlmdCh7IG5hbWU6IFwic3ViXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KSwgcG9zID0gcmhzLnBvc2l0aW9uLCBsaHNMZXZlbCA9IDY7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIipcIjoge1xuICAgICAgICAgIGlmIChzdHJbaW5uZXJQb3MgKyAxXSA9PT0gXCIqXCIpIHtcbiAgICAgICAgICAgIGlmIChsZXZlbCA+IDggfHwgbGhzTGV2ZWwgPD0gOClcbiAgICAgICAgICAgICAgYnJlYWsgbG9vcDtcbiAgICAgICAgICAgIGxldCByaHMyID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgaW5uZXJQb3MgKyAyKSwgOCk7XG4gICAgICAgICAgICBpZiAocmhzMi50eXBlID09PSBcImVycm9yXCIpXG4gICAgICAgICAgICAgIHJldHVybiByaHMyO1xuICAgICAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQocmhzMi5tYXJrcyksIG1hcmtzLnVuc2hpZnQoeyBuYW1lOiBcInBvd1wiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSksIHBvcyA9IHJoczIucG9zaXRpb24sIGxoc0xldmVsID0gODtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobGV2ZWwgPiA3IHx8IGxoc0xldmVsIDwgNylcbiAgICAgICAgICAgIGJyZWFrIGxvb3A7XG4gICAgICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIGlubmVyUG9zICsgMSksIDgpO1xuICAgICAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKVxuICAgICAgICAgICAgcmV0dXJuIHJocztcbiAgICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChyaHMubWFya3MpLCBtYXJrcy51bnNoaWZ0KHsgbmFtZTogXCJtdWxcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pLCBwb3MgPSByaHMucG9zaXRpb24sIGxoc0xldmVsID0gNztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiL1wiOiB7XG4gICAgICAgICAgaWYgKGxldmVsID4gNyB8fCBsaHNMZXZlbCA8IDcpXG4gICAgICAgICAgICBicmVhayBsb29wO1xuICAgICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBpbm5lclBvcyArIDEpLCA4KTtcbiAgICAgICAgICBpZiAocmhzLnR5cGUgPT09IFwiZXJyb3JcIilcbiAgICAgICAgICAgIHJldHVybiByaHM7XG4gICAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQocmhzLm1hcmtzKSwgbWFya3MudW5zaGlmdCh7IG5hbWU6IFwiZGl2XCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KSwgcG9zID0gcmhzLnBvc2l0aW9uLCBsaHNMZXZlbCA9IDc7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIiVcIjoge1xuICAgICAgICAgIGlmIChsZXZlbCA+IDcgfHwgbGhzTGV2ZWwgPCA3KVxuICAgICAgICAgICAgYnJlYWsgbG9vcDtcbiAgICAgICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgaW5uZXJQb3MgKyAxKSwgOCk7XG4gICAgICAgICAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpXG4gICAgICAgICAgICByZXR1cm4gcmhzO1xuICAgICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJocy5tYXJrcyksIG1hcmtzLnVuc2hpZnQoeyBuYW1lOiBcIm1vZFwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSksIHBvcyA9IHJocy5wb3NpdGlvbiwgbGhzTGV2ZWwgPSA3O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCI8XCI6XG4gICAgICAgIGNhc2UgXCI+XCI6IHtcbiAgICAgICAgICBpZiAobGV2ZWwgPiA0IHx8IGxoc0xldmVsIDw9IDQpXG4gICAgICAgICAgICBicmVhayBsb29wO1xuICAgICAgICAgIGxldCBuZXh0UG9zID0gaW5uZXJQb3MgKyAxO1xuICAgICAgICAgIHN0cltuZXh0UG9zXSA9PT0gXCI9XCIgJiYgbmV4dFBvcysrO1xuICAgICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBuZXh0UG9zKSwgNSk7XG4gICAgICAgICAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpXG4gICAgICAgICAgICByZXR1cm4gcmhzO1xuICAgICAgICAgIG1hcmtzLnVuc2hpZnQoeyBuYW1lOiBcImNvbXBcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pLCBtYXJrcy5wdXNoKHsgbmFtZTogXCJvcFwiLCBwb3NpdGlvbjogaW5uZXJQb3MgfSwgeyBuYW1lOiBcIm9wX2VuZFwiLCBwb3NpdGlvbjogbmV4dFBvcyB9KSwgbWFya3MgPSBtYXJrcy5jb25jYXQocmhzLm1hcmtzKSwgcG9zID0gcmhzLnBvc2l0aW9uLCBsaHNMZXZlbCA9IDQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcInxcIjoge1xuICAgICAgICAgIGlmIChzdHJbaW5uZXJQb3MgKyAxXSA9PT0gXCJ8XCIpIHtcbiAgICAgICAgICAgIGlmIChsZXZlbCA+IDIgfHwgbGhzTGV2ZWwgPCAyKVxuICAgICAgICAgICAgICBicmVhayBsb29wO1xuICAgICAgICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIGlubmVyUG9zICsgMiksIDMpO1xuICAgICAgICAgICAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpXG4gICAgICAgICAgICAgIHJldHVybiByaHM7XG4gICAgICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChyaHMubWFya3MpLCBtYXJrcy51bnNoaWZ0KHsgbmFtZTogXCJvclwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSksIHBvcyA9IHJocy5wb3NpdGlvbiwgbGhzTGV2ZWwgPSAyO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAobGV2ZWwgPiAxMSB8fCBsaHNMZXZlbCA8IDExKVxuICAgICAgICAgICAgICBicmVhayBsb29wO1xuICAgICAgICAgICAgbGV0IGlkZW50UG9zID0gc2tpcFdTKHN0ciwgaW5uZXJQb3MgKyAxKSwgaWRlbnRMZW4gPSBwYXJzZVJlZ2V4KHN0ciwgaWRlbnRQb3MsIElERU5UKTtcbiAgICAgICAgICAgIGlmICghaWRlbnRMZW4pXG4gICAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IFwiZXJyb3JcIiwgcG9zaXRpb246IGlkZW50UG9zIH07XG4gICAgICAgICAgICBpZiAocG9zID0gaWRlbnRQb3MgKyBpZGVudExlbiwgc3RyW3Bvc10gPT09IFwiKFwiIHx8IHN0cltwb3NdID09PSBcIjpcIikge1xuICAgICAgICAgICAgICBsZXQgcmVzdWx0ID0gcGFyc2VGdW5jQ2FsbChzdHIsIGlkZW50UG9zLCBwb3MpO1xuICAgICAgICAgICAgICBpZiAocmVzdWx0LnR5cGUgPT09IFwiZXJyb3JcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChyZXN1bHQubWFya3MpLCBtYXJrcy51bnNoaWZ0KHsgbmFtZTogXCJwaXBlY2FsbFwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSksIHBvcyA9IHJlc3VsdC5wb3NpdGlvbiwgbGhzTGV2ZWwgPSAxMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIiZcIjoge1xuICAgICAgICAgIGlmIChzdHJbaW5uZXJQb3MgKyAxXSAhPSBcIiZcIiB8fCBsZXZlbCA+IDMgfHwgbGhzTGV2ZWwgPCAzKVxuICAgICAgICAgICAgYnJlYWsgbG9vcDtcbiAgICAgICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgaW5uZXJQb3MgKyAyKSwgNCk7XG4gICAgICAgICAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpXG4gICAgICAgICAgICByZXR1cm4gcmhzO1xuICAgICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJocy5tYXJrcyksIG1hcmtzLnVuc2hpZnQoeyBuYW1lOiBcImFuZFwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSksIHBvcyA9IHJocy5wb3NpdGlvbiwgbGhzTGV2ZWwgPSAzO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCIhXCI6IHtcbiAgICAgICAgICBpZiAoc3RyW2lubmVyUG9zICsgMV0gIT09IFwiPVwiIHx8IGxldmVsID4gNCB8fCBsaHNMZXZlbCA8PSA0KVxuICAgICAgICAgICAgYnJlYWsgbG9vcDtcbiAgICAgICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgaW5uZXJQb3MgKyAyKSwgNSk7XG4gICAgICAgICAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpXG4gICAgICAgICAgICByZXR1cm4gcmhzO1xuICAgICAgICAgIG1hcmtzLnVuc2hpZnQoeyBuYW1lOiBcImNvbXBcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pLCBtYXJrcy5wdXNoKHsgbmFtZTogXCJvcFwiLCBwb3NpdGlvbjogaW5uZXJQb3MgfSwgeyBuYW1lOiBcIm9wX2VuZFwiLCBwb3NpdGlvbjogaW5uZXJQb3MgKyAyIH0pLCBtYXJrcyA9IG1hcmtzLmNvbmNhdChyaHMubWFya3MpLCBwb3MgPSByaHMucG9zaXRpb24sIGxoc0xldmVsID0gNDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiZFwiOiB7XG4gICAgICAgICAgaWYgKHN0ci5zbGljZShpbm5lclBvcywgaW5uZXJQb3MgKyA0KSAhPT0gXCJkZXNjXCIgfHwgbGV2ZWwgPiA0IHx8IGxoc0xldmVsIDwgNClcbiAgICAgICAgICAgIGJyZWFrIGxvb3A7XG4gICAgICAgICAgbWFya3MudW5zaGlmdCh7IG5hbWU6IFwiZGVzY1wiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSksIHBvcyA9IGlubmVyUG9zICsgNCwgbGhzTGV2ZWwgPSA0O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJhXCI6IHtcbiAgICAgICAgICBpZiAoc3RyLnNsaWNlKGlubmVyUG9zLCBpbm5lclBvcyArIDMpICE9PSBcImFzY1wiIHx8IGxldmVsID4gNCB8fCBsaHNMZXZlbCA8IDQpXG4gICAgICAgICAgICBicmVhayBsb29wO1xuICAgICAgICAgIG1hcmtzLnVuc2hpZnQoeyBuYW1lOiBcImFzY1wiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSksIHBvcyA9IGlubmVyUG9zICsgMywgbGhzTGV2ZWwgPSA0O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgc3dpdGNoIChwYXJzZVJlZ2V4U3RyKHN0ciwgaW5uZXJQb3MsIElERU5UKSkge1xuICAgICAgICAgICAgY2FzZSBcImluXCI6IHtcbiAgICAgICAgICAgICAgaWYgKGxldmVsID4gNCB8fCBsaHNMZXZlbCA8PSA0KVxuICAgICAgICAgICAgICAgIGJyZWFrIGxvb3A7XG4gICAgICAgICAgICAgIHBvcyA9IHNraXBXUyhzdHIsIGlubmVyUG9zICsgMik7XG4gICAgICAgICAgICAgIGxldCBpc0dyb3VwID0gITE7XG4gICAgICAgICAgICAgIHN0cltwb3NdID09PSBcIihcIiAmJiAoaXNHcm91cCA9ICEwLCBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAxKSk7XG4gICAgICAgICAgICAgIGxldCByYW5nZVBvcyA9IHBvcywgcmVzdWx0ID0gcGFyc2VFeHByKHN0ciwgcG9zLCA1KTtcbiAgICAgICAgICAgICAgaWYgKHJlc3VsdC50eXBlID09PSBcImVycm9yXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgaWYgKHBvcyA9IHNraXBXUyhzdHIsIHJlc3VsdC5wb3NpdGlvbiksIHN0cltwb3NdID09PSBcIi5cIiAmJiBzdHJbcG9zICsgMV0gPT09IFwiLlwiKSB7XG4gICAgICAgICAgICAgICAgbGV0IHR5cGUgPSBcImluY19yYW5nZVwiO1xuICAgICAgICAgICAgICAgIHN0cltwb3MgKyAyXSA9PT0gXCIuXCIgPyAodHlwZSA9IFwiZXhjX3JhbmdlXCIsIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDMpKSA6IHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDIpO1xuICAgICAgICAgICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBwb3MsIDUpO1xuICAgICAgICAgICAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHJocztcbiAgICAgICAgICAgICAgICBtYXJrcy51bnNoaWZ0KHsgbmFtZTogXCJpbl9yYW5nZVwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSksIG1hcmtzID0gbWFya3MuY29uY2F0KHsgbmFtZTogdHlwZSwgcG9zaXRpb246IHJhbmdlUG9zIH0sIHJlc3VsdC5tYXJrcywgcmhzLm1hcmtzKSwgcG9zID0gcmhzLnBvc2l0aW9uO1xuICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICBtYXJrcy51bnNoaWZ0KHsgbmFtZTogXCJjb21wXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KSwgbWFya3MucHVzaCh7IG5hbWU6IFwib3BcIiwgcG9zaXRpb246IGlubmVyUG9zIH0sIHsgbmFtZTogXCJvcF9lbmRcIiwgcG9zaXRpb246IGlubmVyUG9zICsgMiB9KSwgbWFya3MgPSBtYXJrcy5jb25jYXQocmVzdWx0Lm1hcmtzKTtcbiAgICAgICAgICAgICAgaWYgKGlzR3JvdXApIHtcbiAgICAgICAgICAgICAgICBpZiAocG9zID0gc2tpcFdTKHN0ciwgcG9zKSwgc3RyW3Bvc10gIT09IFwiKVwiKVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJlcnJvclwiLCBwb3NpdGlvbjogcG9zIH07XG4gICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbGhzTGV2ZWwgPSA0O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJtYXRjaFwiOiB7XG4gICAgICAgICAgICAgIGlmIChsZXZlbCA+IDQgfHwgbGhzTGV2ZWwgPD0gNClcbiAgICAgICAgICAgICAgICBicmVhayBsb29wO1xuICAgICAgICAgICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgaW5uZXJQb3MgKyA1KSwgNSk7XG4gICAgICAgICAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKVxuICAgICAgICAgICAgICAgIHJldHVybiByaHM7XG4gICAgICAgICAgICAgIG1hcmtzLnVuc2hpZnQoeyBuYW1lOiBcImNvbXBcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pLCBtYXJrcy5wdXNoKHsgbmFtZTogXCJvcFwiLCBwb3NpdGlvbjogaW5uZXJQb3MgfSwgeyBuYW1lOiBcIm9wX2VuZFwiLCBwb3NpdGlvbjogaW5uZXJQb3MgKyA1IH0pLCBtYXJrcyA9IG1hcmtzLmNvbmNhdChyaHMubWFya3MpLCBwb3MgPSByaHMucG9zaXRpb24sIGxoc0xldmVsID0gNDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICBicmVhayBsb29wO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIGxldCBmYWlsUG9zaXRpb24gPSAodHJhdiA9PSBudWxsID8gdm9pZCAwIDogdHJhdi50eXBlKSA9PT0gXCJlcnJvclwiICYmIHRyYXYucG9zaXRpb247XG4gIHJldHVybiB7IHR5cGU6IFwic3VjY2Vzc1wiLCBtYXJrcywgcG9zaXRpb246IHBvcywgZmFpbFBvc2l0aW9uIH07XG59XG5mdW5jdGlvbiBwYXJzZVRyYXZlcnNhbChzdHIsIHBvcykge1xuICBsZXQgc3RhcnRQb3MgPSBwb3M7XG4gIHN3aXRjaCAoc3RyW3Bvc10pIHtcbiAgICBjYXNlIFwiLlwiOiB7XG4gICAgICBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAxKTtcbiAgICAgIGxldCBpZGVudFN0YXJ0ID0gcG9zLCBpZGVudExlbjIgPSBwYXJzZVJlZ2V4KHN0ciwgcG9zLCBJREVOVCk7XG4gICAgICByZXR1cm4gaWRlbnRMZW4yID8gKHBvcyArPSBpZGVudExlbjIsIHtcbiAgICAgICAgdHlwZTogXCJzdWNjZXNzXCIsXG4gICAgICAgIG1hcmtzOiBbXG4gICAgICAgICAgeyBuYW1lOiBcImF0dHJfYWNjZXNzXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9LFxuICAgICAgICAgIHsgbmFtZTogXCJpZGVudFwiLCBwb3NpdGlvbjogaWRlbnRTdGFydCB9LFxuICAgICAgICAgIHsgbmFtZTogXCJpZGVudF9lbmRcIiwgcG9zaXRpb246IHBvcyB9XG4gICAgICAgIF0sXG4gICAgICAgIHBvc2l0aW9uOiBwb3NcbiAgICAgIH0pIDogeyB0eXBlOiBcImVycm9yXCIsIHBvc2l0aW9uOiBwb3MgfTtcbiAgICB9XG4gICAgY2FzZSBcIi1cIjpcbiAgICAgIGlmIChzdHJbcG9zICsgMV0gIT09IFwiPlwiKVxuICAgICAgICByZXR1cm4geyB0eXBlOiBcImVycm9yXCIsIHBvc2l0aW9uOiBwb3MgfTtcbiAgICAgIGxldCBtYXJrcyA9IFt7IG5hbWU6IFwiZGVyZWZcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH1dO1xuICAgICAgcG9zICs9IDI7XG4gICAgICBsZXQgaWRlbnRQb3MgPSBza2lwV1Moc3RyLCBwb3MpLCBpZGVudExlbiA9IHBhcnNlUmVnZXgoc3RyLCBpZGVudFBvcywgSURFTlQpO1xuICAgICAgcmV0dXJuIGlkZW50TGVuICYmIChwb3MgPSBpZGVudFBvcyArIGlkZW50TGVuLCBtYXJrcy5wdXNoKFxuICAgICAgICB7IG5hbWU6IFwiZGVyZWZfYXR0clwiLCBwb3NpdGlvbjogaWRlbnRQb3MgfSxcbiAgICAgICAgeyBuYW1lOiBcImlkZW50XCIsIHBvc2l0aW9uOiBpZGVudFBvcyB9LFxuICAgICAgICB7IG5hbWU6IFwiaWRlbnRfZW5kXCIsIHBvc2l0aW9uOiBwb3MgfVxuICAgICAgKSksIHtcbiAgICAgICAgdHlwZTogXCJzdWNjZXNzXCIsXG4gICAgICAgIG1hcmtzLFxuICAgICAgICBwb3NpdGlvbjogcG9zXG4gICAgICB9O1xuICAgIGNhc2UgXCJbXCI6IHtcbiAgICAgIGlmIChwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAxKSwgc3RyW3Bvc10gPT09IFwiXVwiKVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6IFwic3VjY2Vzc1wiLFxuICAgICAgICAgIG1hcmtzOiBbeyBuYW1lOiBcImFycmF5X3Bvc3RmaXhcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH1dLFxuICAgICAgICAgIHBvc2l0aW9uOiBwb3MgKyAxXG4gICAgICAgIH07XG4gICAgICBsZXQgcmFuZ2VQb3MgPSBwb3MsIHJlc3VsdCA9IHBhcnNlRXhwcihzdHIsIHBvcywgMCk7XG4gICAgICBpZiAocmVzdWx0LnR5cGUgPT09IFwiZXJyb3JcIilcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIGlmIChwb3MgPSBza2lwV1Moc3RyLCByZXN1bHQucG9zaXRpb24pLCBzdHJbcG9zXSA9PT0gXCIuXCIgJiYgc3RyW3BvcyArIDFdID09PSBcIi5cIikge1xuICAgICAgICBsZXQgdHlwZSA9IFwiaW5jX3JhbmdlXCI7XG4gICAgICAgIHN0cltwb3MgKyAyXSA9PT0gXCIuXCIgPyAodHlwZSA9IFwiZXhjX3JhbmdlXCIsIHBvcyArPSAzKSA6IHBvcyArPSAyLCBwb3MgPSBza2lwV1Moc3RyLCBwb3MpO1xuICAgICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgcG9zLCAwKTtcbiAgICAgICAgcmV0dXJuIHJocy50eXBlID09PSBcImVycm9yXCIgPyByaHMgOiAocG9zID0gc2tpcFdTKHN0ciwgcmhzLnBvc2l0aW9uKSwgc3RyW3Bvc10gIT09IFwiXVwiID8geyB0eXBlOiBcImVycm9yXCIsIHBvc2l0aW9uOiBwb3MgfSA6IHtcbiAgICAgICAgICB0eXBlOiBcInN1Y2Nlc3NcIixcbiAgICAgICAgICBtYXJrczogW1xuICAgICAgICAgICAgeyBuYW1lOiBcInNsaWNlXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9LFxuICAgICAgICAgICAgeyBuYW1lOiB0eXBlLCBwb3NpdGlvbjogcmFuZ2VQb3MgfVxuICAgICAgICAgIF0uY29uY2F0KHJlc3VsdC5tYXJrcywgcmhzLm1hcmtzKSxcbiAgICAgICAgICBwb3NpdGlvbjogcG9zICsgMVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHJbcG9zXSAhPT0gXCJdXCIgPyB7IHR5cGU6IFwiZXJyb3JcIiwgcG9zaXRpb246IHBvcyB9IDoge1xuICAgICAgICB0eXBlOiBcInN1Y2Nlc3NcIixcbiAgICAgICAgbWFya3M6IFt7IG5hbWU6IFwic3F1YXJlX2JyYWNrZXRcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH1dLmNvbmNhdChyZXN1bHQubWFya3MpLFxuICAgICAgICBwb3NpdGlvbjogcG9zICsgMVxuICAgICAgfTtcbiAgICB9XG4gICAgY2FzZSBcInxcIjoge1xuICAgICAgaWYgKHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDEpLCBzdHJbcG9zXSA9PT0gXCJ7XCIpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHBhcnNlT2JqZWN0KHN0ciwgcG9zKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC50eXBlID09PSBcImVycm9yXCIgfHwgcmVzdWx0Lm1hcmtzLnVuc2hpZnQoeyBuYW1lOiBcInByb2plY3Rpb25cIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pLCByZXN1bHQ7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcIntcIjoge1xuICAgICAgbGV0IHJlc3VsdCA9IHBhcnNlT2JqZWN0KHN0ciwgcG9zKTtcbiAgICAgIHJldHVybiByZXN1bHQudHlwZSA9PT0gXCJlcnJvclwiIHx8IHJlc3VsdC5tYXJrcy51bnNoaWZ0KHsgbmFtZTogXCJwcm9qZWN0aW9uXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KSwgcmVzdWx0O1xuICAgIH1cbiAgfVxuICByZXR1cm4geyB0eXBlOiBcImVycm9yXCIsIHBvc2l0aW9uOiBwb3MgfTtcbn1cbmZ1bmN0aW9uIHBhcnNlRnVuY0NhbGwoc3RyLCBzdGFydFBvcywgcG9zKSB7XG4gIGxldCBtYXJrcyA9IFtdO1xuICBpZiAobWFya3MucHVzaCh7IG5hbWU6IFwiZnVuY19jYWxsXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KSwgc3RyW3Bvc10gPT09IFwiOlwiICYmIHN0cltwb3MgKyAxXSA9PT0gXCI6XCIpIHtcbiAgICBtYXJrcy5wdXNoKHsgbmFtZTogXCJuYW1lc3BhY2VcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pLCBtYXJrcy5wdXNoKHsgbmFtZTogXCJpZGVudFwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSwgeyBuYW1lOiBcImlkZW50X2VuZFwiLCBwb3NpdGlvbjogcG9zIH0pLCBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAyKTtcbiAgICBsZXQgbmFtZUxlbiA9IHBhcnNlUmVnZXgoc3RyLCBwb3MsIElERU5UKTtcbiAgICBpZiAoIW5hbWVMZW4pXG4gICAgICByZXR1cm4geyB0eXBlOiBcImVycm9yXCIsIHBvc2l0aW9uOiBwb3MgfTtcbiAgICBpZiAobWFya3MucHVzaCh7IG5hbWU6IFwiaWRlbnRcIiwgcG9zaXRpb246IHBvcyB9LCB7IG5hbWU6IFwiaWRlbnRfZW5kXCIsIHBvc2l0aW9uOiBwb3MgKyBuYW1lTGVuIH0pLCBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyBuYW1lTGVuKSwgc3RyW3Bvc10gIT09IFwiKFwiKVxuICAgICAgcmV0dXJuIHsgdHlwZTogXCJlcnJvclwiLCBwb3NpdGlvbjogcG9zIH07XG4gICAgcG9zKyssIHBvcyA9IHNraXBXUyhzdHIsIHBvcyk7XG4gIH0gZWxzZVxuICAgIG1hcmtzLnB1c2goeyBuYW1lOiBcImlkZW50XCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9LCB7IG5hbWU6IFwiaWRlbnRfZW5kXCIsIHBvc2l0aW9uOiBwb3MgfSksIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDEpO1xuICBsZXQgbGFzdFBvcyA9IHBvcztcbiAgaWYgKHN0cltwb3NdICE9PSBcIilcIilcbiAgICBmb3IgKDsgOyApIHtcbiAgICAgIGxldCByZXN1bHQgPSBwYXJzZUV4cHIoc3RyLCBwb3MsIDApO1xuICAgICAgaWYgKHJlc3VsdC50eXBlID09PSBcImVycm9yXCIpXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICBpZiAobWFya3MgPSBtYXJrcy5jb25jYXQocmVzdWx0Lm1hcmtzKSwgbGFzdFBvcyA9IHJlc3VsdC5wb3NpdGlvbiwgcG9zID0gc2tpcFdTKHN0ciwgcmVzdWx0LnBvc2l0aW9uKSwgc3RyW3Bvc10gIT09IFwiLFwiIHx8IChwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAxKSwgc3RyW3Bvc10gPT09IFwiKVwiKSlcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICByZXR1cm4gc3RyW3Bvc10gIT09IFwiKVwiID8geyB0eXBlOiBcImVycm9yXCIsIHBvc2l0aW9uOiBwb3MgfSA6IChtYXJrcy5wdXNoKHsgbmFtZTogXCJmdW5jX2FyZ3NfZW5kXCIsIHBvc2l0aW9uOiBsYXN0UG9zIH0pLCB7XG4gICAgdHlwZTogXCJzdWNjZXNzXCIsXG4gICAgbWFya3MsXG4gICAgcG9zaXRpb246IHBvcyArIDFcbiAgfSk7XG59XG5mdW5jdGlvbiBwYXJzZU9iamVjdChzdHIsIHBvcykge1xuICBsZXQgbWFya3MgPSBbeyBuYW1lOiBcIm9iamVjdFwiLCBwb3NpdGlvbjogcG9zIH1dO1xuICBmb3IgKHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDEpOyBzdHJbcG9zXSAhPT0gXCJ9XCI7ICkge1xuICAgIGxldCBwYWlyUG9zID0gcG9zO1xuICAgIGlmIChzdHIuc2xpY2UocG9zLCBwb3MgKyAzKSA9PT0gXCIuLi5cIilcbiAgICAgIGlmIChwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAzKSwgc3RyW3Bvc10gIT09IFwifVwiICYmIHN0cltwb3NdICE9PSBcIixcIikge1xuICAgICAgICBsZXQgZXhwciA9IHBhcnNlRXhwcihzdHIsIHBvcywgMCk7XG4gICAgICAgIGlmIChleHByLnR5cGUgPT09IFwiZXJyb3JcIilcbiAgICAgICAgICByZXR1cm4gZXhwcjtcbiAgICAgICAgbWFya3MucHVzaCh7IG5hbWU6IFwib2JqZWN0X3NwbGF0XCIsIHBvc2l0aW9uOiBwYWlyUG9zIH0pLCBtYXJrcyA9IG1hcmtzLmNvbmNhdChleHByLm1hcmtzKSwgcG9zID0gZXhwci5wb3NpdGlvbjtcbiAgICAgIH0gZWxzZVxuICAgICAgICBtYXJrcy5wdXNoKHsgbmFtZTogXCJvYmplY3Rfc3BsYXRfdGhpc1wiLCBwb3NpdGlvbjogcGFpclBvcyB9KTtcbiAgICBlbHNlIHtcbiAgICAgIGxldCBleHByID0gcGFyc2VFeHByKHN0ciwgcG9zLCAwKTtcbiAgICAgIGlmIChleHByLnR5cGUgPT09IFwiZXJyb3JcIilcbiAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgICBsZXQgbmV4dFBvcyA9IHNraXBXUyhzdHIsIGV4cHIucG9zaXRpb24pO1xuICAgICAgaWYgKGV4cHIubWFya3NbMF0ubmFtZSA9PT0gXCJzdHJcIiAmJiBzdHJbbmV4dFBvc10gPT09IFwiOlwiKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIG5leHRQb3MgKyAxKSwgMCk7XG4gICAgICAgIGlmICh2YWx1ZS50eXBlID09PSBcImVycm9yXCIpXG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICBtYXJrcy5wdXNoKHsgbmFtZTogXCJvYmplY3RfcGFpclwiLCBwb3NpdGlvbjogcGFpclBvcyB9KSwgbWFya3MgPSBtYXJrcy5jb25jYXQoZXhwci5tYXJrcywgdmFsdWUubWFya3MpLCBwb3MgPSB2YWx1ZS5wb3NpdGlvbjtcbiAgICAgIH0gZWxzZVxuICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdCh7IG5hbWU6IFwib2JqZWN0X2V4cHJcIiwgcG9zaXRpb246IHBvcyB9LCBleHByLm1hcmtzKSwgcG9zID0gZXhwci5wb3NpdGlvbjtcbiAgICB9XG4gICAgaWYgKHBvcyA9IHNraXBXUyhzdHIsIHBvcyksIHN0cltwb3NdICE9PSBcIixcIilcbiAgICAgIGJyZWFrO1xuICAgIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDEpO1xuICB9XG4gIHJldHVybiBzdHJbcG9zXSAhPT0gXCJ9XCIgPyB7IHR5cGU6IFwiZXJyb3JcIiwgcG9zaXRpb246IHBvcyB9IDogKHBvcysrLCBtYXJrcy5wdXNoKHsgbmFtZTogXCJvYmplY3RfZW5kXCIsIHBvc2l0aW9uOiBwb3MgfSksIHsgdHlwZTogXCJzdWNjZXNzXCIsIG1hcmtzLCBwb3NpdGlvbjogcG9zIH0pO1xufVxuZnVuY3Rpb24gcGFyc2VTdHJpbmcoc3RyLCBwb3MpIHtcbiAgbGV0IHRva2VuID0gc3RyW3Bvc107XG4gIHBvcyA9IHBvcyArIDE7XG4gIGNvbnN0IG1hcmtzID0gW3sgbmFtZTogXCJzdHJcIiwgcG9zaXRpb246IHBvcyB9XTtcbiAgc3RyOlxuICAgIGZvciAoOyA7IHBvcysrKSB7XG4gICAgICBpZiAocG9zID4gc3RyLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJlcnJvclwiLCBwb3NpdGlvbjogcG9zIH07XG4gICAgICBzd2l0Y2ggKHN0cltwb3NdKSB7XG4gICAgICAgIGNhc2UgdG9rZW46IHtcbiAgICAgICAgICBtYXJrcy5wdXNoKHsgbmFtZTogXCJzdHJfZW5kXCIsIHBvc2l0aW9uOiBwb3MgfSksIHBvcysrO1xuICAgICAgICAgIGJyZWFrIHN0cjtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiXFxcXFwiOlxuICAgICAgICAgIG1hcmtzLnB1c2goeyBuYW1lOiBcInN0cl9wYXVzZVwiLCBwb3NpdGlvbjogcG9zIH0pLCBzdHJbcG9zICsgMV0gPT09IFwidVwiID8gc3RyW3BvcyArIDJdID09PSBcIntcIiA/IChtYXJrcy5wdXNoKHsgbmFtZTogXCJ1bmljb2RlX2hleFwiLCBwb3NpdGlvbjogcG9zICsgMyB9KSwgcG9zID0gc3RyLmluZGV4T2YoXCJ9XCIsIHBvcyArIDMpLCBtYXJrcy5wdXNoKHsgbmFtZTogXCJ1bmljb2RlX2hleF9lbmRcIiwgcG9zaXRpb246IHBvcyB9KSkgOiAobWFya3MucHVzaCh7IG5hbWU6IFwidW5pY29kZV9oZXhcIiwgcG9zaXRpb246IHBvcyArIDIgfSksIG1hcmtzLnB1c2goeyBuYW1lOiBcInVuaWNvZGVfaGV4X2VuZFwiLCBwb3NpdGlvbjogcG9zICsgNiB9KSwgcG9zICs9IDUpIDogKG1hcmtzLnB1c2goeyBuYW1lOiBcInNpbmdsZV9lc2NhcGVcIiwgcG9zaXRpb246IHBvcyArIDEgfSksIHBvcyArPSAxKSwgbWFya3MucHVzaCh7IG5hbWU6IFwic3RyX3N0YXJ0XCIsIHBvc2l0aW9uOiBwb3MgKyAxIH0pO1xuICAgICAgfVxuICAgIH1cbiAgcmV0dXJuIHsgdHlwZTogXCJzdWNjZXNzXCIsIG1hcmtzLCBwb3NpdGlvbjogcG9zIH07XG59XG5mdW5jdGlvbiBza2lwV1Moc3RyLCBwb3MpIHtcbiAgcmV0dXJuIHBvcyArIHBhcnNlUmVnZXgoc3RyLCBwb3MsIFdTKTtcbn1cbmZ1bmN0aW9uIHBhcnNlUmVnZXgoc3RyLCBwb3MsIHJlKSB7XG4gIGxldCBtID0gcmUuZXhlYyhzdHIuc2xpY2UocG9zKSk7XG4gIHJldHVybiBtID8gbVswXS5sZW5ndGggOiAwO1xufVxuZnVuY3Rpb24gcGFyc2VSZWdleFN0cihzdHIsIHBvcywgcmUpIHtcbiAgbGV0IG0gPSByZS5leGVjKHN0ci5zbGljZShwb3MpKTtcbiAgcmV0dXJuIG0gPyBtWzBdIDogbnVsbDtcbn1cbmZ1bmN0aW9uIGpvaW4oYSwgYikge1xuICByZXR1cm4gKGJhc2UpID0+IGIoYShiYXNlKSk7XG59XG5mdW5jdGlvbiBtYXAoaW5uZXIpIHtcbiAgcmV0dXJuIChiYXNlKSA9PiAoeyB0eXBlOiBcIk1hcFwiLCBiYXNlLCBleHByOiBpbm5lcih7IHR5cGU6IFwiVGhpc1wiIH0pIH0pO1xufVxuZnVuY3Rpb24gZmxhdE1hcChpbm5lcikge1xuICByZXR1cm4gKGJhc2UpID0+ICh7IHR5cGU6IFwiRmxhdE1hcFwiLCBiYXNlLCBleHByOiBpbm5lcih7IHR5cGU6IFwiVGhpc1wiIH0pIH0pO1xufVxuZnVuY3Rpb24gdHJhdmVyc2VBcnJheShidWlsZCwgcmlnaHQpIHtcbiAgaWYgKCFyaWdodClcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJhLWFcIixcbiAgICAgIGJ1aWxkXG4gICAgfTtcbiAgc3dpdGNoIChyaWdodC50eXBlKSB7XG4gICAgY2FzZSBcImEtYVwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJhLWFcIixcbiAgICAgICAgYnVpbGQ6IGpvaW4oYnVpbGQsIHJpZ2h0LmJ1aWxkKVxuICAgICAgfTtcbiAgICBjYXNlIFwiYS1iXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImEtYlwiLFxuICAgICAgICBidWlsZDogam9pbihidWlsZCwgcmlnaHQuYnVpbGQpXG4gICAgICB9O1xuICAgIGNhc2UgXCJiLWJcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiYS1hXCIsXG4gICAgICAgIGJ1aWxkOiBqb2luKGJ1aWxkLCBtYXAocmlnaHQuYnVpbGQpKVxuICAgICAgfTtcbiAgICBjYXNlIFwiYi1hXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImEtYVwiLFxuICAgICAgICBidWlsZDogam9pbihidWlsZCwgZmxhdE1hcChyaWdodC5idWlsZCkpXG4gICAgICB9O1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHVua25vd24gdHlwZTogJHtyaWdodC50eXBlfWApO1xuICB9XG59XG5mdW5jdGlvbiB0cmF2ZXJzZVBsYWluKG1hcHBlciwgcmlnaHQpIHtcbiAgaWYgKCFyaWdodClcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJiLWJcIixcbiAgICAgIGJ1aWxkOiBtYXBwZXJcbiAgICB9O1xuICBzd2l0Y2ggKHJpZ2h0LnR5cGUpIHtcbiAgICBjYXNlIFwiYS1hXCI6XG4gICAgY2FzZSBcImItYVwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJiLWFcIixcbiAgICAgICAgYnVpbGQ6IGpvaW4obWFwcGVyLCByaWdodC5idWlsZClcbiAgICAgIH07XG4gICAgY2FzZSBcImEtYlwiOlxuICAgIGNhc2UgXCJiLWJcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiYi1iXCIsXG4gICAgICAgIGJ1aWxkOiBqb2luKG1hcHBlciwgcmlnaHQuYnVpbGQpXG4gICAgICB9O1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHVua25vd24gdHlwZTogJHtyaWdodC50eXBlfWApO1xuICB9XG59XG5mdW5jdGlvbiB0cmF2ZXJzZUVsZW1lbnQobWFwcGVyLCByaWdodCkge1xuICBpZiAoIXJpZ2h0KVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImEtYlwiLFxuICAgICAgYnVpbGQ6IG1hcHBlclxuICAgIH07XG4gIHN3aXRjaCAocmlnaHQudHlwZSkge1xuICAgIGNhc2UgXCJhLWFcIjpcbiAgICBjYXNlIFwiYi1hXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImEtYVwiLFxuICAgICAgICBidWlsZDogam9pbihtYXBwZXIsIHJpZ2h0LmJ1aWxkKVxuICAgICAgfTtcbiAgICBjYXNlIFwiYS1iXCI6XG4gICAgY2FzZSBcImItYlwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJhLWJcIixcbiAgICAgICAgYnVpbGQ6IGpvaW4obWFwcGVyLCByaWdodC5idWlsZClcbiAgICAgIH07XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdW5rbm93biB0eXBlOiAke3JpZ2h0LnR5cGV9YCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHRyYXZlcnNlUHJvamVjdGlvbihtYXBwZXIsIHJpZ2h0KSB7XG4gIGlmICghcmlnaHQpXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiYi1iXCIsXG4gICAgICBidWlsZDogbWFwcGVyXG4gICAgfTtcbiAgc3dpdGNoIChyaWdodC50eXBlKSB7XG4gICAgY2FzZSBcImEtYVwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJhLWFcIixcbiAgICAgICAgYnVpbGQ6IGpvaW4obWFwKG1hcHBlciksIHJpZ2h0LmJ1aWxkKVxuICAgICAgfTtcbiAgICBjYXNlIFwiYS1iXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImEtYlwiLFxuICAgICAgICBidWlsZDogam9pbihtYXAobWFwcGVyKSwgcmlnaHQuYnVpbGQpXG4gICAgICB9O1xuICAgIGNhc2UgXCJiLWFcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiYi1hXCIsXG4gICAgICAgIGJ1aWxkOiBqb2luKG1hcHBlciwgcmlnaHQuYnVpbGQpXG4gICAgICB9O1xuICAgIGNhc2UgXCJiLWJcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiYi1iXCIsXG4gICAgICAgIGJ1aWxkOiBqb2luKG1hcHBlciwgcmlnaHQuYnVpbGQpXG4gICAgICB9O1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHVua25vd24gdHlwZTogJHtyaWdodC50eXBlfWApO1xuICB9XG59XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5LCBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwLCB3cml0YWJsZTogITAsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZSwgX19wdWJsaWNGaWVsZCA9IChvYmosIGtleSwgdmFsdWUpID0+IChfX2RlZk5vcm1hbFByb3Aob2JqLCB0eXBlb2Yga2V5ICE9IFwic3ltYm9sXCIgPyBrZXkgKyBcIlwiIDoga2V5LCB2YWx1ZSksIHZhbHVlKTtcbmNvbnN0IEVTQ0FQRV9TRVFVRU5DRSA9IHtcbiAgXCInXCI6IFwiJ1wiLFxuICAnXCInOiAnXCInLFxuICBcIlxcXFxcIjogXCJcXFxcXCIsXG4gIFwiL1wiOiBcIi9cIixcbiAgYjogXCJcXGJcIixcbiAgZjogXCJcXGZcIixcbiAgbjogYFxuYCxcbiAgcjogXCJcXHJcIixcbiAgdDogXCJcdFwiXG59O1xuZnVuY3Rpb24gZXhwYW5kSGV4KHN0cikge1xuICBjb25zdCBjaGFyQ29kZSA9IHBhcnNlSW50KHN0ciwgMTYpO1xuICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjaGFyQ29kZSk7XG59XG5jbGFzcyBHcm9xUXVlcnlFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKSwgX19wdWJsaWNGaWVsZCh0aGlzLCBcIm5hbWVcIiwgXCJHcm9xUXVlcnlFcnJvclwiKTtcbiAgfVxufVxuY29uc3QgRVhQUl9CVUlMREVSID0ge1xuICBncm91cChwKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiR3JvdXBcIixcbiAgICAgIGJhc2U6IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpXG4gICAgfTtcbiAgfSxcbiAgZXZlcnl0aGluZygpIHtcbiAgICByZXR1cm4geyB0eXBlOiBcIkV2ZXJ5dGhpbmdcIiB9O1xuICB9LFxuICB0aGlzKCkge1xuICAgIHJldHVybiB7IHR5cGU6IFwiVGhpc1wiIH07XG4gIH0sXG4gIHBhcmVudCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJQYXJlbnRcIixcbiAgICAgIG46IDFcbiAgICB9O1xuICB9LFxuICBkYmxwYXJlbnQocCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIlBhcmVudFwiLFxuICAgICAgbjogcC5wcm9jZXNzKEVYUFJfQlVJTERFUikubiArIDFcbiAgICB9O1xuICB9LFxuICB0cmF2ZXJzZShwKSB7XG4gICAgY29uc3QgYmFzZSA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpLCB0cmF2ZXJzYWxMaXN0ID0gW107XG4gICAgZm9yICg7IHAuZ2V0TWFyaygpLm5hbWUgIT09IFwidHJhdmVyc2FsX2VuZFwiOyApXG4gICAgICB0cmF2ZXJzYWxMaXN0LnB1c2gocC5wcm9jZXNzKFRSQVZFUlNFX0JVSUxERVIpKTtcbiAgICBwLnNoaWZ0KCk7XG4gICAgbGV0IHRyYXZlcnNhbCA9IG51bGw7XG4gICAgZm9yIChsZXQgaSA9IHRyYXZlcnNhbExpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICB0cmF2ZXJzYWwgPSB0cmF2ZXJzYWxMaXN0W2ldKHRyYXZlcnNhbCk7XG4gICAgaWYgKChiYXNlLnR5cGUgPT09IFwiRXZlcnl0aGluZ1wiIHx8IGJhc2UudHlwZSA9PT0gXCJBcnJheVwiIHx8IGJhc2UudHlwZSA9PT0gXCJQaXBlRnVuY0NhbGxcIikgJiYgKHRyYXZlcnNhbCA9IHRyYXZlcnNlQXJyYXkoKHZhbCkgPT4gdmFsLCB0cmF2ZXJzYWwpKSwgdHJhdmVyc2FsID09PSBudWxsKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQlVHOiB1bmV4cGVjdGVkIGVtcHR5IHRyYXZlcnNhbFwiKTtcbiAgICByZXR1cm4gdHJhdmVyc2FsLmJ1aWxkKGJhc2UpO1xuICB9LFxuICB0aGlzX2F0dHIocCkge1xuICAgIGNvbnN0IG5hbWUgPSBwLnByb2Nlc3NTdHJpbmcoKTtcbiAgICByZXR1cm4gbmFtZSA9PT0gXCJudWxsXCIgPyB7IHR5cGU6IFwiVmFsdWVcIiwgdmFsdWU6IG51bGwgfSA6IG5hbWUgPT09IFwidHJ1ZVwiID8geyB0eXBlOiBcIlZhbHVlXCIsIHZhbHVlOiAhMCB9IDogbmFtZSA9PT0gXCJmYWxzZVwiID8geyB0eXBlOiBcIlZhbHVlXCIsIHZhbHVlOiAhMSB9IDoge1xuICAgICAgdHlwZTogXCJBY2Nlc3NBdHRyaWJ1dGVcIixcbiAgICAgIG5hbWVcbiAgICB9O1xuICB9LFxuICBuZWcocCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIk5lZ1wiLFxuICAgICAgYmFzZTogcC5wcm9jZXNzKEVYUFJfQlVJTERFUilcbiAgICB9O1xuICB9LFxuICBwb3MocCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIlBvc1wiLFxuICAgICAgYmFzZTogcC5wcm9jZXNzKEVYUFJfQlVJTERFUilcbiAgICB9O1xuICB9LFxuICBhZGQocCkge1xuICAgIGNvbnN0IGxlZnQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKSwgcmlnaHQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJPcENhbGxcIixcbiAgICAgIG9wOiBcIitcIixcbiAgICAgIGxlZnQsXG4gICAgICByaWdodFxuICAgIH07XG4gIH0sXG4gIHN1YihwKSB7XG4gICAgY29uc3QgbGVmdCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpLCByaWdodCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIk9wQ2FsbFwiLFxuICAgICAgb3A6IFwiLVwiLFxuICAgICAgbGVmdCxcbiAgICAgIHJpZ2h0XG4gICAgfTtcbiAgfSxcbiAgbXVsKHApIHtcbiAgICBjb25zdCBsZWZ0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUiksIHJpZ2h0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiT3BDYWxsXCIsXG4gICAgICBvcDogXCIqXCIsXG4gICAgICBsZWZ0LFxuICAgICAgcmlnaHRcbiAgICB9O1xuICB9LFxuICBkaXYocCkge1xuICAgIGNvbnN0IGxlZnQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKSwgcmlnaHQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJPcENhbGxcIixcbiAgICAgIG9wOiBcIi9cIixcbiAgICAgIGxlZnQsXG4gICAgICByaWdodFxuICAgIH07XG4gIH0sXG4gIG1vZChwKSB7XG4gICAgY29uc3QgbGVmdCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpLCByaWdodCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIk9wQ2FsbFwiLFxuICAgICAgb3A6IFwiJVwiLFxuICAgICAgbGVmdCxcbiAgICAgIHJpZ2h0XG4gICAgfTtcbiAgfSxcbiAgcG93KHApIHtcbiAgICBjb25zdCBsZWZ0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUiksIHJpZ2h0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiT3BDYWxsXCIsXG4gICAgICBvcDogXCIqKlwiLFxuICAgICAgbGVmdCxcbiAgICAgIHJpZ2h0XG4gICAgfTtcbiAgfSxcbiAgY29tcChwKSB7XG4gICAgY29uc3QgbGVmdCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpLCBvcCA9IHAucHJvY2Vzc1N0cmluZygpLCByaWdodCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIk9wQ2FsbFwiLFxuICAgICAgb3AsXG4gICAgICBsZWZ0LFxuICAgICAgcmlnaHRcbiAgICB9O1xuICB9LFxuICBpbl9yYW5nZShwKSB7XG4gICAgY29uc3QgYmFzZSA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpLCBpc0luY2x1c2l2ZSA9IHAuZ2V0TWFyaygpLm5hbWUgPT09IFwiaW5jX3JhbmdlXCI7XG4gICAgcC5zaGlmdCgpO1xuICAgIGNvbnN0IGxlZnQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKSwgcmlnaHQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJJblJhbmdlXCIsXG4gICAgICBiYXNlLFxuICAgICAgbGVmdCxcbiAgICAgIHJpZ2h0LFxuICAgICAgaXNJbmNsdXNpdmVcbiAgICB9O1xuICB9LFxuICBzdHIocCkge1xuICAgIGxldCB2YWx1ZSA9IFwiXCI7XG4gICAgbG9vcDpcbiAgICAgIGZvciAoOyBwLmhhc01hcmsoKTsgKSB7XG4gICAgICAgIGNvbnN0IG1hcmsgPSBwLmdldE1hcmsoKTtcbiAgICAgICAgc3dpdGNoIChtYXJrLm5hbWUpIHtcbiAgICAgICAgICBjYXNlIFwic3RyX2VuZFwiOlxuICAgICAgICAgICAgdmFsdWUgKz0gcC5wcm9jZXNzU3RyaW5nRW5kKCk7XG4gICAgICAgICAgICBicmVhayBsb29wO1xuICAgICAgICAgIGNhc2UgXCJzdHJfcGF1c2VcIjpcbiAgICAgICAgICAgIHZhbHVlICs9IHAucHJvY2Vzc1N0cmluZ0VuZCgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcInN0cl9zdGFydFwiOlxuICAgICAgICAgICAgcC5zaGlmdCgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcInNpbmdsZV9lc2NhcGVcIjoge1xuICAgICAgICAgICAgY29uc3QgY2hhciA9IHAuc2xpY2UoMSk7XG4gICAgICAgICAgICBwLnNoaWZ0KCksIHZhbHVlICs9IEVTQ0FQRV9TRVFVRU5DRVtjaGFyXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwidW5pY29kZV9oZXhcIjpcbiAgICAgICAgICAgIHAuc2hpZnQoKSwgdmFsdWUgKz0gZXhwYW5kSGV4KHAucHJvY2Vzc1N0cmluZ0VuZCgpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuZXhwZWN0ZWQgbWFyazogJHttYXJrLm5hbWV9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICByZXR1cm4geyB0eXBlOiBcIlZhbHVlXCIsIHZhbHVlIH07XG4gIH0sXG4gIGludGVnZXIocCkge1xuICAgIGNvbnN0IHN0clZhbHVlID0gcC5wcm9jZXNzU3RyaW5nRW5kKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiVmFsdWVcIixcbiAgICAgIHZhbHVlOiBOdW1iZXIoc3RyVmFsdWUpXG4gICAgfTtcbiAgfSxcbiAgZmxvYXQocCkge1xuICAgIGNvbnN0IHN0clZhbHVlID0gcC5wcm9jZXNzU3RyaW5nRW5kKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiVmFsdWVcIixcbiAgICAgIHZhbHVlOiBOdW1iZXIoc3RyVmFsdWUpXG4gICAgfTtcbiAgfSxcbiAgc2NpKHApIHtcbiAgICBjb25zdCBzdHJWYWx1ZSA9IHAucHJvY2Vzc1N0cmluZ0VuZCgpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIlZhbHVlXCIsXG4gICAgICB2YWx1ZTogTnVtYmVyKHN0clZhbHVlKVxuICAgIH07XG4gIH0sXG4gIG9iamVjdChwKSB7XG4gICAgY29uc3QgYXR0cmlidXRlcyA9IFtdO1xuICAgIGZvciAoOyBwLmdldE1hcmsoKS5uYW1lICE9PSBcIm9iamVjdF9lbmRcIjsgKVxuICAgICAgYXR0cmlidXRlcy5wdXNoKHAucHJvY2VzcyhPQkpFQ1RfQlVJTERFUikpO1xuICAgIHJldHVybiBwLnNoaWZ0KCksIHtcbiAgICAgIHR5cGU6IFwiT2JqZWN0XCIsXG4gICAgICBhdHRyaWJ1dGVzXG4gICAgfTtcbiAgfSxcbiAgYXJyYXkocCkge1xuICAgIGNvbnN0IGVsZW1lbnRzID0gW107XG4gICAgZm9yICg7IHAuZ2V0TWFyaygpLm5hbWUgIT09IFwiYXJyYXlfZW5kXCI7ICkge1xuICAgICAgbGV0IGlzU3BsYXQgPSAhMTtcbiAgICAgIHAuZ2V0TWFyaygpLm5hbWUgPT09IFwiYXJyYXlfc3BsYXRcIiAmJiAoaXNTcGxhdCA9ICEwLCBwLnNoaWZ0KCkpO1xuICAgICAgY29uc3QgdmFsdWUgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICAgIGVsZW1lbnRzLnB1c2goe1xuICAgICAgICB0eXBlOiBcIkFycmF5RWxlbWVudFwiLFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgaXNTcGxhdFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBwLnNoaWZ0KCksIHtcbiAgICAgIHR5cGU6IFwiQXJyYXlcIixcbiAgICAgIGVsZW1lbnRzXG4gICAgfTtcbiAgfSxcbiAgdHVwbGUocCkge1xuICAgIGNvbnN0IG1lbWJlcnMgPSBbXTtcbiAgICBmb3IgKDsgcC5nZXRNYXJrKCkubmFtZSAhPT0gXCJ0dXBsZV9lbmRcIjsgKVxuICAgICAgbWVtYmVycy5wdXNoKHAucHJvY2VzcyhFWFBSX0JVSUxERVIpKTtcbiAgICByZXR1cm4gcC5zaGlmdCgpLCB7XG4gICAgICB0eXBlOiBcIlR1cGxlXCIsXG4gICAgICBtZW1iZXJzXG4gICAgfTtcbiAgfSxcbiAgZnVuY19jYWxsKHApIHtcbiAgICBsZXQgbmFtZXNwYWNlID0gXCJnbG9iYWxcIjtcbiAgICBwLmdldE1hcmsoKS5uYW1lID09PSBcIm5hbWVzcGFjZVwiICYmIChwLnNoaWZ0KCksIG5hbWVzcGFjZSA9IHAucHJvY2Vzc1N0cmluZygpKTtcbiAgICBjb25zdCBuYW1lID0gcC5wcm9jZXNzU3RyaW5nKCk7XG4gICAgaWYgKG5hbWVzcGFjZSA9PT0gXCJnbG9iYWxcIiAmJiBuYW1lID09PSBcInNlbGVjdFwiKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgIHR5cGU6IFwiU2VsZWN0XCIsXG4gICAgICAgIGFsdGVybmF0aXZlczogW11cbiAgICAgIH07XG4gICAgICBmb3IgKDsgcC5nZXRNYXJrKCkubmFtZSAhPT0gXCJmdW5jX2FyZ3NfZW5kXCI7IClcbiAgICAgICAgaWYgKHAuZ2V0TWFyaygpLm5hbWUgPT09IFwicGFpclwiKSB7XG4gICAgICAgICAgaWYgKHJlc3VsdC5mYWxsYmFjaylcbiAgICAgICAgICAgIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihcInVuZXhwZWN0ZWQgYXJndW1lbnQgdG8gc2VsZWN0KClcIik7XG4gICAgICAgICAgcC5zaGlmdCgpO1xuICAgICAgICAgIGNvbnN0IGNvbmRpdGlvbiA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpLCB2YWx1ZSA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgICAgICAgIHJlc3VsdC5hbHRlcm5hdGl2ZXMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiBcIlNlbGVjdEFsdGVybmF0aXZlXCIsXG4gICAgICAgICAgICBjb25kaXRpb24sXG4gICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChyZXN1bHQuZmFsbGJhY2spXG4gICAgICAgICAgICB0aHJvdyBuZXcgR3JvcVF1ZXJ5RXJyb3IoXCJ1bmV4cGVjdGVkIGFyZ3VtZW50IHRvIHNlbGVjdCgpXCIpO1xuICAgICAgICAgIGNvbnN0IHZhbHVlID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgICAgICAgcmVzdWx0LmZhbGxiYWNrID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIHJldHVybiBwLnNoaWZ0KCksIHJlc3VsdDtcbiAgICB9XG4gICAgY29uc3QgYXJncyA9IFtdO1xuICAgIGZvciAoOyBwLmdldE1hcmsoKS5uYW1lICE9PSBcImZ1bmNfYXJnc19lbmRcIjsgKVxuICAgICAgYXJndW1lbnRTaG91bGRCZVNlbGVjdG9yKG5hbWVzcGFjZSwgbmFtZSwgYXJncy5sZW5ndGgpID8gKHAucHJvY2VzcyhTRUxFQ1RPUl9CVUlMREVSKSwgYXJncy5wdXNoKHsgdHlwZTogXCJTZWxlY3RvclwiIH0pKSA6IGFyZ3MucHVzaChwLnByb2Nlc3MoRVhQUl9CVUlMREVSKSk7XG4gICAgaWYgKHAuc2hpZnQoKSwgbmFtZXNwYWNlID09PSBcImdsb2JhbFwiICYmIChuYW1lID09PSBcImJlZm9yZVwiIHx8IG5hbWUgPT09IFwiYWZ0ZXJcIikgJiYgcC5wYXJzZU9wdGlvbnMubW9kZSA9PT0gXCJkZWx0YVwiKVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJDb250ZXh0XCIsXG4gICAgICAgIGtleTogbmFtZVxuICAgICAgfTtcbiAgICBpZiAobmFtZXNwYWNlID09PSBcImdsb2JhbFwiICYmIG5hbWUgPT09IFwiYm9vc3RcIiAmJiAhcC5hbGxvd0Jvb3N0KVxuICAgICAgdGhyb3cgbmV3IEdyb3FRdWVyeUVycm9yKFwidW5leHBlY3RlZCBib29zdFwiKTtcbiAgICBjb25zdCBmdW5jcyA9IG5hbWVzcGFjZXNbbmFtZXNwYWNlXTtcbiAgICBpZiAoIWZ1bmNzKVxuICAgICAgdGhyb3cgbmV3IEdyb3FRdWVyeUVycm9yKGBVbmRlZmluZWQgbmFtZXNwYWNlOiAke25hbWVzcGFjZX1gKTtcbiAgICBjb25zdCBmdW5jID0gZnVuY3NbbmFtZV07XG4gICAgaWYgKCFmdW5jKVxuICAgICAgdGhyb3cgbmV3IEdyb3FRdWVyeUVycm9yKGBVbmRlZmluZWQgZnVuY3Rpb246ICR7bmFtZX1gKTtcbiAgICBpZiAoZnVuYy5hcml0eSAhPT0gdm9pZCAwICYmIHZhbGlkYXRlQXJpdHkobmFtZSwgZnVuYy5hcml0eSwgYXJncy5sZW5ndGgpLCBmdW5jLm1vZGUgIT09IHZvaWQgMCAmJiBmdW5jLm1vZGUgIT09IHAucGFyc2VPcHRpb25zLm1vZGUpXG4gICAgICB0aHJvdyBuZXcgR3JvcVF1ZXJ5RXJyb3IoYFVuZGVmaW5lZCBmdW5jdGlvbjogJHtuYW1lfWApO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIkZ1bmNDYWxsXCIsXG4gICAgICBmdW5jLFxuICAgICAgbmFtZXNwYWNlLFxuICAgICAgbmFtZSxcbiAgICAgIGFyZ3NcbiAgICB9O1xuICB9LFxuICBwaXBlY2FsbChwKSB7XG4gICAgY29uc3QgYmFzZSA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIHAuc2hpZnQoKTtcbiAgICBsZXQgbmFtZXNwYWNlID0gXCJnbG9iYWxcIjtcbiAgICBpZiAocC5nZXRNYXJrKCkubmFtZSA9PT0gXCJuYW1lc3BhY2VcIiAmJiAocC5zaGlmdCgpLCBuYW1lc3BhY2UgPSBwLnByb2Nlc3NTdHJpbmcoKSksIG5hbWVzcGFjZSAhPT0gXCJnbG9iYWxcIilcbiAgICAgIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihgVW5kZWZpbmVkIG5hbWVzcGFjZTogJHtuYW1lc3BhY2V9YCk7XG4gICAgY29uc3QgbmFtZSA9IHAucHJvY2Vzc1N0cmluZygpLCBhcmdzID0gW10sIG9sZEFsbG93Qm9vc3QgPSBwLmFsbG93Qm9vc3Q7XG4gICAgZm9yIChuYW1lID09PSBcInNjb3JlXCIgJiYgKHAuYWxsb3dCb29zdCA9ICEwKTsgOyApIHtcbiAgICAgIGNvbnN0IG1hcmtOYW1lID0gcC5nZXRNYXJrKCkubmFtZTtcbiAgICAgIGlmIChtYXJrTmFtZSA9PT0gXCJmdW5jX2FyZ3NfZW5kXCIpXG4gICAgICAgIGJyZWFrO1xuICAgICAgaWYgKG5hbWUgPT09IFwib3JkZXJcIikge1xuICAgICAgICBpZiAobWFya05hbWUgPT09IFwiYXNjXCIpIHtcbiAgICAgICAgICBwLnNoaWZ0KCksIGFyZ3MucHVzaCh7IHR5cGU6IFwiQXNjXCIsIGJhc2U6IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpIH0pO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2UgaWYgKG1hcmtOYW1lID09PSBcImRlc2NcIikge1xuICAgICAgICAgIHAuc2hpZnQoKSwgYXJncy5wdXNoKHsgdHlwZTogXCJEZXNjXCIsIGJhc2U6IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpIH0pO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBhcmdzLnB1c2gocC5wcm9jZXNzKEVYUFJfQlVJTERFUikpO1xuICAgIH1cbiAgICBwLnNoaWZ0KCksIHAuYWxsb3dCb29zdCA9IG9sZEFsbG93Qm9vc3Q7XG4gICAgY29uc3QgZnVuYyA9IHBpcGVGdW5jdGlvbnNbbmFtZV07XG4gICAgaWYgKCFmdW5jKVxuICAgICAgdGhyb3cgbmV3IEdyb3FRdWVyeUVycm9yKGBVbmRlZmluZWQgcGlwZSBmdW5jdGlvbjogJHtuYW1lfWApO1xuICAgIHJldHVybiBmdW5jLmFyaXR5ICYmIHZhbGlkYXRlQXJpdHkobmFtZSwgZnVuYy5hcml0eSwgYXJncy5sZW5ndGgpLCB7XG4gICAgICB0eXBlOiBcIlBpcGVGdW5jQ2FsbFwiLFxuICAgICAgZnVuYyxcbiAgICAgIGJhc2UsXG4gICAgICBuYW1lLFxuICAgICAgYXJnc1xuICAgIH07XG4gIH0sXG4gIHBhaXIocCkge1xuICAgIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihcInVuZXhwZWN0ZWQgPT5cIik7XG4gIH0sXG4gIGFuZChwKSB7XG4gICAgY29uc3QgbGVmdCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpLCByaWdodCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIkFuZFwiLFxuICAgICAgbGVmdCxcbiAgICAgIHJpZ2h0XG4gICAgfTtcbiAgfSxcbiAgb3IocCkge1xuICAgIGNvbnN0IGxlZnQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKSwgcmlnaHQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJPclwiLFxuICAgICAgbGVmdCxcbiAgICAgIHJpZ2h0XG4gICAgfTtcbiAgfSxcbiAgbm90KHApIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJOb3RcIixcbiAgICAgIGJhc2U6IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpXG4gICAgfTtcbiAgfSxcbiAgYXNjKHApIHtcbiAgICB0aHJvdyBuZXcgR3JvcVF1ZXJ5RXJyb3IoXCJ1bmV4cGVjdGVkIGFzY1wiKTtcbiAgfSxcbiAgZGVzYyhwKSB7XG4gICAgdGhyb3cgbmV3IEdyb3FRdWVyeUVycm9yKFwidW5leHBlY3RlZCBkZXNjXCIpO1xuICB9LFxuICBwYXJhbShwKSB7XG4gICAgY29uc3QgbmFtZSA9IHAucHJvY2Vzc1N0cmluZygpO1xuICAgIHJldHVybiBwLnBhcnNlT3B0aW9ucy5wYXJhbXMgJiYgcC5wYXJzZU9wdGlvbnMucGFyYW1zLmhhc093blByb3BlcnR5KG5hbWUpID8ge1xuICAgICAgdHlwZTogXCJWYWx1ZVwiLFxuICAgICAgdmFsdWU6IHAucGFyc2VPcHRpb25zLnBhcmFtc1tuYW1lXVxuICAgIH0gOiB7XG4gICAgICB0eXBlOiBcIlBhcmFtZXRlclwiLFxuICAgICAgbmFtZVxuICAgIH07XG4gIH1cbn0sIE9CSkVDVF9CVUlMREVSID0ge1xuICBvYmplY3RfZXhwcihwKSB7XG4gICAgaWYgKHAuZ2V0TWFyaygpLm5hbWUgPT09IFwicGFpclwiKSB7XG4gICAgICBwLnNoaWZ0KCk7XG4gICAgICBjb25zdCBjb25kaXRpb24gPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKSwgdmFsdWUyID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcIk9iamVjdENvbmRpdGlvbmFsU3BsYXRcIixcbiAgICAgICAgY29uZGl0aW9uLFxuICAgICAgICB2YWx1ZTogdmFsdWUyXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCB2YWx1ZSA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIk9iamVjdEF0dHJpYnV0ZVZhbHVlXCIsXG4gICAgICBuYW1lOiBleHRyYWN0UHJvcGVydHlLZXkodmFsdWUpLFxuICAgICAgdmFsdWVcbiAgICB9O1xuICB9LFxuICBvYmplY3RfcGFpcihwKSB7XG4gICAgY29uc3QgbmFtZSA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIGlmIChuYW1lLnR5cGUgIT09IFwiVmFsdWVcIilcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIm5hbWUgbXVzdCBiZSBzdHJpbmdcIik7XG4gICAgY29uc3QgdmFsdWUgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJPYmplY3RBdHRyaWJ1dGVWYWx1ZVwiLFxuICAgICAgbmFtZTogbmFtZS52YWx1ZSxcbiAgICAgIHZhbHVlXG4gICAgfTtcbiAgfSxcbiAgb2JqZWN0X3NwbGF0KHApIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJPYmplY3RTcGxhdFwiLFxuICAgICAgdmFsdWU6IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpXG4gICAgfTtcbiAgfSxcbiAgb2JqZWN0X3NwbGF0X3RoaXMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiT2JqZWN0U3BsYXRcIixcbiAgICAgIHZhbHVlOiB7IHR5cGU6IFwiVGhpc1wiIH1cbiAgICB9O1xuICB9XG59LCBUUkFWRVJTRV9CVUlMREVSID0ge1xuICBzcXVhcmVfYnJhY2tldChwKSB7XG4gICAgY29uc3QgZXhwciA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpLCB2YWx1ZSA9IHRyeUNvbnN0YW50RXZhbHVhdGUoZXhwcik7XG4gICAgcmV0dXJuIHZhbHVlICYmIHZhbHVlLnR5cGUgPT09IFwibnVtYmVyXCIgPyAocmlnaHQpID0+IHRyYXZlcnNlRWxlbWVudCgoYmFzZSkgPT4gKHsgdHlwZTogXCJBY2Nlc3NFbGVtZW50XCIsIGJhc2UsIGluZGV4OiB2YWx1ZS5kYXRhIH0pLCByaWdodCkgOiB2YWx1ZSAmJiB2YWx1ZS50eXBlID09PSBcInN0cmluZ1wiID8gKHJpZ2h0KSA9PiB0cmF2ZXJzZVBsYWluKChiYXNlKSA9PiAoeyB0eXBlOiBcIkFjY2Vzc0F0dHJpYnV0ZVwiLCBiYXNlLCBuYW1lOiB2YWx1ZS5kYXRhIH0pLCByaWdodCkgOiAocmlnaHQpID0+IHRyYXZlcnNlQXJyYXkoXG4gICAgICAoYmFzZSkgPT4gKHtcbiAgICAgICAgdHlwZTogXCJGaWx0ZXJcIixcbiAgICAgICAgYmFzZSxcbiAgICAgICAgZXhwclxuICAgICAgfSksXG4gICAgICByaWdodFxuICAgICk7XG4gIH0sXG4gIHNsaWNlKHApIHtcbiAgICBjb25zdCBpc0luY2x1c2l2ZSA9IHAuZ2V0TWFyaygpLm5hbWUgPT09IFwiaW5jX3JhbmdlXCI7XG4gICAgcC5zaGlmdCgpO1xuICAgIGNvbnN0IGxlZnQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKSwgcmlnaHQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKSwgbGVmdFZhbHVlID0gdHJ5Q29uc3RhbnRFdmFsdWF0ZShsZWZ0KSwgcmlnaHRWYWx1ZSA9IHRyeUNvbnN0YW50RXZhbHVhdGUocmlnaHQpO1xuICAgIGlmICghbGVmdFZhbHVlIHx8ICFyaWdodFZhbHVlIHx8IGxlZnRWYWx1ZS50eXBlICE9PSBcIm51bWJlclwiIHx8IHJpZ2h0VmFsdWUudHlwZSAhPT0gXCJudW1iZXJcIilcbiAgICAgIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihcInNsaWNpbmcgbXVzdCB1c2UgY29uc3RhbnQgbnVtYmVyc1wiKTtcbiAgICByZXR1cm4gKHJocykgPT4gdHJhdmVyc2VBcnJheShcbiAgICAgIChiYXNlKSA9PiAoe1xuICAgICAgICB0eXBlOiBcIlNsaWNlXCIsXG4gICAgICAgIGJhc2UsXG4gICAgICAgIGxlZnQ6IGxlZnRWYWx1ZS5kYXRhLFxuICAgICAgICByaWdodDogcmlnaHRWYWx1ZS5kYXRhLFxuICAgICAgICBpc0luY2x1c2l2ZVxuICAgICAgfSksXG4gICAgICByaHNcbiAgICApO1xuICB9LFxuICBwcm9qZWN0aW9uKHApIHtcbiAgICBjb25zdCBvYmogPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICByZXR1cm4gKHJpZ2h0KSA9PiB0cmF2ZXJzZVByb2plY3Rpb24oKGJhc2UpID0+ICh7IHR5cGU6IFwiUHJvamVjdGlvblwiLCBiYXNlLCBleHByOiBvYmogfSksIHJpZ2h0KTtcbiAgfSxcbiAgYXR0cl9hY2Nlc3MocCkge1xuICAgIGNvbnN0IG5hbWUgPSBwLnByb2Nlc3NTdHJpbmcoKTtcbiAgICByZXR1cm4gKHJpZ2h0KSA9PiB0cmF2ZXJzZVBsYWluKChiYXNlKSA9PiAoeyB0eXBlOiBcIkFjY2Vzc0F0dHJpYnV0ZVwiLCBiYXNlLCBuYW1lIH0pLCByaWdodCk7XG4gIH0sXG4gIGRlcmVmKHApIHtcbiAgICBsZXQgYXR0ciA9IG51bGw7XG4gICAgcC5nZXRNYXJrKCkubmFtZSA9PT0gXCJkZXJlZl9hdHRyXCIgJiYgKHAuc2hpZnQoKSwgYXR0ciA9IHAucHJvY2Vzc1N0cmluZygpKTtcbiAgICBjb25zdCB3cmFwID0gKGJhc2UpID0+IGF0dHIgPyB7IHR5cGU6IFwiQWNjZXNzQXR0cmlidXRlXCIsIGJhc2UsIG5hbWU6IGF0dHIgfSA6IGJhc2U7XG4gICAgcmV0dXJuIChyaWdodCkgPT4gdHJhdmVyc2VQbGFpbihcbiAgICAgIChiYXNlKSA9PiB3cmFwKHtcbiAgICAgICAgdHlwZTogXCJEZXJlZlwiLFxuICAgICAgICBiYXNlXG4gICAgICB9KSxcbiAgICAgIHJpZ2h0XG4gICAgKTtcbiAgfSxcbiAgYXJyYXlfcG9zdGZpeChwKSB7XG4gICAgcmV0dXJuIChyaWdodCkgPT4gdHJhdmVyc2VBcnJheSgoYmFzZSkgPT4gKHsgdHlwZTogXCJBcnJheUNvZXJjZVwiLCBiYXNlIH0pLCByaWdodCk7XG4gIH1cbn0sIFNFTEVDVE9SX0JVSUxERVIgPSB7XG4gIGdyb3VwKHApIHtcbiAgICByZXR1cm4gcC5wcm9jZXNzKFNFTEVDVE9SX0JVSUxERVIpLCBudWxsO1xuICB9LFxuICBldmVyeXRoaW5nKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICB9LFxuICB0aGlzKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICB9LFxuICBwYXJlbnQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIGRibHBhcmVudChwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIHRyYXZlcnNlKHApIHtcbiAgICBmb3IgKHAucHJvY2VzcyhTRUxFQ1RPUl9CVUlMREVSKTsgcC5nZXRNYXJrKCkubmFtZSAhPT0gXCJ0cmF2ZXJzYWxfZW5kXCI7IClcbiAgICAgIHAucHJvY2VzcyhUUkFWRVJTRV9CVUlMREVSKTtcbiAgICByZXR1cm4gcC5zaGlmdCgpLCBudWxsO1xuICB9LFxuICB0aGlzX2F0dHIocCkge1xuICAgIHJldHVybiBwLnByb2Nlc3NTdHJpbmcoKSwgbnVsbDtcbiAgfSxcbiAgbmVnKHApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgcG9zKHApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgYWRkKHApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgc3ViKHApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgbXVsKHApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgZGl2KHApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgbW9kKHApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgcG93KHApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgY29tcChwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIGluX3JhbmdlKHApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgc3RyKHApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgaW50ZWdlcihwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIGZsb2F0KHApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgc2NpKHApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgb2JqZWN0KHApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgYXJyYXkocCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICB9LFxuICB0dXBsZShwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIGZ1bmNfY2FsbChwLCBtYXJrKSB7XG4gICAgY29uc3QgZnVuYyA9IEVYUFJfQlVJTERFUi5mdW5jX2NhbGwocCwgbWFyayk7XG4gICAgaWYgKGZ1bmMubmFtZSA9PT0gXCJhbnl3aGVyZVwiICYmIGZ1bmMuYXJncy5sZW5ndGggPT09IDEpXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgcGlwZWNhbGwocCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICB9LFxuICBwYWlyKHApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgYW5kKHApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgb3IocCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICB9LFxuICBub3QocCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICB9LFxuICBhc2MocCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICB9LFxuICBkZXNjKHApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgcGFyYW0ocCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICB9XG59O1xuZnVuY3Rpb24gZXh0cmFjdFByb3BlcnR5S2V5KG5vZGUpIHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gXCJBY2Nlc3NBdHRyaWJ1dGVcIiAmJiAhbm9kZS5iYXNlKVxuICAgIHJldHVybiBub2RlLm5hbWU7XG4gIGlmIChub2RlLnR5cGUgPT09IFwiRGVyZWZcIiB8fCBub2RlLnR5cGUgPT09IFwiTWFwXCIgfHwgbm9kZS50eXBlID09PSBcIlByb2plY3Rpb25cIiB8fCBub2RlLnR5cGUgPT09IFwiU2xpY2VcIiB8fCBub2RlLnR5cGUgPT09IFwiRmlsdGVyXCIgfHwgbm9kZS50eXBlID09PSBcIkFjY2Vzc0VsZW1lbnRcIiB8fCBub2RlLnR5cGUgPT09IFwiQXJyYXlDb2VyY2VcIilcbiAgICByZXR1cm4gZXh0cmFjdFByb3BlcnR5S2V5KG5vZGUuYmFzZSk7XG4gIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihgQ2Fubm90IGRldGVybWluZSBwcm9wZXJ0eSBrZXkgZm9yIHR5cGU6ICR7bm9kZS50eXBlfWApO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVBcml0eShuYW1lLCBhcml0eSwgY291bnQpIHtcbiAgaWYgKHR5cGVvZiBhcml0eSA9PSBcIm51bWJlclwiKSB7XG4gICAgaWYgKGNvdW50ICE9PSBhcml0eSlcbiAgICAgIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihcbiAgICAgICAgYEluY29ycmVjdCBudW1iZXIgb2YgYXJndW1lbnRzIHRvIGZ1bmN0aW9uICR7bmFtZX0oKS4gRXhwZWN0ZWQgJHthcml0eX0sIGdvdCAke2NvdW50fS5gXG4gICAgICApO1xuICB9IGVsc2UgaWYgKGFyaXR5ICYmICFhcml0eShjb3VudCkpXG4gICAgdGhyb3cgbmV3IEdyb3FRdWVyeUVycm9yKGBJbmNvcnJlY3QgbnVtYmVyIG9mIGFyZ3VtZW50cyB0byBmdW5jdGlvbiAke25hbWV9KCkuYCk7XG59XG5mdW5jdGlvbiBhcmd1bWVudFNob3VsZEJlU2VsZWN0b3IobmFtZXNwYWNlLCBmdW5jdGlvbk5hbWUsIGFyZ0NvdW50KSB7XG4gIGNvbnN0IGZ1bmN0aW9uc1JlcXVpcmluZ1NlbGVjdG9ycyA9IFtcImNoYW5nZWRBbnlcIiwgXCJjaGFuZ2VkT25seVwiXTtcbiAgcmV0dXJuIG5hbWVzcGFjZSA9PSBcImRpZmZcIiAmJiBhcmdDb3VudCA9PSAyICYmIGZ1bmN0aW9uc1JlcXVpcmluZ1NlbGVjdG9ycy5pbmNsdWRlcyhmdW5jdGlvbk5hbWUpO1xufVxuY2xhc3MgR3JvcVN5bnRheEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3Rvcihwb3NpdGlvbikge1xuICAgIHN1cGVyKGBTeW50YXggZXJyb3IgaW4gR1JPUSBxdWVyeSBhdCBwb3NpdGlvbiAke3Bvc2l0aW9ufWApLCBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwicG9zaXRpb25cIiksIF9fcHVibGljRmllbGQodGhpcywgXCJuYW1lXCIsIFwiR3JvcVN5bnRheEVycm9yXCIpLCB0aGlzLnBvc2l0aW9uID0gcG9zaXRpb247XG4gIH1cbn1cbmZ1bmN0aW9uIHBhcnNlKGlucHV0LCBvcHRpb25zID0ge30pIHtcbiAgY29uc3QgcmVzdWx0ID0gcGFyc2UkMShpbnB1dCk7XG4gIGlmIChyZXN1bHQudHlwZSA9PT0gXCJlcnJvclwiKVxuICAgIHRocm93IG5ldyBHcm9xU3ludGF4RXJyb3IocmVzdWx0LnBvc2l0aW9uKTtcbiAgcmV0dXJuIG5ldyBNYXJrUHJvY2Vzc29yKGlucHV0LCByZXN1bHQubWFya3MsIG9wdGlvbnMpLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbn1cbmV4cG9ydCB7XG4gIERhdGVUaW1lLFxuICBQYXRoLFxuICBldmFsdWF0ZVF1ZXJ5IGFzIGV2YWx1YXRlLFxuICBwYXJzZVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPTEubWpzLm1hcFxuIl0sIm5hbWVzIjpbIl9fZGVmUHJvcCQ1IiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJfX2RlZk5vcm1hbFByb3AkNSIsIm9iaiIsImtleSIsInZhbHVlIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiX19wdWJsaWNGaWVsZCQ1IiwiZXNjYXBlUmVnRXhwIiwic3RyaW5nIiwicmVwbGFjZSIsInBhdGhSZWdFeHAiLCJwYXR0ZXJuIiwicmUiLCJwYXJ0Iiwic3BsaXQiLCJwdXNoIiwiUmVnRXhwIiwiam9pbiIsIlBhdGgiLCJjb25zdHJ1Y3RvciIsInBhdHRlcm5SZSIsIm1hdGNoZXMiLCJzdHIiLCJ0ZXN0IiwidG9KU09OIiwiX19kZWZQcm9wJDQiLCJfX2RlZk5vcm1hbFByb3AkNCIsIl9fcHVibGljRmllbGQkNCIsIlN0cmVhbVZhbHVlIiwiZ2VuZXJhdG9yIiwidGlja2VyIiwiaXNEb25lIiwiZGF0YSIsImlzQXJyYXkiLCJnZXQiLCJyZXN1bHQiLCJTeW1ib2wiLCJhc3luY0l0ZXJhdG9yIiwiaSIsImxlbmd0aCIsIl9uZXh0VGljayIsImN1cnJlbnRSZXNvbHZlciIsInNldHVwVGlja2VyIiwiUHJvbWlzZSIsInJlc29sdmUiLCJ0aWNrIiwiZmV0Y2giLCJSRkMzMzM5X1JFR0VYIiwicGFyc2VSRkMzMzM5IiwiRGF0ZSIsImZvcm1hdFJGQzMzMzkiLCJkIiwieWVhciIsImFkZExlYWRpbmdaZXJvIiwiZ2V0VVRDRnVsbFllYXIiLCJtb250aCIsImdldFVUQ01vbnRoIiwiZGF5IiwiZ2V0VVRDRGF0ZSIsImhvdXIiLCJnZXRVVENIb3VycyIsIm1pbnV0ZSIsImdldFVUQ01pbnV0ZXMiLCJzZWNvbmQiLCJnZXRVVENTZWNvbmRzIiwiZnJhY3Rpb25hbFNlY29uZCIsIm1pbGxpcyIsImdldE1pbGxpc2Vjb25kcyIsIm51bSIsInRhcmdldExlbmd0aCIsInRvU3RyaW5nIiwiX19kZWZQcm9wJDMiLCJfX2RlZk5vcm1hbFByb3AkMyIsIl9fcHVibGljRmllbGQkMyIsIlN0YXRpY1ZhbHVlIiwidHlwZSIsIkFycmF5IiwiZWxlbWVudCIsImZyb21KUyIsIkVycm9yIiwiTlVMTF9WQUxVRSIsIlRSVUVfVkFMVUUiLCJGQUxTRV9WQUxVRSIsIkRhdGVUaW1lIiwiZGF0ZSIsInBhcnNlVG9WYWx1ZSIsImVxdWFscyIsIm90aGVyIiwiZ2V0VGltZSIsImFkZCIsInNlY3MiLCJjb3B5Iiwic2V0VGltZSIsImRpZmZlcmVuY2UiLCJjb21wYXJlVG8iLCJmcm9tTnVtYmVyIiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJmcm9tU3RyaW5nIiwiZnJvbURhdGVUaW1lIiwiZHQiLCJmcm9tUGF0aCIsInBhdGgiLCJpc0l0ZXJhdG9yIiwibmV4dCIsInZhbCIsImdldFR5cGUiLCJpc0VxdWFsIiwiYSIsImIiLCJDSEFSUyIsIkNIQVJTX1dJVEhfV0lMRENBUkQiLCJFREdFX0NIQVJTIiwiTUFYX1RFUk1fTEVOR1RIIiwibWF0Y2hUZXh0IiwidG9rZW5zIiwicGF0dGVybnMiLCJldmVyeSIsIm1hdGNoVG9rZW5pemUiLCJ0ZXh0IiwibWF0Y2giLCJtYXRjaEFuYWx5emVQYXR0ZXJuIiwibWF0Y2hQYXR0ZXJuUmVnZXgiLCJtYXAiLCJzb21lIiwidG9rZW4iLCJ0ZXJtIiwic2xpY2UiLCJnYXRoZXJUZXh0IiwiY2IiLCJzdWNjZXNzIiwiVFlQRV9PUkRFUiIsImRhdGV0aW1lIiwibnVtYmVyIiwiYm9vbGVhbiIsInBhcnRpYWxDb21wYXJlIiwiYVR5cGUiLCJiVHlwZSIsInRvdGFsQ29tcGFyZSIsImFUeXBlT3JkZXIiLCJiVHlwZU9yZGVyIiwib3BlcmF0b3JzIiwibGVmdCIsInJpZ2h0IiwiaW4iLCJjb25jYXQiLCJudW1lcmljT3BlcmF0b3IiLCJNYXRoIiwicG93IiwiaW1wbCIsIl9fZGVmUHJvcCQyIiwiX19kZWZOb3JtYWxQcm9wJDIiLCJfX3B1YmxpY0ZpZWxkJDIiLCJTY29wZSIsInBhcmFtcyIsInNvdXJjZSIsImNvbnRleHQiLCJwYXJlbnQiLCJjcmVhdGVOZXN0ZWQiLCJpc0hpZGRlbiIsImNyZWF0ZUhpZGRlbiIsImV2YWx1YXRlIiwibm9kZSIsInNjb3BlIiwiZXhlY3V0ZSIsImZ1bmMiLCJFWEVDVVRPUlMiLCJwcm9taXNlbGVzc0FwcGx5IiwidGhlbiIsIlRoaXMiLCJfIiwiU2VsZWN0b3IiLCJFdmVyeXRoaW5nIiwiUGFyYW1ldGVyIiwibmFtZSIsIkNvbnRleHQiLCJQYXJlbnQiLCJuIiwiY3VycmVudCIsIk9wQ2FsbCIsIm9wIiwibGVmdFZhbHVlIiwicmlnaHRWYWx1ZSIsIlNlbGVjdCIsImFsdGVybmF0aXZlcyIsImZhbGxiYWNrIiwiYWx0IiwiYWx0Q29uZCIsImNvbmRpdGlvbiIsIkluUmFuZ2UiLCJiYXNlIiwiaXNJbmNsdXNpdmUiLCJsZWZ0Q21wIiwicmlnaHRDbXAiLCJGaWx0ZXIiLCJleHByIiwiYmFzZVZhbHVlIiwiZWxlbSIsIm5ld1Njb3BlIiwiZXhwclZhbHVlIiwiUHJvamVjdGlvbiIsIkZ1bmNDYWxsIiwiYXJncyIsIlBpcGVGdW5jQ2FsbCIsIkFjY2Vzc0F0dHJpYnV0ZSIsImhhc093blByb3BlcnR5IiwiQWNjZXNzRWxlbWVudCIsImluZGV4IiwiZmluYWxJbmRleCIsIlNsaWNlIiwiYXJyYXkyIiwibGVmdElkeCIsInJpZ2h0SWR4IiwiRGVyZWYiLCJpZCIsIl9yZWYiLCJkZXJlZmVyZW5jZSIsImRvYyIsIl9pZCIsIlZhbHVlIiwiR3JvdXAiLCJhdHRyaWJ1dGVzIiwiYXR0ciIsImF0dHJUeXBlIiwiY29uZCIsImFzc2lnbiIsImVsZW1lbnRzIiwiaXNTcGxhdCIsInYiLCJUdXBsZSIsIk9yIiwiQW5kIiwiTm90IiwiTmVnIiwiUG9zIiwiQXNjIiwiRGVzYyIsIkFycmF5Q29lcmNlIiwiTWFwIiwiRmxhdE1hcCIsImlubmVyVmFsdWUiLCJpbm5lciIsImV2YWx1YXRlUXVlcnkiLCJ0cmVlIiwib3B0aW9ucyIsInJvb3QiLCJkYXRhc2V0IiwidGltZXN0YW1wIiwiaWRlbnRpdHkiLCJzYW5pdHkiLCJhZnRlciIsImJlZm9yZSIsImNhbkNvbnN0YW50RXZhbHVhdGUiLCJEVU1NWV9TQ09QRSIsInRyeUNvbnN0YW50RXZhbHVhdGUiLCJjb25zdGFudEV2YWx1YXRlIiwicG9ydGFibGVUZXh0Q29udGVudCIsImJsb2NrVGV4dCIsInRleHRzIiwiYXJyYXlUZXh0IiwiYmxvY2siLCJfdHlwZSIsImNoaWxkcmVuIiwiY2hpbGQiLCJCTTI1ayIsImV2YWx1YXRlU2NvcmUiLCJldmFsdWF0ZU1hdGNoU2NvcmUiLCJpbm5lclNjb3JlIiwiYm9vc3QiLCJsZWZ0U2NvcmUiLCJyaWdodFNjb3JlIiwicmVzIiwidGVybXMiLCJzY29yZSIsImZyZXEiLCJyZWR1Y2UiLCJjIiwiaGFzUmVmZXJlbmNlIiwicGF0aFNldCIsImhhcyIsInZhbHVlcyIsImNvdW50VVRGOCIsImNvdW50MiIsImNvZGUiLCJjaGFyQ29kZUF0IiwiX2dsb2JhbCIsImFueXdoZXJlIiwiYXJpdHkiLCJjb2FsZXNjZSIsImFyZyIsImNvdW50IiwiZGF0ZVRpbWUiLCJkZWZpbmVkIiwicmVmZXJlbmNlcyIsIlNldCIsInBhdGgyIiwic2l6ZSIsInNjb3BlVmFsdWUiLCJyb3VuZCIsInByZWMiLCJwcmVjVmFsdWUiLCJpc0ludGVnZXIiLCJ0b0ZpeGVkIiwibm93IiwidG9JU09TdHJpbmciLCJzdHJpbmcyIiwibG93ZXIiLCJ0b0xvd2VyQ2FzZSIsInVwcGVyIiwidG9VcHBlckNhc2UiLCJzZXAiLCJmcm9tIiwic3RhcnRzV2l0aCIsInByZWZpeCIsImFycmF5IiwiYXJyIiwiYnVmIiwibmVlZFNlcCIsImNvbXBhY3QiLCJ1bmlxdWUiLCJhZGRlZCIsIml0ZXIiLCJwdCIsInByb2plY3RJZCIsInBpcGVGdW5jdGlvbnMiLCJvcmRlciIsIm1hcHBlcnMiLCJkaXJlY3Rpb25zIiwibWFwcGVyIiwiZGlyZWN0aW9uIiwiYXV4IiwiaWR4IiwidHVwbGUiLCJzb3J0IiwiYVR1cGxlIiwiYlR1cGxlIiwidW5rbm93biIsInNjb3JlZCIsInZhbHVlU2NvcmUiLCJfc2NvcmUiLCJuZXdPYmplY3QiLCJkZWx0YSIsIm9wZXJhdGlvbiIsImhhc0JlZm9yZSIsImhhc0FmdGVyIiwiY2hhbmdlZEFueSIsIm1vZGUiLCJjaGFuZ2VkT25seSIsImRpZmYiLCJtYXRoIiwibWluIiwibWF4Iiwic3VtIiwiYXZnIiwiZGF0ZVRpbWUyIiwibmFtZXNwYWNlcyIsImdsb2JhbCIsIl9fZGVmUHJvcCQxIiwiX19kZWZOb3JtYWxQcm9wJDEiLCJfX3B1YmxpY0ZpZWxkJDEiLCJNYXJrUHJvY2Vzc29yIiwibWFya3MiLCJwYXJzZU9wdGlvbnMiLCJoYXNNYXJrIiwicG9zIiwiZ2V0TWFyayIsInNoaWZ0IiwicHJvY2VzcyIsInZpc2l0b3IiLCJtYXJrIiwiY2FsbCIsInByb2Nlc3NTdHJpbmciLCJwcm9jZXNzU3RyaW5nRW5kIiwicHJldiIsImN1cnIiLCJwb3NpdGlvbiIsImxlbiIsIldTIiwiTlVNIiwiSURFTlQiLCJwYXJzZSQxIiwic2tpcFdTIiwicGFyc2VFeHByIiwiZmFpbFBvc2l0aW9uIiwibGV2ZWwiLCJzdGFydFBvcyIsInJocyIsInBhcnNlT2JqZWN0IiwicGFyc2VTdHJpbmciLCJpZGVudExlbiIsInBhcnNlUmVnZXgiLCJudW1MZW4iLCJmcmFjTGVuIiwiZXhwTGVuIiwicGFyc2VGdW5jQ2FsbCIsImxoc0xldmVsIiwidHJhdiIsImxvb3AiLCJpbm5lclBvcyIsInBhcnNlVHJhdmVyc2FsIiwidW5zaGlmdCIsInJoczIiLCJuZXh0UG9zIiwiaWRlbnRQb3MiLCJwYXJzZVJlZ2V4U3RyIiwiaXNHcm91cCIsInJhbmdlUG9zIiwiaWRlbnRTdGFydCIsImlkZW50TGVuMiIsIm5hbWVMZW4iLCJsYXN0UG9zIiwicGFpclBvcyIsImluZGV4T2YiLCJtIiwiZXhlYyIsImZsYXRNYXAiLCJ0cmF2ZXJzZUFycmF5IiwiYnVpbGQiLCJ0cmF2ZXJzZVBsYWluIiwidHJhdmVyc2VFbGVtZW50IiwidHJhdmVyc2VQcm9qZWN0aW9uIiwiX19kZWZQcm9wIiwiX19kZWZOb3JtYWxQcm9wIiwiX19wdWJsaWNGaWVsZCIsIkVTQ0FQRV9TRVFVRU5DRSIsImYiLCJyIiwidCIsImV4cGFuZEhleCIsImNoYXJDb2RlIiwicGFyc2VJbnQiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJHcm9xUXVlcnlFcnJvciIsImFyZ3VtZW50cyIsIkVYUFJfQlVJTERFUiIsImdyb3VwIiwicCIsImV2ZXJ5dGhpbmciLCJ0aGlzIiwiZGJscGFyZW50IiwidHJhdmVyc2UiLCJ0cmF2ZXJzYWxMaXN0IiwiVFJBVkVSU0VfQlVJTERFUiIsInRyYXZlcnNhbCIsInRoaXNfYXR0ciIsIm5lZyIsInN1YiIsIm11bCIsImRpdiIsIm1vZCIsImNvbXAiLCJpbl9yYW5nZSIsImNoYXIiLCJpbnRlZ2VyIiwic3RyVmFsdWUiLCJmbG9hdCIsInNjaSIsIm9iamVjdCIsIk9CSkVDVF9CVUlMREVSIiwibWVtYmVycyIsImZ1bmNfY2FsbCIsIm5hbWVzcGFjZSIsImFyZ3VtZW50U2hvdWxkQmVTZWxlY3RvciIsIlNFTEVDVE9SX0JVSUxERVIiLCJhbGxvd0Jvb3N0IiwiZnVuY3MiLCJ2YWxpZGF0ZUFyaXR5IiwicGlwZWNhbGwiLCJvbGRBbGxvd0Jvb3N0IiwibWFya05hbWUiLCJwYWlyIiwiYW5kIiwib3IiLCJub3QiLCJhc2MiLCJkZXNjIiwicGFyYW0iLCJvYmplY3RfZXhwciIsInZhbHVlMiIsImV4dHJhY3RQcm9wZXJ0eUtleSIsIm9iamVjdF9wYWlyIiwib2JqZWN0X3NwbGF0Iiwib2JqZWN0X3NwbGF0X3RoaXMiLCJzcXVhcmVfYnJhY2tldCIsInByb2plY3Rpb24iLCJhdHRyX2FjY2VzcyIsImRlcmVmIiwid3JhcCIsImFycmF5X3Bvc3RmaXgiLCJmdW5jdGlvbk5hbWUiLCJhcmdDb3VudCIsImZ1bmN0aW9uc1JlcXVpcmluZ1NlbGVjdG9ycyIsImluY2x1ZGVzIiwiR3JvcVN5bnRheEVycm9yIiwicGFyc2UiLCJpbnB1dCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/groq-js/dist/1.mjs\n");

/***/ })

};
;